<!DOCTYPE html>
<html>
<head>
<!--
⣀⡀ ⢀⣀ ⢀⣀ ⡀⢀ ⢀⡀ ⣰⡀
⠇⠸ ⠣⠼ ⠣⠤ ⣑⡺ ⠣⠜ ⠘⠤

Copyright © 2013- nacyot<Daekwon Kim> All Rights Reserved.
-->
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<meta content='target-densitydpi=device-dpi, width=device-width, maximum-scale=0.9, user-scalable=yes' name='viewport'>
<link href='/images/favicon.ico' rel='shortcut icon' type='image/x-icon'>
<link href='http://blog.nacyot.com/articles/2015-12-07-ruby-proc-and-lambda/' rel='canonical'>
<link href='http://blog.nacyot.com/feed.xml' rel='alternate' title='nacyot의 프로그래밍 이야기 RSS Feed' type='application/rss+xml'>
<link href='/articles/2015-12-02-programming-is-difficult/' rel='prev' title="프로그래밍은 왜 어려운가 - 벤 프라이(Ben Fry)의 Distellamap으로 생각해보는 다익스트라의 'GOTO문은 해롭다(Go To Statement Considered Harmful)'">
<link href='/articles/2015-12-09-incremental-search-tool-peco/' rel='next' title='증분검색을 통한 텍스트 필터링 도구 페코(Peco) - 명령어 히스토리를 비롯한 셸(shell) 어디서나 증분검색하기'>
<meta content='루비 Advent Calendar 2015 7일차로 참석합니다.루비에서 가장 특징적이고 많이 사용되는 문법이 바로 블록입니다. 루비에서는 블록 문법을 통해서 하나의 익명 함수를 손쉽게 함수에 넘겨줄 수 있습니다. 대부분의 반복문을 비롯해 인터페이스로도 자주 사용되기 때문에 익명 함수 개념을 이해하는 것은 매우 중요합니다. 블록을 사용하지 않더라도 루비에서는 명시적으로 익명 함수 객체를 생성할 수 있습니다. 익명 함수를 만드는 두 가지 대표적인 방법이 바로 Proc 객체와 lambda문을 사용하는 것입니다. 이 글에서는 루비에서의 익명 함수와 Proc 객체와 lambda문으로 생성된 익명 함수의 차이점을 살펴보겠습니다.' name='description'>
<link href='https://plus.google.com/+KimDaekwon' rel='author'>
<link href='https://plus.google.com/+KimDaekwon' rel='publisher'>
<meta content='summary' name='twitter:card'>
<meta content='article' property='og:type'>
<meta content='nacyot의 프로그래밍 이야기 :: 루비와 익명 함수 -  블록(block), Proc(절차, procedure) 객체와 람다(lambda) 함수의 차이 이해하기' name='twitter:title'>
<meta content='nacyot의 프로그래밍 이야기 :: 루비와 익명 함수 -  블록(block), Proc(절차, procedure) 객체와 람다(lambda) 함수의 차이 이해하기' property='og:title'>
<meta content='루비 Advent Calendar 2015 7일차로 참석합니다.루비에서 가장 특징적이고 많이 사용되는 문법이 바로 블록입니다. 루비에서는 블록 문법을 통해서 하나의 익명 함수를 손쉽게 함수에 넘겨줄 수 있습니다. 대부분의 반복문을 비롯해 인터페이스로도 자주 사용되기 때문에 익명 함수 개념을 이해하는 것은 매우 중요합니다. 블록을 사용하지 않더라도 루비에서는 명시적으로 익명 함수 객체를 생성할 수 있습니다. 익명 함수를 만드는 두 가지 대표적인 방법이 바로 Proc 객체와 lambda문을 사용하는 것입니다. 이 글에서는 루비에서의 익명 함수와 Proc 객체와 lambda문으로 생성된 익명 함수의 차이점을 살펴보겠습니다.' name='twitter:description'>
<meta content='루비 Advent Calendar 2015 7일차로 참석합니다.루비에서 가장 특징적이고 많이 사용되는 문법이 바로 블록입니다. 루비에서는 블록 문법을 통해서 하나의 익명 함수를 손쉽게 함수에 넘겨줄 수 있습니다. 대부분의 반복문을 비롯해 인터페이스로도 자주 사용되기 때문에 익명 함수 개념을 이해하는 것은 매우 중요합니다. 블록을 사용하지 않더라도 루비에서는 명시적으로 익명 함수 객체를 생성할 수 있습니다. 익명 함수를 만드는 두 가지 대표적인 방법이 바로 Proc 객체와 lambda문을 사용하는 것입니다. 이 글에서는 루비에서의 익명 함수와 Proc 객체와 lambda문으로 생성된 익명 함수의 차이점을 살펴보겠습니다.' property='og:description'>
<meta content='@nacyo_t' name='twitter:site'>
<meta content='nacyot의 프로그래밍 이야기' property='og:site_name'>
<meta content='http://blog.nacyot.com/articles/2015-12-07-ruby-proc-and-lambda/' name='twitter:url'>
<meta content='http://blog.nacyot.com/articles/2015-12-07-ruby-proc-and-lambda/' property='og:url'>
<meta content='http://i.imgur.com/TVYlS05.png' name='twitter:image'>
<meta content='http://i.imgur.com/TVYlS05.png' property='og:image'>
<meta content='programming, lambda, ruby, proc, block, anonymous_function, javascript' name='keywords'>
<title>nacyot의 프로그래밍 이야기 :: 루비와 익명 함수 -  블록(block), Proc(절차, procedure) 객체와 람다(lambda) 함수의 차이 이해하기</title>
<link href="../../stylesheets/all.css" media="all" rel="stylesheet" type="text/css" />
<script src="../../javascripts/all.js" type="text/javascript"></script>
<link href='http://fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-46785477-2', 'auto');
  ga('send', 'pageview');
</script>
</head>
<body>
<div class='categories' id='categories-title'>
<a href='/tags/news' title='새소식(News) 목록'>
<div class='category-news category-title' style='width: 12.5%'>
<i class='fa fa-newspaper-o'></i>
</div>
</a>
<a href='/tags/visualization' title='시각화(Visualization) 목록'>
<div class='category-title category-visualization' style='width: 12.5%'>
<i class='fa fa-bar-chart'></i>
</div>
</a>
<a href='/tags/infrastructure' title='시스템(Infrastructure) 목록'>
<div class='category-infrastructure category-title' style='width: 12.5%'>
<i class='fa fa-cloud'></i>
</div>
</a>
<a href='/tags/programming' title='프로그래밍(Programming) 목록'>
<div class='category-programming category-title' style='width: 12.5%'>
<i class='fa fa-desktop'></i>
</div>
</a>
<a href='/tags/software' title='소프트웨어(software) 목록'>
<div class='category-software category-title' style='width: 12.5%'>
<i class='fa fa-square-o'></i>
</div>
</a>
<a href='/tags/service' title='서비스(Services) 목록'>
<div class='category-service category-title' style='width: 12.5%'>
<i class='fa fa-cubes'></i>
</div>
</a>
<a href='/tags/editor' title='에디터(Editor) 목록'>
<div class='category-editor category-title' style='width: 12.5%'>
<i class='fa fa-edit'></i>
</div>
</a>
<a href='/tags/article' title='이야기(Articles) 목록'>
<div class='category-book category-title' style='width: 12.5%'>
<i class='fa fa-book'></i>
</div>
</a>
</div>
<div class='wall'>
<h1 class='title'>
<a href="/"><img alt='nacyot profile image' class='img-rounded profile_image' src='/images/nacyot.jpeg'>
<span class='hidden-sm hidden-xs'>
nacyot의 프로그래밍 이야기
</span>
</a>
</h1>
</div>

<div class='row'>
<div class='col-lg-2 col-md-2'></div>
<div class='col-lg-8 col-md-8 col-sm-12 col-xs-12'>
<div class='main'>

<div class='summary_card' style='background-color: #ffc9c9; padding: 0.5rem 2rem; border-top: #e03131 solid 2px'>
<div class='summary'>
<div class='title-image-wrapper'>
</div>
<p>
<a href="http://blog.nacyot.com/">이 블로그</a>에 글이 올라온지 긴 시간이 지났습니다. 2018년 7월을 마지막으로 더 이상 업데이트하지 않을 예정입니다. 앞으로는 <a href="https://www.44bits.io/ko" style="border-bottom: #e03131 solid 1px;">44Bits.io</a>에 기고할 예정입니다.
<span class='link'>
<a href="/articles/2018-07-06-goodbye/">계속 읽기</a>
</span>
</p>
</div>
</div>

<div class='articles'>
<div class='article'>
<div class='categories'>
<div class='category category-programming-top' style='width: 100.0%'>
</div>
</div>
<h1 class='title'>
<a href="./">루비와 익명 함수 -  블록(block), Proc(절차, procedure) 객체와 람다(lambda) 함수의 차이 이해하기</a>
</h1>
<div>
<span class='date'>
<a href='/tags/programming' title='프로그래밍(Programming) 목록'>
<i class='fa fa-desktop' style='color: #1f77b4'></i>
프로그래밍
</a>
<i class='fa fa-calendar'></i>
2015년 12월 08일 발행
</span>
</div>
<div class='title-image-wrapper'>
<img class="title-image" src="http://i.imgur.com/TVYlS05.png" />
</div>
<a name='toc'></a>
<div class='toc'></div>
<div class='body'>
<blockquote>
<p><a href="https://ruby-korea.github.io/advent-calendar/">루비 Advent Calendar 2015</a> 7일차로 참석합니다.</p>
</blockquote>

<p>루비에서 가장 특징적이고 많이 사용되는 문법이 바로 블록입니다. 루비에서는 블록 문법을 통해서 하나의 익명 함수를 손쉽게 함수에 넘겨줄 수 있습니다. 대부분의 반복문을 비롯해 인터페이스로도 자주 사용되기 때문에 익명 함수 개념을 이해하는 것은 매우 중요합니다. 블록을 사용하지 않더라도 루비에서는 명시적으로 익명 함수 객체를 생성할 수 있습니다. 익명 함수를 만드는 두 가지 대표적인 방법이 바로 Proc 객체와 <code>lambda</code>문을 사용하는 것입니다. 이 글에서는 루비에서의 익명 함수와 Proc 객체와 <code>lambda</code>문으로 생성된 익명 함수의 차이점을 살펴보겠습니다.</p>



<h2><a name='proc(절차,-procedure)-객체-이해하기'>Proc(절차, Procedure) 객체 이해하기</a> <span class='to_toc'><a href='#toc'><i class='fa fa-angle-double-up'></i></a></span></h2>

<p>루비에서는 Proc 클래스를 통해서 익명 함수를 생성할 수 있습니다. 여기서 Proc은 Procedure의 줄임말로 어떤 처리 과정(절차)을 담고있다는 의미입니다. Proc 또한 일반적인 루비 클래스와 다르지 않으므로 Prow.new 메서드를 통해서 객체를 생성할 수 있습니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="no">Proc</span><span class="o">.</span><span class="n">new</span>
</span><span id="line-2"><span class="c1"># ArgumentError: tried to create Proc object without a block</span>
</span></pre></div>
<p>설명이 조금 까다로워집니다만, <code>Proc.new</code> 메서드는 블록을 통해서 절차(루비 표현식들)를 넘겨받습니다. 설명이 귀찮아진다는 의미는 블록 자체도 익명 함수기 때문입니다. 루비에서는 메서드 뒤에  <code>do...end</code> 형태로 블록이라는 특별한 문법을 사용할 수 있습니다. <code>do</code>와 <code>end</code> 사이에는 루비 표현식이 들어갑니다. 이 <code>do...end</code> 사이의 표현식들은 실행되지 않은 채로 익명 함수로서 그대로 실행하는 메서드에 전달됩니다. 여기서는 이 부분에 대해서는 다루지 않을 것입니다. 어쨌건 루비 표현식들이 고스란히 함수로 전달된다는 것이 중요합니다.</p>

<p><code>Proc.new</code>도 블록을 통해서 익명 함수를 전달받습니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>
</span><span id="line-2">  <span class="nb">puts</span> <span class="s1">&#39;Hello, world!&#39;</span>
</span><span id="line-3"><span class="k">end</span>
</span><span id="line-4"><span class="c1"># =&gt; #&lt;Proc:0x007f99f12c6bf8@(pry):2&gt;</span>
</span></pre></div>
<p><code>Proc.new</code>는 Proc 객체를 반환합니다. 이 생성자 메서드는 넘겨받은 익명 함수에 대해서 어떠한 일도 하지않고, 익명 함수를 그대로 저장을 합니다. 앞서 말했듯이 블록에 쓰여진 루비 표현식은 곧바로 실행되지 않습니다. 따라서 <code>puts &#39;Hello, world!&#39;</code>는 출력되지 않습니다.</p>

<h3><a name='proc-객체-실행하기'>Proc 객체 실행하기</a> <span class='to_toc'><a href='#toc'><i class='fa fa-angle-double-up'></i></a></span></h3>

<p>이 Proc 객체는 이제 원하는 시점에 언제라도 실행할 수 있습니다. 다음 예제에서는 이 Proc 객체를 변수에 대입하고 실행하는 방법을 살펴보겠습니다. Proc 객체를 실행하는 방법은 크게 3가지가 있습니다. 첫번째는 <code>.call()</code> 메서드 호출입니다. 제일 명확한 표현법입니다. 이외에도 <code>.()</code>과 <code>[]</code>와 같은 조금은 낯설게 보이는 방법도 있습니다. 기본적으로 <code>.call()</code>과 다르지 않습니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="c1"># 여기서는 편의상 do...end 대신 { }을 사용했습니다</span>
</span><span id="line-2"><span class="nb">p</span> <span class="o">=</span> <span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s1">&#39;Hello, world!&#39;</span><span class="p">}</span>
</span><span id="line-3">
</span><span id="line-4"><span class="nb">p</span><span class="o">.</span><span class="n">call</span><span class="p">()</span>
</span><span id="line-5"><span class="c1"># Hello, world!</span>
</span><span id="line-6">
</span><span id="line-7"><span class="nb">p</span><span class="o">.</span><span class="p">()</span>
</span><span id="line-8"><span class="c1"># Hello, world!</span>
</span><span id="line-9">
</span><span id="line-10"><span class="nb">p</span><span class="o">[]</span>
</span><span id="line-11"><span class="c1"># Hello, world!</span>
</span></pre></div>
<p>형태는 다르지만 모두 같은 방식으로 동작하는 걸 알 수 있습니다.</p>

<p>파이썬이나 자바스크립트 같은 언어를 사용해왔다면 이런 표현이 거슬릴 지도 모릅니다. 자바스크립트에서는 익명 함수와 기명함수의 실질적인 차이가 없습니다. 따라서 자바스크립트에서는 아래의 두 방법으로 함수를 선언한 결과가 실질적으로 같습니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="c1">// 일반적인 함수 선언</span>
</span><span id="line-2"><span class="kd">function</span> <span class="nx">hello1</span><span class="p">(){</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello, world!&#39;</span><span class="p">)</span> <span class="p">}</span>
</span><span id="line-3">
</span><span id="line-4"><span class="c1">// 익명 함수를 사용한 함수 선언</span>
</span><span id="line-5"><span class="kd">var</span> <span class="nx">hello2</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">&#39;</span><span class="nx">Hello</span><span class="p">,</span> <span class="nx">world</span><span class="o">!</span><span class="p">)</span> <span class="p">};</span>
</span></pre></div>
<p>함수를 호출하는 방법도 같습니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="nx">hello1</span><span class="p">()</span>
</span><span id="line-2"><span class="c1">// Hello, world!</span>
</span><span id="line-3">
</span><span id="line-4"><span class="nx">hello2</span><span class="p">()</span>
</span><span id="line-5"><span class="c1">// Hello, world!</span>
</span></pre></div>
<p>이는 루비와는 명백히 다릅니다. 위의 루비 예제에서는 익명 함수(Proc 객체)를 proc에 대입했습니다만, 함수처럼 직접 호출하는 것은 불가능합니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="nb">p</span><span class="p">()</span>
</span><span id="line-2"><span class="c1"># NoMethodError: undefined method `a&#39; for main:Object</span>
</span></pre></div>
<p>파이썬이나 자바스크립트에서는 함수 이름으로 접근하면 함수 자체에 접근할 수 있고 이를 직접 호출할 수 있지만 루비에서는 그렇지 않습니다. NoMethodError 예외가 발생하는 이유는 간단합니다. 말그대로 p라는 이름으로 정의된 함수가 존재하지 않기 때문입니다. 이 이유를 이해하기 위해서는 루비의 메서드 호출 방식을 이해할 필요가 있습니다만, 여기서는 익명 함수와 기명 함수가 존재하는 공간이 다르다는 정도에서 넘어가겠습니다.</p>

<p>이 주제에 대해서는 <a href="http://blog.nacyot.com/articles/2014-12-17-diffrence-of-ruby-and-python/">루비와 파이썬에서 함수 호출과 함수 참조에 대한 차이</a>에서 좀 더 자세히 다루고 있으니 참고해주시기 바랍니다.</p>

<h2><a name='블록'>블록</a> <span class='to_toc'><a href='#toc'><i class='fa fa-angle-double-up'></i></a></span></h2>

<p>블록은 엄밀히 말하면 Proc 객체는 아닙니다(이에 대해서는 뒤에서 설명합니다). 단, 메서드 선언시에 <code>&amp;</code> 연산자를 통해서 블록을 명시적으로 Proc 객체로 받아올 수 있습니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
</span><span id="line-2">  <span class="n">b</span><span class="o">.</span><span class="n">call</span><span class="p">()</span>
</span><span id="line-3"><span class="k">end</span>
</span><span id="line-4">
</span><span id="line-5"><span class="n">hello</span> <span class="k">do</span>
</span><span id="line-6">  <span class="nb">puts</span> <span class="s1">&#39;Hello, world!</span>
</span><span id="line-7"><span class="s1">end&#39;</span>
</span><span id="line-8"><span class="c1"># Hello, world!</span>
</span></pre></div>
<h2><a name='proc'>proc</a> <span class='to_toc'><a href='#toc'><i class='fa fa-angle-double-up'></i></a></span></h2>

<p>Kernel#proc 메서드도 있습니다. 이 메서드는 <code>Proc.new</code>와 같습니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="nb">p</span> <span class="o">=</span> <span class="nb">proc</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s1">&#39;Hello, world!&#39;</span> <span class="p">}</span>
</span><span id="line-2"><span class="nb">p</span><span class="o">.</span><span class="n">call</span><span class="p">()</span>
</span><span id="line-3"><span class="c1"># Hello, world!</span>
</span></pre></div>
<h2><a name='proc-객체와-람다(lambda)'>Proc 객체와 람다(lambda)</a> <span class='to_toc'><a href='#toc'><i class='fa fa-angle-double-up'></i></a></span></h2>

<p>흥미롭게도(그리고 혼란스럽게도) 루비에는 <code>lambda</code>라고 하는 Proc 객체를 생성하는 또 다른 방법이 존재합니다. 먼저 <code>lambda</code>를 통해서 Proc 객체를 만들어보겠습니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="n">l</span> <span class="o">=</span> <span class="nb">lambda</span><span class="p">{</span> <span class="nb">puts</span> <span class="s1">&#39;Hello, world!&#39;</span> <span class="p">}</span>
</span><span id="line-2">
</span><span id="line-3"><span class="n">l</span><span class="o">.</span><span class="n">class</span>
</span><span id="line-4"><span class="c1"># Proc</span>
</span><span id="line-5">
</span><span id="line-6"><span class="n">l</span><span class="o">.</span><span class="n">call</span><span class="p">()</span>
</span><span id="line-7"><span class="c1"># Hello, world!</span>
</span></pre></div>
<p>루비 1.9부터는 신택스 슈가인 <code>-&gt;</code>를 사용할 수도 있습니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="o">-&gt;</span><span class="p">{</span> <span class="nb">puts</span> <span class="s1">&#39;Hello, world!&#39;</span> <span class="p">}</span>
</span></pre></div>
<p>왜 <code>lambda</code>가 존재하는 걸까요? 람다라는 표현을 거슬러 올라가면 람다 대수가 나옵니다. 람다 대수는 알론조 처치에 의해 만들어진 수학 체계입니다. 이 체계가 흥미로운 것은 하나의 인자를 받는 함수들만을 사용하면서, 튜링 컴플리트하다는 점입니다. 즉, 완전히 수학적이면서 튜링 머신에서 가능한 모든 계산이 가능하다는 의미입니다. 단, 여기서 <code>lambda</code>라는 표현은 엄밀한 의미에서 수학적인 표현이라기보다는 루비 이전의 언어들에서 익명 함수를 의미할 때 사용해오던 관용구라고 이해하는 게 좋습니다. 루비에서는 이렇게 생성된 객체가 일반적인 Proc 객체보다 좀 더 함수답게 작동한다는 차이점을 가지고 있습니다.</p>

<h3><a name='proc#lambda?-를-사용한-lambda-여부-확인'>Proc#lambda? 를 사용한 lambda 여부 확인</a> <span class='to_toc'><a href='#toc'><i class='fa fa-angle-double-up'></i></a></span></h3>

<p>먼저 본격적으로 차이점을 알아버기 전에 일반적인 Proc 객체와 <code>lambda</code>로 만들어진 객체를 구분하는 방법을 살펴보겠습니다. Proc 객체의 <code>lambda?</code> 메서드로 <code>lambda</code>로 생성된 함수인지를 확인할 수 있습니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="no">Proc</span><span class="o">.</span><span class="n">new</span><span class="p">{}</span><span class="o">.</span><span class="n">lambda?</span> <span class="c1"># =&gt; false</span>
</span><span id="line-2"><span class="nb">proc</span><span class="p">{}</span><span class="o">.</span><span class="n">lambda?</span>     <span class="c1"># =&gt; false</span>
</span><span id="line-3"><span class="nb">lambda</span><span class="p">{}</span><span class="o">.</span><span class="n">lambda?</span>   <span class="c1"># =&gt; true</span>
</span><span id="line-4"><span class="o">-&gt;</span><span class="p">{}</span><span class="o">.</span><span class="n">lambda?</span>       <span class="c1"># =&gt; true</span>
</span></pre></div>
<p>참고로 일반적인 메서드를 객체화해서 Proc 객체로 변환하면 lambda Proc 객체가 됩니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="k">def</span> <span class="nf">hello</span><span class="p">;</span> <span class="k">end</span>
</span><span id="line-2"><span class="n">hello_method</span> <span class="o">=</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:hello</span><span class="p">)</span>
</span><span id="line-3"><span class="n">hello_method</span><span class="o">.</span><span class="n">to_proc</span><span class="o">.</span><span class="n">lambda?</span> <span class="c1"># =&gt; true</span>
</span></pre></div>
<p>더 자세한 내용은 <a href="http://ruby-doc.org/core-1.9.3/Proc.html#method-i-lambda-3F">루비 문서</a>에서 확인할 수 있습니다.</p>

<h3><a name='인자-검사-방식의-차이'>인자 검사 방식의 차이</a> <span class='to_toc'><a href='#toc'><i class='fa fa-angle-double-up'></i></a></span></h3>

<p>그 첫 번째 차이점으로 <code>lambda</code>로 만들어진 Proc 객체는 인자 개수를 엄격하게 검사합니다. 일반적으로 블록에서는 블록 인자라는 독특한 방법으로 인자를 받습니다. 여기서는 하나의 인자를 받는 Proc 객체를 만들고, 인자 개수를 바꿔가며 실행해보겠습니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="n">hello</span> <span class="o">=</span> <span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="nb">puts</span> <span class="s1">&#39;Hello, #{name}!&#39;</span><span class="p">}</span>
</span><span id="line-2"><span class="n">hello</span><span class="o">.</span><span class="n">call</span><span class="p">()</span>
</span><span id="line-3"><span class="c1"># Hello, !</span>
</span><span id="line-4">
</span><span id="line-5"><span class="n">hello</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s1">&#39;Jack&#39;</span><span class="p">)</span>
</span><span id="line-6"><span class="c1"># Hello, Jack!</span>
</span><span id="line-7">
</span><span id="line-8"><span class="n">hello</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span><span id="line-9"><span class="c1"># Hello, 1!</span>
</span></pre></div>
<p>정의에서는 하나의 인자를 사용하지만, 인자 개수가 달라지더라도 에러가 발생하지 않습니다. 이런 점에서 Proc 객체는 이름 그대로 <strong>절차</strong>만 저장된 객체라고 할 수 있습니다. 반면  <code>lambda</code>로 만든 Proc 객체는 다르게 작동합니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="n">hello</span> <span class="o">=</span> <span class="nb">lambda</span><span class="p">(</span><span class="nb">name</span><span class="p">){</span> <span class="nb">puts</span> <span class="s2">&quot;Hello, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">!&quot;</span> <span class="p">}</span>
</span><span id="line-2">
</span><span id="line-3"><span class="c1"># 신택스 슈가를 사용할 때는 다음과 같이 정의합니다</span>
</span><span id="line-4"><span class="o">-&gt;</span><span class="p">(</span><span class="nb">name</span><span class="p">){</span> <span class="nb">puts</span> <span class="s2">&quot;Hello, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">}</span>
</span><span id="line-5">
</span><span id="line-6"><span class="n">hello</span><span class="o">.</span><span class="n">call</span><span class="p">()</span>
</span><span id="line-7"><span class="c1"># ArgumentError: wrong number of arguments (0 for 1)</span>
</span><span id="line-8">
</span><span id="line-9"><span class="n">hello</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s1">&#39;Jack&#39;</span><span class="p">)</span>
</span><span id="line-10"><span class="c1"># hello, Jack!</span>
</span><span id="line-11">
</span><span id="line-12"><span class="n">hello</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
</span><span id="line-13"><span class="c1"># ArgumentError: wrong number of arguments (5 for 1)</span>
</span></pre></div>
<p>인자를 넘기지 않거나 더 많은 인자를 넘긴 경우 <code>ArgumentError</code> 예외가 발생한 것을 볼 수 있습니다.</p>

<h3><a name='return-작동-방식의-차이'>return 작동 방식의 차이</a> <span class='to_toc'><a href='#toc'><i class='fa fa-angle-double-up'></i></a></span></h3>

<p><code>proc</code>과 <code>lambda</code>의 또 다른 차이 점은 <code>return</code>의 작동방식입니다. 먼저 일반적은 Proc 객체가 동작하는 방식을 살펴보겠습니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="k">def</span> <span class="nf">return_two</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">p</span><span class="p">)</span>
</span><span id="line-2">  <span class="nb">p</span><span class="o">.</span><span class="n">call</span>
</span><span id="line-3">  <span class="k">return</span> <span class="mi">2</span>
</span><span id="line-4"><span class="k">end</span>
</span><span id="line-5">
</span><span id="line-6"><span class="n">return_two</span><span class="p">(</span><span class="o">&amp;</span><span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">})</span>
</span><span id="line-7"><span class="c1"># LocalJumpError: unexpected return</span>
</span></pre></div>
<p>밖에서 Proc 객체를 넘겨받으면 <code>LocalJumpError</code> 예외를 발생시킵니다. 이는 <code>return</code>이 어떤 맥락에서 해석되어야하는 지가 불분명하기 때문입니다.(Proc 객체? 아니면 Proc 객체를 실행하는 문맥?)</p>

<p>다음은 밖에서 넘겨받는 대신 안에서 Proc 객체를 생성하는 예제입니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="k">def</span> <span class="nf">return_two</span><span class="p">()</span>
</span><span id="line-2">  <span class="nb">p</span> <span class="o">=</span> <span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">}</span>
</span><span id="line-3">  <span class="nb">p</span><span class="o">.</span><span class="n">call</span>
</span><span id="line-4">  <span class="k">return</span> <span class="mi">2</span>
</span><span id="line-5"><span class="k">end</span>
</span><span id="line-6">
</span><span id="line-7"><span class="n">return_two</span>
</span><span id="line-8"><span class="c1"># =&gt; 1</span>
</span></pre></div>
<p>이번에는 1을 반환합니다. 놀랍게도 Proc 객체의 <code>return</code> 문이 <code>return_two</code>의 <code>retrun</code>으로 실행된 것을 알 수 있습니다. 이런 의도로 Proc 객체를 쓰는 일은 아마 거의 없을 듯 합니다.</p>

<p>그럼 이번에는 <code>lambda</code>로 만든 Proc 객체를 실행해보죠</p>
<div class="highlight"><pre><span id="line-1"><span class="k">def</span> <span class="nf">return_two</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">p</span><span class="p">)</span>
</span><span id="line-2">  <span class="nb">p</span><span class="o">.</span><span class="n">call</span>
</span><span id="line-3">  <span class="k">return</span> <span class="mi">2</span>
</span><span id="line-4"><span class="k">end</span>
</span><span id="line-5">
</span><span id="line-6"><span class="n">return_two</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">lambda</span><span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">})</span>
</span><span id="line-7"><span class="c1"># =&gt; 2</span>
</span></pre></div>
<p>이번에는 2를 반환했습니다. 좀 더 자세히 살펴보기 위해서 <code>p.call</code>의 반환값을 출력해보겠습니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="k">def</span> <span class="nf">return_two</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">p</span><span class="p">)</span>
</span><span id="line-2">  <span class="nb">puts</span> <span class="nb">p</span><span class="o">.</span><span class="n">call</span>
</span><span id="line-3">  <span class="k">return</span> <span class="mi">2</span>
</span><span id="line-4"><span class="k">end</span>
</span><span id="line-5">
</span><span id="line-6"><span class="n">return_two</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">lambda</span><span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">})</span>
</span><span id="line-7"><span class="c1"># 1</span>
</span><span id="line-8"><span class="c1"># =&gt; 2</span>
</span></pre></div>
<p><code>p.call</code>의 반환값이 1이 되는 것을 알 수 있습니다. 이를 통해서 <code>lambda</code> 함수에서 <code>return</code> 문을 사용하면 Proc 객체, 즉 익명 함수 자체의 반환이 되는 것을 알 수 있습니다. 따라서 <code>lambda</code> 함수에서는 1을 반환하고, <code>return_two</code> 함수에서는 의도한 대로 넘겨준 lambda Proc 객체와는 무관하게 2를 반환합니다.</p>

<h3><a name='break-작동-방식의-차이'>break 작동 방식의 차이</a> <span class='to_toc'><a href='#toc'><i class='fa fa-angle-double-up'></i></a></span></h3>

<p><code>break</code>도 <code>return</code>과 비슷한 차이가 있습니다. Proc 객체에서 break를 사용하면 LocalJumpError 예외를 발생시킵니다. <code>return</code> 문의 경우와 마찬가지입니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="mi">0</span><span class="o">.</span><span class="n">upto</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">&amp;</span><span class="no">Proc</span><span class="o">.</span><span class="n">new</span><span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">i</span><span class="p">;</span> <span class="k">break</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">})</span>
</span><span id="line-2"><span class="c1"># 0</span>
</span><span id="line-3"><span class="c1"># 1</span>
</span><span id="line-4"><span class="c1"># 2</span>
</span><span id="line-5"><span class="c1"># 3</span>
</span><span id="line-6"><span class="c1"># LocalJumpError: break from proc-closure</span>
</span></pre></div>
<p>반면에 lambda를 사용하면 break는 lambda Proc 객체 안으로 한정됩니다. 따라서 반복문 안에서 아무런 영향도 끼치지 않고 <code>i==2</code> 조건을 만족할 때 lambda 안에서 break가 실행될 뿐입니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="mi">0</span><span class="o">.</span><span class="n">upto</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">lambda</span><span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">i</span><span class="p">;</span> <span class="k">break</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">})</span>
</span><span id="line-2"><span class="c1"># 0</span>
</span><span id="line-3"><span class="c1"># 1</span>
</span><span id="line-4"><span class="c1"># 2</span>
</span><span id="line-5"><span class="c1"># 3</span>
</span><span id="line-6"><span class="c1"># =&gt; nil</span>
</span></pre></div>
<h3><a name='블록과-proc-객체의-차이'>블록과 Proc 객체의 차이</a> <span class='to_toc'><a href='#toc'><i class='fa fa-angle-double-up'></i></a></span></h3>

<p>블록은 Proc과 비슷하지만 엄밀히 말하면 Proc 객체와는 조금 다릅니다. 블록은 메서드와 결합된 문맥에서만 존재하기 때문에 이를 Proc 객체로 만들기는 어렵습니다. 다음 예제에서는 반복자를 통해서 break가 어떻게 다르게 작동하는 지를 살펴봅니다. 블록에서는 break가 정상적으로 작동합니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="mi">0</span><span class="o">.</span><span class="n">upto</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">i</span><span class="p">;</span> <span class="k">break</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">}</span>
</span><span id="line-2"><span class="c1"># 0</span>
</span><span id="line-3"><span class="c1"># 1</span>
</span><span id="line-4"><span class="c1"># 2</span>
</span><span id="line-5"><span class="c1"># 3</span>
</span><span id="line-6"><span class="c1"># =&gt; nil</span>
</span></pre></div>
<p>이번에는 정확히 같은 일을 하는 Proc 객체를 넘겨줍니다. </p>
<div class="highlight"><pre><span id="line-1"><span class="mi">0</span><span class="o">.</span><span class="n">upto</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="no">Proc</span><span class="o">.</span><span class="n">new</span><span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">i</span><span class="p">;</span> <span class="k">break</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">})</span>
</span><span id="line-2"><span class="c1"># 0</span>
</span><span id="line-3"><span class="c1"># 1</span>
</span><span id="line-4"><span class="c1"># 2</span>
</span><span id="line-5"><span class="c1"># 3</span>
</span><span id="line-6"><span class="c1"># LocalJumpError: break from proc-closure</span>
</span></pre></div>
<p>LocalJumpError가 발생합니다. 이는 넘겨진 함수가 클로저로 실행되는데, 그 안에서 break를 사용하고 있기 때문에 발생하는 예외입니다. 순수한(?) 블록에서는 이 문제를 적절히 해결해주는 걸 알 수 있습니다.</p>

<h2><a name='결론'>결론</a> <span class='to_toc'><a href='#toc'><i class='fa fa-angle-double-up'></i></a></span></h2>

<p>여기까지 배운 지식을 활용하면 다음과 같은 이상해보이는 구문이 정상적인 루비 구문이라는 걸 이해할 수 있습니다.</p>
<div class="highlight"><pre><span id="line-1"><span class="o">-&gt;</span><span class="p">(){}</span><span class="o">[]</span>
</span><span id="line-2"><span class="c1"># nil</span>
</span></pre></div>
<p>이게 요지는 아닙니다만, 루비에서 블록과 익명 함수 개념에 대한 이해는 아무리 강조해도 지나치지 않습니다. 많이들 어려움을 느끼는 부분도 Proc과 lambda처럼 비슷해보이면서도 다른 것들입니다. 특히 proc이나 lambda는 Kernel 클래스에 있어서 문법처럼 보이기도 하고 함수처럼 보이기도 하고 분명 헷갈리기 쉬운 요소입니다. 나아가 lambda에는 <code>-&gt;</code>라는 신택스 슈가도 있고, 이러한 익명 함수를 실행시키는 방법으로는 <code>.call()</code>, <code>.()</code>, <code>[]</code>와 같이 세 가지나 준비되어 있습니다. 처음 보면 당황스러울 수도 있지만 루비에서는 다들 많이 사용되는 표현이므로 확실히 익혀두는 게 좋습니다.</p>

<h2><a name='참고자료'>참고자료</a> <span class='to_toc'><a href='#toc'><i class='fa fa-angle-double-up'></i></a></span></h2>

<ul>
<li><a href="http://docs.ruby-lang.org/ja/2.2.0/method/Kernel/m/proc.html">Ruby 2.2.0 リファレンスマニュアル(레퍼런스 매뉴얼) - module function Kernel.#lambda</a></li>
<li><a href="http://ruby-doc.org/core-2.2.0/Proc.html">ruby-doc.org - Proc</a></li>
</ul>

</div>
<div class='recommand'>
<strong>
이 글이 도움이 되셨나요?
</strong>
<div class='links'>
<div class='feedly'>
<a href='http://feedly.com/i/subscription/feed/http://blog.nacyot.com/feed.xml'>
<img id='feedlyFollow' style='display:inline;' src='http://s3.feedly.com/img/follows/feedly-follow-logo-green_2x.png' alt='follow us in feedly' width='20' height='20' />
Feedly에서 nacyot의 프로그래밍 이야기 구독하기
</a>
</div>
<div class='twitter'>
<a href='https://twitter.com/intent/follow?screen_name=nacyo_t' target='_blank'>
<img style='display: inline' width='20' height='20' src='/images/twitter.png' />
Twitter에서 nacyot 팔로우하기
</a>
</div>
</div>
</div>
<div class='footer'>
<hr>
<div class='row'>
<div class='col-lg-12 col-md-12 col-sm-12 col-xs-12'>
<div class='tags'>
<div>
<i class='fa fa-tag'></i>
<a href='/tags/anonymous_function'>
익명 함수(anonymous function)
<span class='more'>
더 보기
</span>
</a>
</div>
<div>
<i class='fa fa-tag'></i>
<a href='/tags/block'>
블록(block)
<span class='more'>
더 보기
</span>
</a>
</div>
<div>
<i class='fa fa-tag'></i>
<a href='/tags/javascript'>
자바스크립트(Javascript)
<span class='more'>
더 보기
</span>
</a>
</div>
<div>
<i class='fa fa-tag'></i>
<a href='/tags/lambda'>
람다(lambda)
<span class='more'>
더 보기
</span>
</a>
</div>
<div>
<i class='fa fa-tag'></i>
<a href='/tags/proc'>
proc
<span class='more'>
더 보기
</span>
</a>
</div>
<div>
<i class='fa fa-tag'></i>
<a href='/tags/programming'>
프로그래밍(Programming)
<span class='more'>
더 보기
</span>
</a>
</div>
<div>
<i class='fa fa-tag'></i>
<a href='/tags/ruby'>
루비(Ruby)
<span class='more'>
더 보기
</span>
</a>
</div>
</div>
</div>
</div>
<hr>
<div class='row'>
<div class='author col-lg-6 col-md-6 col-sm-6 col-xs-6'>
<h1>nacyot</h1>
프로그래머
</div>
<div class='share col-lg-6 col-md-6 col-sm-6 col-xs-6'>
<h1>Share this post</h1>
<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style addthis_32x32_style">
<a class="addthis_button_facebook"></a>
<a class="addthis_button_twitter"></a>
<a class="addthis_button_google_plusone_share"></a>
<a class="addthis_button_pocket"></a>
<a class="addthis_button_print"></a>
<a class="addthis_button_compact"></a><a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript">var addthis_config = {"data_track_addressbar":false};</script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-52ffce6f41e2b5e2"></script>
<!-- AddThis Button END -->
</div>
</div>
</div>
<hr>
<div id='disqus_thread'>
<script>
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'nacyot'; // required: replace example with your forum shortname

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
</div>
<div class='barcode' data-title='루비와 익명 함수 -  블록(block), Proc(절차, procedure) 객체와 람다(lambda) 함수의 차이 이해하기'></div>
<div class='navigation'>
<div class='prevnav'>
<div class='fa fa-chevron-left'></div>
<div class='fa fa-chevron-left'></div>
<div class='fa fa-chevron-left'></div>
<a href='/articles/2015-12-02-programming-is-difficult/' rel='prev'>이전 글</a>
<div class='summary_card'>
<div class='categories'>
<div class='category category-book-top' style='width: 100.0%'></div>
</div>
<h1 class='title'>
<a href="../2015-12-02-programming-is-difficult/">프로그래밍은 왜 어려운가 - 벤 프라이(Ben Fry)의 Distellamap으로 생각해보는 다익스트라의 'GOTO문은 해롭다(Go To Statement Considered Harmful)'</a>
</h1>
<div>
<span class='date'>
<a href='/tags/article' title='이야기(Articles) 목록'>
<i class='fa fa-book' style='color: #d62728'></i>
이야기
</a>
<i class='fa fa-calendar'></i>
2015년 12월 03일 발행
</span>
</div>
<div class='summary'>
<div class='title-image-wrapper'>
<img class="title-image" src="http://i.imgur.com/xwuGSjK.pngg" />
</div>
<p>최근에 현대카드 디자인 라이브러리에서 열린 <a href="http://design.hyundaicardcapital.com/771">Designing with Data</a> 전시를 보고 왔는데 그 중에서 Ben Fry의 <a href="http://benfry.com/distellamap/">Distellamap</a>이라는 작품이 유독 인상깊었습니다.</p>

<p>이 작품은 Atari 2600 게임 코드(어셈블리) 전체를 한 평면에 놓고 코드가 점프하는 지점들을 연결한 작품입니다. 얼핏 봐도 알 수 있지만 프로그램 내에서도 아주 많은 선들로 연결되어있습니다. 프로그램은 선형적으로 실행되지 않는다는 걸 노골적으로 보여주고 있죠.</p>

<span class='link'>
<a href="../2015-12-02-programming-is-difficult/">계속 읽기</a>
</span>
</div>
<div class='tags'>
<i class='fa fa-tag'></i>
<a href='/tags/abstraction'>abstraction</a>
<i class='fa fa-tag'></i>
<a href='/tags/article'>article</a>
<i class='fa fa-tag'></i>
<a href='/tags/atari_2600'>atari_2600</a>
<i class='fa fa-tag'></i>
<a href='/tags/ben_fry'>ben_fry</a>
<i class='fa fa-tag'></i>
<a href='/tags/computer'>computer</a>
<i class='fa fa-tag'></i>
<a href='/tags/edsger_dijkstra'>edsger_dijkstra</a>
<i class='fa fa-tag'></i>
<a href='/tags/goto'>goto</a>
<i class='fa fa-tag'></i>
<a href='/tags/human'>human</a>
<i class='fa fa-tag'></i>
<a href='/tags/process'>process</a>
<i class='fa fa-tag'></i>
<a href='/tags/program'>program</a>
<i class='fa fa-tag'></i>
<a href='/tags/programming'>programming</a>
<i class='fa fa-tag'></i>
<a href='/tags/visualization'>visualization</a>
</div>
<div class='barcode' data-title="프로그래밍은 왜 어려운가 - 벤 프라이(Ben Fry)의 Distellamap으로 생각해보는 다익스트라의 'GOTO문은 해롭다(Go To Statement Considered Harmful)'"></div>
</div>

</div>
<div class='nextnav'>
<a href='/articles/2015-12-09-incremental-search-tool-peco/' rel='next'>다음 글</a>
<div class='fa fa-chevron-right'></div>
<div class='fa fa-chevron-right'></div>
<div class='fa fa-chevron-right'></div>
<div class='summary_card'>
<div class='categories'>
<div class='category category-software-top' style='width: 100.0%'></div>
</div>
<h1 class='title'>
<a href="../2015-12-09-incremental-search-tool-peco/">증분검색을 통한 텍스트 필터링 도구 페코(Peco) - 명령어 히스토리를 비롯한 셸(shell) 어디서나 증분검색하기</a>
</h1>
<div>
<span class='date'>
<a href='/tags/software' title='소프트웨어(software) 목록'>
<i class='fa fa-square-o' style='color: #7f7f7f'></i>
소프트웨어
</a>
<i class='fa fa-calendar'></i>
2015년 12월 09일 발행
</span>
</div>
<div class='summary'>
<div class='title-image-wrapper'>
<img class="title-image" src="http://i.imgur.com/XKk4660.png" />
</div>
<p>셸(shell)은 매력적인 도구이지만, 많은 사람들에게 원시적인 도구로 오해받곤 한다. CLI의 대표적인 원시성으로는 각각의 프로그램들이 개별적으로 사용자와 대화하는 대신, 셸을 통해서만 명령이 가능하다는 점을 들 수 있다. 하지만 이러한 점은 커다란 장점이 되기도 한다. 예를 들어 프로그램들이 <code>STDIN</code>과 <code>STDOUT</code>만으로 데이터를 주고받을 수 있다. 또한 셸 인터페이스의 개선이 모든 프로그램의 사용성 개선과 직결되기도 한다. 애플리케이션의 단절을 전제로 하는 GUI에서는 이러한 장점을 누리기 어렵다.</p>

<p>페코(Peco)는 특히 인터페이스를 개선해주는 후자에 해당하는 도구이다. 페코는 개별적으로 사용가능한 인터렉티브 데이터 필터링 도구인 동시에, 셸과 함께 사용하면 셸의 사용성을 개선할 수 있다. 이 글에서는 페코의 기본적인 사용법과 셸의 히스토리 검색과 결합해서 사용하는 방법에 대해서 알아본다.</p>

<span class='link'>
<a href="../2015-12-09-incremental-search-tool-peco/">계속 읽기</a>
</span>
</div>
<div class='tags'>
<i class='fa fa-tag'></i>
<a href='/tags/bash'>bash</a>
<i class='fa fa-tag'></i>
<a href='/tags/command_history'>command_history</a>
<i class='fa fa-tag'></i>
<a href='/tags/firefox'>firefox</a>
<i class='fa fa-tag'></i>
<a href='/tags/go'>go</a>
<i class='fa fa-tag'></i>
<a href='/tags/incremental_search'>incremental_search</a>
<i class='fa fa-tag'></i>
<a href='/tags/peco'>peco</a>
<i class='fa fa-tag'></i>
<a href='/tags/percol'>percol</a>
<i class='fa fa-tag'></i>
<a href='/tags/shell'>shell</a>
<i class='fa fa-tag'></i>
<a href='/tags/software'>software</a>
<i class='fa fa-tag'></i>
<a href='/tags/zsh'>zsh</a>
</div>
<div class='barcode' data-title='증분검색을 통한 텍스트 필터링 도구 페코(Peco) - 명령어 히스토리를 비롯한 셸(shell) 어디서나 증분검색하기'></div>
</div>

</div>
<br style='clear:both'>
</div>
</div>
</div>
</div>
<div class='col-lg-2 col-md-2'></div>
</div>
<script>
  $('.toc').toc({
    'selectors': 'h2,h3,h4,h5',
    'container': '.article'
  });
</script>

<div class='row'>
<div class='col-lg-12'>
<hr>
<div class='site-footer'>
<div class='search-form'>
<form role="search" id="cse-search-box" action="http://google.com/cse">
<input type="hidden" name="cx" value="001442510316556568987:j38kphmalos" />
<input type="hidden" name="ie" value="UTF-8" />
<div class="form-group">
<input class="form-control" type="text" name="q" size="15" />
</div>
</form>
</div>
<div class='navigaiton'>
<a class='icon' href='/' title='블로그 메인으로 이동'>
<i class='fa-home fa fa-2x'></i>
</a>
<a class='icon' href='http://nacyot.com' title='nacyot.com'>
<i class='fa-user fa fa-2x'></i>
</a>
<a class='icon' href='https://twitter.com/nacyo_t' title='nacyo_t 트위터'>
<i class='fa-tumblr fa fa-2x'></i>
</a>
<a class='icon' href='https://nacyot.tumblr.com' title="NACYOT's beeswax">
<i class='fa-twitter fa fa-2x'></i>
</a>
<a class='icon' href='https://github.com/nacyot' title='nacyot Github'>
<i class='fa-github fa fa-2x'></i>
</a>
<a class='icon' href='/feed.xml' style='color: orange' title='nacyot의 프로그래밍 이야기 RSS feed'>
<i class='fa-rss fa fa-2x'></i>
</a>
</div>
<div class='copyright'>
<div>
All content copyright
<a href='http://nacyot.com'>nacyot</a>
© 2013-2016
</div>
<div></div>
All rights reserved.
</div>
</div>
</div>
</div>

</body>
</html>
