<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Name</title>
  <subtitle>Blog subtitle</subtitle>
  <id>http://blog.url.com/</id>
  <link href="http://blog.url.com/"/>
  <link href="http://blog.url.com/feed.xml" rel="self"/>
  <updated>2014-01-17T15:00:00Z</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>Ubuntu 13.10 개발환경 세팅</title>
    <link rel="alternate" href="http://blog.url.com/articles/2014-01-18-ubuntu-setting/"/>
    <id>http://blog.url.com/articles/2014-01-18-ubuntu-setting/</id>
    <published>2014-01-17T15:00:00Z</published>
    <updated>2014-01-18T16:38:51+00:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;Ubuntu 13.10 개발 환경 세팅 정리. 서버면 자동화시키는 것도 좋은 방법일 듯 한데, 데스크탑은 그래픽 드라이버 같은 부분이 컴퓨터마다 다르다 보니 완전히 자동화하는 건 쉽지 않은 것 같다. 지난 번까지 우분투 13.04 써왔는데(지금 노트북도 13.04), 이번에 새로 13.10에 도전해봤다. 사실 그래픽 드라이버 문제로 13.04로 낮추고 싶었으나, 조만간 지원이 끝난다고 하길래 맘 잡고 13.10으로 개발환경 정리를 했다. 금요일 오전 내내 걸렸으니까 전체 세팅하는데 4~5시간 정도 걸린 것 같다. 이걸로 기본적인 부분은 정리가 된 듯 싶고, 어디까지나 앞으로 삽질 방지용 포스트.&lt;/p&gt;

&lt;p&gt;참고로 본인은 Ubuntu / Terminator(터미널 프로그램) / Emacs(에디터) / Dvorak(키보드 레이아웃) 사용자.&lt;/p&gt;



&lt;h2&gt;Ubuntu 13.10 설치&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.ubuntu.com/download/desktop"&gt;우분투 공식 홈페이지&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우분투 13.10 설치. 우분투에는 기본적으로 setup disk creator이라는 어플이 들어가서 있어서 이걸로 usb에 옮겨담을 수 있는데 조금 문제가 있어서 윈도우에서 &lt;a href="http://www.linuxliveusb.com/"&gt;Linux Live USB Driver&lt;/a&gt;로 USB에 설치.&lt;/p&gt;

&lt;h2&gt;APT 다운로드 서버 설정&lt;/h2&gt;

&lt;p&gt;처음에 자동으로 업데이트를 실시하지만 패키지도 많고 상당히 시간이 오래걸린다. 이 때 미러 서버를 바꿔주면 속도가 많이 개선된다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;자동으로 뜨는 업데이트는 진행하지 말 것.&lt;/li&gt;
&lt;li&gt;System Settings&lt;/li&gt;
&lt;li&gt;Software &amp;amp; Updates&lt;/li&gt;
&lt;li&gt;Ubuntu Software 탭에서 Download from : http://ftp.daum.net/ubuntu&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;APT 다운로드 서버 설정. 자세히 알고 있다면 &lt;code&gt;/etc/apt&lt;/code&gt;에 설정 파일들을 직접 편집해도 되지만 보통 시스템 설정을 사용하는 게 편리하다. 디폴트로 잡혀있는 kr.archive.ubuntu.com은 많이 느린 편이고, 한국에서는 Daum이나 Neowiz 서버가 빠르긴한데 업데이트가 느리거나 불안정하다는 얘기가 있다. 한국 미러에 문제가 있는 경우, 일본에서 빠른 서버 찾아서 사용하면 된다. jaist를 많이 사용하는 것 같다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;터미널에서 업데이트 진행(Software &amp;amp; Updates 윈도우에서 진행해도 무관하다).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;
sudo apt-get update
sudo apt-get upgrade
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;그래픽 카드 설치&lt;/h2&gt;

&lt;p&gt;이번에 설치한 그래픽 카드는 AMD A10 5800K(APU). 아마도 이런 모델이었던 것 같은데 맞는 지는 모르겠다. 일단 Ubuntu에서 기본적으로 지원하는 드라이버 Xorg로는 화면이 깨지는 현상이 있어서 AMD 쪽에서 나오는 서드파티 드라이버를 설치해야한다. &lt;code&gt;fglrx&lt;/code&gt;를 설치하면 화면이 깨지는 현상은 사라지는데 마우스 커서가 없어지는 문제가 있어서 &lt;code&gt;fglrx-update&lt;/code&gt;를 설치.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo apt-get install fglrx-update fglrx-update-dev&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이걸로 안 되면 삭제하고 &lt;code&gt;fglrx&lt;/code&gt; 설치.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo apt-get install fglrx fglrx-dev&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;듀얼 모니터 설정&lt;/h3&gt;

&lt;p&gt;단 &lt;code&gt;fglrx-update&lt;/code&gt;를 설치하니 듀얼모니터가 해상도 제한이 걸린다며 지정이 안 되는 문제가 발생했다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
sudo aticonfig --initial # /etc/X11/xorg.conf 생성.
sudo amdcccle
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;설정을 알고 있다면 직접 xorg.conf 생성 후 직접 편집해도 되지만, 잘 모른다면 AMD 드라이버 설정 관리자(amdcccle)를 열어서 듀얼 모니터를 잡아주면 된다. 여기서 화면 회전이나 추가적인 설정 가능.&lt;/p&gt;

&lt;h3&gt;참고&lt;/h3&gt;

&lt;p&gt;일반적으로 어떤 그래픽 카드건 Software &amp;amp; Updates의 Additianal Drivers에서 사용가능한 드라이버를 확인할 수 있다. 문제가 있으면 여기에 뜨는 것들을 바꿔가며 테스트 해보고 구글링으로 해당하는 문제를 찾아보는 게 좋다.&lt;/p&gt;

&lt;h2&gt;Nabi 설정&lt;/h2&gt;

&lt;h3&gt;한글 입력기 Nabi 설치[^1]&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
sudo add-apt-repository ppa:createsc/copy4
sudo apt-get update
sudo apt-get install nabi
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;[^1]: 참고 http://www.ubuntu.or.kr/viewtopic.php?p=62810&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;System Settings&lt;/li&gt;
&lt;li&gt;Language Support&lt;/li&gt;
&lt;li&gt;키보드 입력기 : Hangul&lt;/li&gt;
&lt;li&gt;재부팅 or 로그아웃&lt;/li&gt;
&lt;li&gt;드보락 설정(필요시, 링크 참조)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;System Tray Whitelist 등록[^2]&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
sudo add-apt-repository ppa:mc3man/systray-white
sudo apt-get update
gsettings set com.canonical.Unity.Panel systray-whitelist &amp;quot;[&amp;#39;all&amp;#39;]&amp;quot;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;[^2]: 참조 http://www.ubuntu.or.kr/viewtopic.php?p=112275&lt;/p&gt;

&lt;h2&gt;방화병 설정 및 ssh 서버 설치&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
sudo ufw enable
sudo ufw allow 22/tcp
sudo apt-get ssh-server
sudo apt-get install ssh-server
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;외부 접속 위해서 ssh-server 설치해줘야 되는 건지 원래 되는 건지(설치 되어있는지) 정확히 기억이 안난다. &lt;code&gt;uft&lt;/code&gt;은 방화벽 설정.&lt;/p&gt;

&lt;h2&gt;ssh key 생성&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
ssh-keygen -t rsa -C &amp;quot;propellerheaven@gmail.com&amp;quot;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ssh key 생성 후, &lt;code&gt;~/.ssh/id_rsa.pub&lt;/code&gt; 파일 출력해서 github, bitbucket, gitlab에 등록 해 줌.&lt;/p&gt;

&lt;h2&gt;OpenVPN 세팅&lt;/h2&gt;

&lt;p&gt;```
sudo apt-get install openvpn&lt;/p&gt;

&lt;h1&gt;/etc/openvpn vpn 환경 설정 파일 설정&lt;/h1&gt;

&lt;p&gt;sudo service openvpn restart
```&lt;/p&gt;

&lt;p&gt;개인적으로는 로컬 서버에서 돌리는 것들이 있어서 openvpn 열어서 사용중. 필요하면 /etc/openvpn디렉토리에서 설정.&lt;/p&gt;

&lt;h2&gt;Unix 설정 파일 Clone&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
sudo apt-get install zsh tmux git
chsh # /bin/zsh
git clone git@&amp;lt;GIT_SERVER&amp;gt;:configuration/unix-config.git conf
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;환경설정 파일들은 마찬가지로 기존에 사용하는 것들 그대로 가져와서 사용. 개인적으로 private repository에서 관리중이고 클론해서 &lt;code&gt;~&lt;/code&gt;에서 &lt;code&gt;conf&lt;/code&gt; 디렉토리의 폴더로 심볼릭 링크 걸어서 사용. 필요한 게 추가로 있으면 scp로 기존 작업 환경에서 복사해서 사용. &lt;/p&gt;

&lt;h2&gt;Terminator 설치&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
sudo apt-get install terminator
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;터미네이터 설정 파일은 &lt;code&gt;.config/terminator/config&lt;/code&gt;. 보통은 scp로 원래 쓰던 거 가져다가 세팅했는데,이번엔 &lt;a href="https://github.com/ghuntley/terminator-solarized"&gt;terminator-solarized&lt;/a&gt; 테마도 같이사용해봤다.사용해보진 않았는데 Mac 쓰던 경우엔 &lt;a href="https://gist.github.com/olistik/3894072"&gt;이 gist&lt;/a&gt;도좋을 듯.&lt;/p&gt;

&lt;h2&gt;Eamcs 설치&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
sudo apt-get install emacs24 emacs24-common
git clone git@&amp;lt;GIT_SERVER&amp;gt;:configuration/emacs-config.git .emacs.d
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ubuntu 13.10에서는 emacs24를 바로 설치해서 사용 가능. 환경 설정에 기존에 사용하던 거 그대로 가져와서 사용.&lt;/p&gt;

&lt;h3&gt;the silver seacher 설치&lt;/h3&gt;

&lt;p&gt;ubuntu 13.10에서는 apt-get으로 바로 silver seacher 설치할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
sudo apt-get install silversearcher-ag
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;워크스페이스 활성화&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
sudo apt-get install compizconfig-settings-manager
&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Windows(Super) 키 누르고 &lt;code&gt;컴피즈 설정 관리자&lt;/code&gt; 실행.&lt;/li&gt;
&lt;li&gt;General =&amp;gt; 일반 설정&lt;/li&gt;
&lt;li&gt;데스크탑 크기 탭에서 &lt;code&gt;가로 가상 크기&lt;/code&gt;와 &lt;code&gt;세로 가상 크기&lt;/code&gt; 지정.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;워크스페이스 간 창 이동 단축키 변경&lt;/h3&gt;

&lt;p&gt;Ubuntu Unity에서는 워크스페이스간에 창 이동을 시킬때 컨트롤 + 쉬프트 + 알트 화살표를 사용하는데 Ubuntu 13.10에서는 기본적으로 양 옆 이동은 가능하나 위 아래 이동은 안 먹히는 문제가 있다. 이를 해결하기 위해서는,&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Windows(Super) 키 누르고 &lt;code&gt;컴피즈 설정 관리자&lt;/code&gt; 실행.&lt;/li&gt;
&lt;li&gt;Desktop =&amp;gt; Desktop Wall&lt;/li&gt;
&lt;li&gt;바로가기 탭의 Move with window within wall을 열고,&lt;/li&gt;
&lt;li&gt;단축키 다시 설정 해줌(연필 아이콘)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Ruby 설치&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
git clone https://github.com/sstephenson/rbenv.git ~/.rbenv
echo &amp;#39;export PATH=&amp;quot;$HOME/.rbenv/bin:$PATH&amp;quot;&amp;#39; &amp;gt;&amp;gt; ~/.zshrc
echo &amp;#39;eval &amp;quot;$(rbenv init -)&amp;quot;&amp;#39; &amp;gt;&amp;gt; ~/.zshrc
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;rbenv 설치. 기본적으로 README에는 bash 기준으로 설정이 되어있는데, 자신이 사용하는 쉘 설정 파일에 집어넣어준다(여기선 zsh). 필요하면 설정하고 쉘을 다시 실행시켜준다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
git clone https://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build
sudo apt-get install -qy build-essential zlib1g-dev libyaml-dev libssl-devlibgdbm-devlibreadline-dev libncurses5-dev libffi-dev curl libxml2-dev libxslt-devlibcurl4-openssl-dev libicu-dev
rbenv install 2.1.0
rbenv install 2.0.0-p353
rbenv install 1.9.3-p484
rbenv global 2.1.0
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ruby-build는 rbenv에서 루비 빌드를 하기 위한 플러그인. 위에서 설치하는 패키지들은 루비 빌드에 사용되는 패키지들.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
gem install travis middleman middleman-blog rails heroku --verbose
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;중요한 gem들 설치... 별로 중요해보이지 않지만 패스.&lt;/p&gt;

&lt;h2&gt;Hub 설치&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
git clone git://github.com/github/hub.git
cd hub/
sudo .rbenv/shims/rake install
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;적당한 디렉토리에 클론하고 &lt;code&gt;rake install&lt;/code&gt;로 설치.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
wget https://raw.github.com/github/hub/master/etc/hub.zsh_completion
sudo mv hub.zsh_completion /usr/local/share/zsh/site-functions/_hub
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;zsh용 자동완성 파일을 받아서 위의 디렉토리로 복사해준다. 아래 설정을 &lt;code&gt;.zshrc&lt;/code&gt; 파일에 추가해준다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
eval &amp;quot;$(hub alias -s)&amp;quot;
compdef git=hub
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;Wine 카카오톡 설치&lt;/h2&gt;

&lt;p&gt;현재 팀에서 사용하고 있는 메신저가 카카오톡이라 Wine로 카카오톡 설치 시도. &lt;/p&gt;

&lt;p&gt;&lt;code&gt;
sudo add-apt-repository ppa:ubuntu-wine/ppa
sudo apt-get upgrade
sudo apt-cache search &amp;quot;wine&amp;quot;
sudo apt-get install wine1.7
winetricks gdiplus
winetricks wmp9 
winetricks riched20
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wmp9&lt;/code&gt;은 메시지 알림음, &lt;code&gt;riched20&lt;/code&gt;은 한글 입력에 필요한 듯.&lt;/p&gt;

&lt;p&gt;한글 설정을 위해 굴림 폰트 구해서 wine 폴더 쪽으로 복사해주고 기본 폰트 쪽에 링크를 걸어준다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
mv gulim.ttc ../.wine/drive_c/windows/Fonts/
ln -s gulim.ttc batang.ttc
ln -s gulim.ttc dotum.ttc
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;~/.wine/system.reg&lt;/code&gt; 파일을 열어서 아래 부분을 찾아서,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
&amp;quot;MS Shell Dlg&amp;quot;=&amp;quot;Tahoma&amp;quot;
&amp;quot;MS Shell Dlg 2&amp;quot;=&amp;quot;Tahoma&amp;quot;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;아래 내용으로 바꿔준다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
&amp;quot;MS Shell Dlg&amp;quot;=&amp;quot;Gulim&amp;quot;
&amp;quot;MS Shell Dlg 2&amp;quot;=&amp;quot;Gulim&amp;quot;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://app.pc.kakao.com/talk/win32/KakaoTalk_Setup.exe"&gt;카카오톡 설치 파일&lt;/a&gt; 다운 받아서 실행. 한글이 깨지는 경우 적당이 추측해서 설치해준다.&lt;/p&gt;

&lt;p&gt;터미널에서 아래 명령어를 실행해본다. 이 때 카카오톡 아이콘 위치가 정확하지 않으면 직접 확인해준다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
wine C:\\windows\\command\\start.exe/Unix/home/daekwon/.wine/dosdevices/c:/users/Public/Desktop/카카오톡.lnk
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이렇게 실행했는데, 한글이 깨지면 카카오톡을 전부 종료하고 강제로 &lt;code&gt;LC_ALL&lt;/code&gt; 환경변수를 지정해 실행해본다. 이게 나 같은 경우에는 이번에 Ubuntu를 영어로 설치해서 그러니 Wine도 기본으로 Language가 영어로 잡혀서 폰트 설정만으로는 제대로 적용이 안 됐다. 이 환경변수를 사용해 한글이 잘 되면 카카오톡 설치시 바탕화면에 생기는 아이콘의 실행 경로에 &lt;code&gt;LC_ALL&lt;/code&gt; 환경변수를 지정해 놓는다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
LC_ALL=ko_KR.utf8 wine C:\\windows\\command\\start.exe/Unix/home/daekwon/.wine/dosdevices/c:/users/Public/Desktop/카카오톡.lnk
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;한글이 조금 구려보이긴 하지만 잘 되는 것은 확인.&lt;/p&gt;

&lt;h2&gt;개발용 &lt;a href="http://docker.io/"&gt;Docker&lt;/a&gt; 설치&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
curl -s https://get.docker.io/ubuntu/ | sudo sh
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;요새 서버에 도입하려고 궁리중인 Docker. 공식 사이트에서 제공해주는 스크립트 하나면 정말 간단히 설치할 수 있다. 자세항 내용은 &lt;a href="http://docs.docker.io/en/latest/installation/ubuntulinux/"&gt;공식 문서&lt;/a&gt; 확인.&lt;/p&gt;

&lt;h2&gt;정리&lt;/h2&gt;

&lt;p&gt;일단 중요한 부분은 다 정리한 듯. 이외에도 VirtualBox, Vagrant, Pandoc, Tex, python, 등등 설치해야되지만, 필요해지면 설치할 예정.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>정적 웹사이트 생성기의 유혹</title>
    <link rel="alternate" href="http://blog.url.com/articles/2014-01-15-static-site-generator/"/>
    <id>http://blog.url.com/articles/2014-01-15-static-site-generator/</id>
    <published>2014-01-05T03:00:00Z</published>
    <updated>2014-01-18T16:38:51+00:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;개인적으로 요새 화두인 주제가 바로 정적 웹사이트 생성기입니다. 21세기에 정적 웹사이트라니 꽤나 뜬금없는 이야기로 들리실지 모르겠지만 여기에 대해서는 약간 배경에 대해서 이해할 필요가 있습니다.&lt;/p&gt;

&lt;p&gt;분명히 &lt;strong&gt;정적&lt;/strong&gt;이라는 단어는 그 동안에 웹 어플리케이션이 발전해 온 데 있어서 정반대의 위치에 있는 단어입니다. &lt;strong&gt;정적&lt;/strong&gt;인 페이지란 말그대로 이미 완성된 HTML이고, 클라이언트의 요청을 받는 서버의 역할은 단순히 이렇게 완성되어 있는 HTML을 보내주는 역할을 할 뿐입니다. 이러한 모델은 우편부를 통해서 비유하기에 아주 적절합니다. 그렇다면 웹이 &lt;strong&gt;동적&lt;/strong&gt;으로 발전해왔다는 건 어떤 걸 의미할까요? 여기서 &lt;strong&gt;동적&lt;/strong&gt;이란 화려한 시각적 효과나 움직임을 지칭하는 단어가 아닙니다. 좀 더 정확히 말하자면 HTML 페이지를 클라이언트의 요청에 따라서 실시간으로 생성해서 보내준다는 의미를 가지고 있습니다. 그래서 이러한 웹 어플리케이션을 배울 때 가장 먼저 나오는 가장 간단한 예는 항상 이름을 받고서 이름을 출력해주는 예제입니다. 즉 서버는 완성된 HTML을 가지고 있지 않습니다. 거의 완성되어있거나, 심지어는 아무것도 없이도 요청에 따라 실시간으로 완성된 문서를 다시 보내줍니다. 즉, 여기서 서버란 웹서버 어플리케이션과 웹 어플리케이션을 함께 이야기합니다.&lt;/p&gt;

&lt;p&gt;하지만 본질적인 부분을 다시 생각해볼 필요가 있습니다. 정말로 &lt;strong&gt;동적&lt;/strong&gt;인 웹페이지란 필요한 걸까요? 단언컨데, 네 필요합니다. 질문을 바꿀 필요가 있습니다. 모든 경우에 정말로 &lt;strong&gt;동적&lt;/strong&gt;인 웹페이지가 필요한 걸까요? 여기에 &lt;strong&gt;모든 경우에&lt;/strong&gt;라는 수사를 통해서 저는 이도 저도 아닌 회색 영역을 만들었습니다. 네, 물론 아닙니다. 웹페이지 상에 동적으로 변해야하는 부분이 단 하나도 없다면, 완성된 HTML 형식으로 사이트를 공개해도 아무런 문제가 없습니다. 단지 우리는 21.1세기에 더 이상 그런 원시적인 웹 사이트는 거의 없다고 믿고 있을 뿐이죠.&lt;/p&gt;

&lt;p&gt;사실 &lt;strong&gt;정적&lt;/strong&gt;이라는 건 &lt;strong&gt;나쁜 것&lt;/strong&gt;이 아닙니다. 오히려 &lt;strong&gt;동적&lt;/strong&gt; 방식이야 말로 실시간으로 &lt;strong&gt;사이트를 생성&lt;/strong&gt;하는 데서 오는 굉장히 큰 비용을 감당해야합니다. 바로 이런 이유 때문에 &lt;strong&gt;어떤 프레임워크&lt;/strong&gt;를 사용할 것인가, &lt;strong&gt;어떤 언어&lt;/strong&gt;를 사용할 것인가 하는 게 굉장히 중요한 문제입니다. 제가 사랑해마지 않는 루비조차도 바로 이런 이유(즉 상대적으로 느리기 때문에!)로 언젠가 서비스가 커지면 갈아치워야할 프로토타입용이라고 생각되는 경우가 굉장히 많습니다. 물론 대부분의 서비스는 그 단계까지도 가지도 못 하고 프로토타입만 서비스하다  망합니다만....&lt;/p&gt;

&lt;p&gt;뭐, 그렇습니다.&lt;/p&gt;

&lt;p&gt;단순히 서버 수준의 스케일링까지 고려를 하지 않더라도 동적으로 웹페이지를 생성하는 일은 굉장히 느립니다. 이는 만들어져있는 즉석식품과와 주문 받으면 음식을 조리하는 방식의 차이입니다. 정적이 전자라면, 동적은 후자입니다. 당연히 느립니다. 그 차이가 비록 와닿지 않을 정도라고 하더라도 분명히 느리며, 또한 이러한 차이를 극복하기 위해 실제 웹서비스들에서는 캐시를 사용해 마치 자신이 정적 웹 페이지인 것 마냥 작동합니다. 캐시가 가능한 이유는 웹 어플리케이션의 많은 부분이 &lt;strong&gt;사실은&lt;/strong&gt; 정적이기 때문입니다. 즉, 요청마다 다르게 보여주는 부분은 실제로는 그렇게 많지 않다는 이야기입니다.&lt;/p&gt;

&lt;p&gt;정적인 자원은 다른 처리 비용을 발생시키지 않기 때문에 동적인 자원에 비해서 훨씬 더 빠릅니다. 그저 이미 만들어져있는 것을 보내주면 그만입니다. 앞에서 이야기했듯이 서버는 그저 우편부 역할을 할 뿐입니다. 여기서 오는 또 하나의 장점은 이렇게 미리 HTML 문서를 만들 경우 배포가 매우 쉽다는 점입니다. 어느 웹서버든 HTML은 serve할 수 있습니다. 복잡하게 어떤 언어를 쓰면 이렇게 하고 어떤 프레임워크를 써면 저렇게 하고 프록시 서버 써서 도메인 돌리고 그런 걸 고민할 필요가 없습니다. 싸구려 호스팅에 올려도 되고, 남는 서버에 올려도 되고, 아마존 S3에 올려도 되고, Github Pages로 배포할 수도 있습니다. 어플리케이션이 아니니 SQL injection 같은 보안 이슈도 없고요. 오오... 은근히 좋아보이네요. &lt;/p&gt;

&lt;p&gt;하지만!&lt;/p&gt;

&lt;p&gt;네, 이제, 웹 프레임워크는 다 버리고 HTML 하드 코딩하시면 되겠습니다.&lt;/p&gt;

&lt;p&gt;바로 여기입니다. 당연히 HTML을 직접 작성해야하는 &lt;strong&gt;정적&lt;/strong&gt; 방식이 좋다고는 결코 말할 수 없습니다. 즉 &lt;code&gt;2 * 10 + 1 * 1 + 1 * 0.1&lt;/code&gt; 세기에 다시 주목받는 정적 웹사이트란, 단순히 HTML을 Serve 해준다는 의미에서의 웹사이트를 말하는 것이 아니라 거기서 한 층 더 나아가 웹사이트를 동적으로 생성하되, 정적으로 Serve 한다는 의미에서 정적 웹사이트 생성기가 되는 것입니다. 이는 프로그래밍에 있어서 &lt;strong&gt;컴파일&lt;/strong&gt;의 사전적인 의미에 좀 더 가까운 작업입니다. 실제로 미리 모든 것을 만들어둔다는 점에서는 프로그래밍의 컴파일 개념과도 비슷합니다.&lt;/p&gt;

&lt;p&gt;예를 들어보죠. 이러한 방식을 적용할 수 있는 정말 좋은 플랫폼이 &lt;strong&gt;블로그&lt;/strong&gt;입니다. 블로그는 시작부터 HTML 문서들을 좀 더 쉽게 배포하기 위한 &lt;strong&gt;동적&lt;/strong&gt;인 플랫폼으로 출발했거나, 그런 목적으로 개발되었습니다. 하지만 문서 기반의 모든 플랫폼은 본질적으로 &lt;strong&gt;내가 가진 문서를 얼마나 잘 보여줄 것인가&lt;/strong&gt; 하는 문제가 가장 중요한 문제입니다. 그런데 여기서 &lt;strong&gt;문서&lt;/strong&gt;란 &lt;strong&gt;정적&lt;/strong&gt;입니다. 그러나 문서를 지원하는 다양한 페이지들은 동적입니다. 이런 페이지에는 페이징, 카테고리, 태그, 날짜 기반 페이지, Feed가 있습니다. 그런데 여기서 동적이라는 b말의 시점을 잘 따져볼 필요가 있습니다. 웹페이지가 동적으로 생성된다는 의미는 웹페이지가 &lt;code&gt;request&lt;/code&gt;되는 시점에서 동적으로 &lt;code&gt;response&lt;/code&gt;를 생성한다는 의미입니다. 그런데 페이징, 카테고리, 태그, 날짜 기반 페이지, Feed와 같은 블로그의 핵심 기능들은 request를 요청하는 시점이 아니라, 블로그 운영자가 포스트를 올리는 시점에 &lt;strong&gt;동적&lt;/strong&gt;입니다. 즉, 이 시점을 제외하고는 항상 아무것도 변하지 않습니다. 같은 &lt;strong&gt;동적&lt;/strong&gt;이라고 말해도 실제로는 시점이 페이지가 완결되는 시점이 다르다는 점입니다. 물론 글을 쓴 시점에 &lt;code&gt;response&lt;/code&gt;가 완성된다는 의미는 아닙니다. 대부분의 웹 어플리케이션은 lazy하기 때문에 처음 &lt;code&gt;request&lt;/code&gt;가 들어오는 시점에 해당 페이지를 적절히 생성하고 캐시합니다. 중요한 건 실제로는 포스트를 올린 시점에 블로그의 모든 페이지가 정적으로 완결될 수 있다는 점입니다. 즉 블로그의 모든 페이지를 미리 생성할 수 있습니다. 이미 이러한 방식을 지원하는 툴들이 이미 존재합니다. Jekyll을 기반으로하는 Octopress를 사용한다면 바로 글을 쓰는 시점에 블로그에 포함되는 모든 페이지를 &lt;strong&gt;정적 페이지&lt;/strong&gt;, 바꿔말해 HTML 파일로 만들어 줍니다.&lt;/p&gt;

&lt;p&gt;단, 여기에는 약간의 함정이 있습니다. 블로그에도 정말 적은 부분이지만 사용자의 요청이 발생하는 시점에서 실시간으로 동적으로 생성하고 반응해야하는 부분이 있습니다. 바로 댓글입니다. 이 부분은 따로 고민하지 않습니다. 그냥 댓글이 들어갈 부분에 &lt;a href="http://disqus.com/"&gt;Disqus&lt;/a&gt;를 삽입합니다.&lt;/p&gt;

&lt;p&gt;이렇듯 의외로 블로그는 정적인 웹 플랫폼입니다. 근데 더 큰 함정이 있군요. 이렇게 만들면 블로그에 글은 어떻게 쓸까요? 다르게 말하면 블로그에서 가장 동적인 부분은 글을 작성하는 부분입니다. 이런 부분은 정적 블로그 생성기에서는 존재하지 않습니다. 여기서 모든 포스트는 그저 마크다운 파일일 뿐입니다. 또한 글이 작성된 시점이나 사이트에 기능이나 페이지가 더해진 시점을 일반적으로 Git 저장소에 push가 일어난 시점으로 판단합니다. 이런 부분은 일반인들이 이런 툴을 사용하기에 매우 프로그래머스럽습니다. 하지만 프로그래머들에게 이런 점은 다른 방향에서 자유를 선사합니다. 바로 블로그 글을 자신이 원하는 에디터로 작성 할 수 있다는 점입니다. 저는 지금 이 글을 제가 애용하는 에디터인 Emacs 위에서 작성하고 있습니다. 예전부터 블로그나 위키를 운영하면서 에디터 통합을 꿈꾸던 입장에서는 지금은 너무 쉽게 이런 접근이 가능합니다. 물론 또다른 방향에서 웹 편집기들은 발전하고 있습니다. &lt;a href="https://github.com/HackerWins/summernote"&gt;Summernote&lt;/a&gt;와 같은 부트스트랩 기반의 에디터도 있고 &lt;a href="http://ghost.org"&gt;Ghost&lt;/a&gt;와 같은 마크다운 프리뷰를 바로 보여주는 훌륭한 플랫폼도 있습니다. Mediawiki에는 웹문서에서 바로 편집을 하는 것 같은 경험을 제공하는 &lt;a href="http://www.mediawiki.org/wiki/VisualEditor"&gt;Visual Editor&lt;/a&gt; 같은 확장도 있습니다.[^1] 많은 훌륭한 시도들이 있습니다만 여전히 웹에서 글을 작성한다는 것은 전용 에디터에 비해서 매우 불만족스러운 일입니다. 반면에 마크다운 파일을 기반으로 하고 있다면 그저 텍스트 문서를 원하는 에디터에서 작성하면 그만입니다.&lt;/p&gt;

&lt;p&gt;[^1]: http://www.mediawiki.org/wiki/VisualEditor 에서 직접 edit를 해보시기 바랍니다.&lt;/p&gt;

&lt;p&gt;아시는 분은 아시겠지만! 이미 &lt;a href="http://github.com"&gt;Github&lt;/a&gt;을 적극 활용하는 많은 분들은 Github Pages와 Github에서 지원하는 루비 기반의 정적 웹페이지 생성기(이자 Github CEO가 만든)인 &lt;a href="http://jekyllrb.com/"&gt;Jekyll&lt;/a&gt;을 적극 활용해서 블로그나 사이트를 운영하고 있습니다. 단순히 블로그에서만 사용할 수 있는 건 아닙니다. 이미 괜찮은 블로그 솔루션들이 마련되어 있기에 편하게 사용할 수 있는 것 뿐이지, 결과적으로 정적인 사이트라면 얼마든지 생성할 수 있습니다. 루비 커뮤니티에서 두 번째로 유명한 &lt;a href="http://middlemanapp.com/community/built-using-middleman/"&gt;Middleman으로 생성한 사례들&lt;/a&gt;도 매우 많습니다. 이 사이트도 Middleman으로 만들어졌고, 글을 작성하면 &lt;a href="https://travis-ci.org/"&gt;Travis&lt;/a&gt;를 통해 빌드하고, 다시 변경된 내용을 Github Repository에 반영해 Github Pages로 배포되고 있습니다. 이러한 활용 방법에 대해서는 다른 포스트에서 좀 더 자세히 다루겠습니다. 이 외에도 &lt;a href="http://staticsitegenerators.net/"&gt;Static Site Generator&lt;/a&gt;와 &lt;a href="http://modernstatic.com/"&gt;Modern Static&lt;/a&gt;에서는 다양한 정적 웹페이지 생성기들을 소개하고 있습니다.&lt;/p&gt;

&lt;p&gt;당연하게도 이런 정적 페이지 생성기들은 정적 페이지를 통한 배포의 이점을 전부 그대로 누립니다. 그냥 HTML 문서니까요. 동시에 빌드 시점에서는 프로그래밍 언어의 강력함도 누릴 수 있습니다. &lt;/p&gt;

&lt;p&gt;결국에 중요한 문제는 어느 시점에서 &lt;strong&gt;동적&lt;/strong&gt;이면 되는가의 문제로 귀결됩니다. 블로그가 정적 웹페이지로도 만들어질 수도 있는 건 모든 시점에 동적일 필요가 없었기 때문입니다. 반면에 소셜 사이트를 정적 웹페이지로 만드는 건 거의 불가능하다고 봐도 되겠죠. 네, 케바케입니다. 하지만 분명한 건 정적 웹페이지로 만들 수 있는 페이지를 동적 어플리케이션으로 서버에 물려놓는 건 사이트 구축은 그렇다고 쳐도, 운영 면에서 불리합니다. 정적 웹페이지 생성기는 중간쯤 어딘가에서 어떤 공백을 메워줍니다.&lt;/p&gt;

&lt;p&gt;네, 모든 종류의 웹사이트가 정적일 수는 없습니다. 거꾸로 모든 종류의 웹사이트가 동적일 필요도 없는 거고, 적절한 타협점이 필요한 거죠.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>hub로 명령행에서 Github 풀리퀘스트 보내기</title>
    <link rel="alternate" href="http://blog.url.com/articles/2013-12-29-hub-and-pull-request/"/>
    <id>http://blog.url.com/articles/2013-12-29-hub-and-pull-request/</id>
    <published>2013-12-29T06:31:32Z</published>
    <updated>2014-01-18T16:38:51+00:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;오픈소스를 비롯해 git를 사용해 소스 코드의 버전관리를 하는 경우엔 원격 git 저장소로 Github를 많이 사용합니다. Github는 단순히 git 저장소 역할을 하는 것뿐만 아니라 웹 인터페이스를 통해서 저장소를 관리할 수 있게 도와주며, 소스코드를 공유하고 협업하기 위한 다양한 기능을 제공합니다.&lt;/p&gt;



&lt;p&gt;예를 들어서 다른 사람이 만든 저장소를 자신의 계정에 fork해서 별도로 관리할 수 있고, 이렇게 fork해서 수정한 저장소의 브랜치를 pull-request를 통해서 원래의 저장소에 통합하도록 요청할 수도 있습니다. 이외에도 이슈 관리와 위키를 비롯한 매우 다양한 기능들이 지원됩니다. 이러한 Github의 장점들은 단순히 git을 활용한 좋은 버전관리 시스템이라는 것을 넘어서 프로젝트 관리를 위한 도구로서 Github 서비스를 차별화 시켜줍니다.&lt;/p&gt;

&lt;p&gt;하지만 대부분의 기능들은 기본적으로 웹인터페이스로만 사용할 수 있다는 단점이 있습니다. Git의 가장 기본적인 클라이언트 프로그램은 git 명령어로 커맨드라인에서 사용할 수 있습니다. 하지만 Github는 일차적으로 웹서비스로서 부가적인 기능들을 웹을 통해서 제공합니다. GUI나 화면에 익숙한 분들에게는 이러한 면은 또다른 장점이 될 수도 있겠지만, 커맨드 라인에서 직접 git 명령어를 입력하고, 저장소의 상태를 확인하는 사람들에게는 워크 플로우가 웹과 커맨드라인으로 나눠진다는 게 영 장점이지만은 않습니다.&lt;/p&gt;

&lt;p&gt;물론 Github에서 제공하는 API를 직접 이용하는 방법도 있긴있겠습니다만, 매우 번거로운 작업입니다. Github에서는 이러한 문제를 해결하기 위해서 저장소 생성, 포크 및 풀리퀘스트 등 주요한 기능을 커맨드라인 인터페이스로 제공해주는 Hub라는 git 명령어의 확장 인터페이스를 제공하고 있습니다. &lt;a href="https://github.com/github/hub"&gt;Hub&lt;/a&gt;라는 이름은 git + hub = Github 라는 공식에서 나온 이름도 참 앙증맞습니다.&lt;/p&gt;

&lt;p&gt;이 글은 Hub를 설치하고 실제 커맨드라인에서 풀리퀘스트를 보내는 과정을 다룹니다. 기본적으로 Github의 풀리퀘스트 기능 정도는 익숙하다는 걸 전제로(최소한 개념 정도는 이해하고 있다는 전제로) 이야기합니다.&lt;/p&gt;

&lt;h1&gt;Hub 설치&lt;/h1&gt;

&lt;p&gt;먼저 Hub를 사용하기 위해서는 공식 홈페이지를 참조해 프로그램을 설치해줄 필요가 있습니다. 우선 hub는 git과 ruby에 의존적인 프로그램이므로 시스템에 이러한 프로그램들이 있는지 확인해야합니다.&lt;/p&gt;

&lt;p&gt;```sh
$ git -v
git version 1.8.3.2&lt;/p&gt;

&lt;h1&gt;git 1.7.3 이상 필요!&lt;/h1&gt;

&lt;p&gt;$ ruby -v
ruby 2.1.0p0 (2013-12-25 revision 44422) [x86_64-linux]&lt;/p&gt;

&lt;h1&gt;ruby 1.8.6 이상 필요!&lt;/h1&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;위의 프로그램들이 설치돼있다면 이제 Hub를 설치할 차례입니다. 맥에서는  Homebrew[^brew]를 이용해 hub를 쉽게 설치할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sh
brew install hub
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;리눅스 계열에서는 소스 코드를 다운로드 받아 직접 설치할 수 있습니다. 아래 과정을 따라 hub를 설치할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sh
$ git clone git://github.com/github/hub.git
$ cd hub
$ rake install
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;설치 시 ruby의 &lt;code&gt;rake&lt;/code&gt; 명령어가 지원되어야합니다. &lt;code&gt;rake&lt;/code&gt; 명령어가 없다면 &lt;code&gt;gem install rake&lt;/code&gt;로 먼저 rake를 설치해주시기 바랍니다. 또한 &lt;code&gt;rake install&lt;/code&gt; 명령어 실행시 기본적으로 메인 시스템 상에 프로그램을 설치하므로 &lt;code&gt;sudo&lt;/code&gt; 등을 붙여 관리자 권한으로 설치해야할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;설치가 정상적으로 끝났다면 아래와 같이 &lt;code&gt;hub&lt;/code&gt; 명령어를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sh
$ hub --version
git version 1.8.3.2
hub version 1.11.1
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;hub는 &lt;code&gt;hub&lt;/code&gt; 명령어를 통해서 독자적으로 사용할 수도 있지만 &lt;code&gt;git&lt;/code&gt; 명령어와 통합해서 사용할 수도 있습니다. &lt;code&gt;hub alias&lt;/code&gt; 명령어를 실행하면 &lt;code&gt;git&lt;/code&gt; 명령어와 통합하는 방법을 알려줍니다.&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h1&gt;Wrap git automatically by adding the following to ~/.zshrc:&lt;/h1&gt;

&lt;p&gt;eval &amp;quot;$(hub alias -s)&amp;quot;
```&lt;/p&gt;

&lt;p&gt;예를 들어 zsh 사용하고 있다면 &lt;code&gt;~/.zshrc&lt;/code&gt; 파일에, bash를 사용하고 있다면 &lt;code&gt;~/.bash_profile&lt;/code&gt; 파일에 &lt;code&gt;eval &amp;quot;$(hub alias -s)&amp;quot;&lt;/code&gt;을 추가해주면 쉘 초기화 시에 git와 hub 명령어를 통합시켜줍니다. git와 hub 명령어는 기능적으로는 겹치지 않으며, hub가 git를 보완하는 역할을 하고 있으므로 이렇게 사용하더라도 별다른 문제가 되지 않습니다.&lt;/p&gt;

&lt;p&gt;이제 설치가 끝났으니 쉘을 재실행 시켜줍니다. git 명령어를 통해서 제대로 alias 되었는지 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ git --version
git version 1.8.3.2
hub version 1.11.1
&lt;/code&gt;&lt;/p&gt;

&lt;h1&gt;쉘에서 Hub 자동 완성 사용하기&lt;/h1&gt;

&lt;p&gt;Hub에서는 쉘에서 명령어 및 옵션 자동 완성을 위한 completion 파일을 제공하고 있습니다. 여기서 zsh을 기준으로 git 명령어의 자동완성을 확장하는 법을 설명합니다. 먼저 hub 자동 완성 파일을 다운로드 받아 적절한 위치(우분투의 경우 기본적으로  &lt;code&gt;usr/local/share/zsh/site-functions&lt;/code&gt; 디렉토리. 정확한 위치는 각 운영체제 별 zsh 환경 설정 파일 위치에 따릅니다)에 복사해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ mkdir ~/src
$ cd ~/src
$ wget https://raw.github.com/github/hub/master/etc/hub.zsh_completion
$ sudo mv hub.zsh_completion /usr/share/zsh/site-functions/_hub
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;zsh을 다시 실행하면 아래와 같이 hub 명령어 사용시 자동완성이 적용되는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ hub pull&amp;lt;TAB&amp;gt;
pull          -- fetch from and merge with another rep....
pull-request  -- open a pull request on GitHub
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git&lt;/code&gt; 명령어와 통합해서 사용중인 경우에는 .zshrc에 아래 라인을 추가해 git 명령어에서도 hub 명령어의 자동완성을 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
compdef git=hub
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;아래와 같이 자동 완성이 적용된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ git pull&amp;lt;TAB&amp;gt;
pull          -- fetch from and merge with another rep....
pull-request  -- open a pull request on GitHub
&lt;/code&gt;&lt;/p&gt;

&lt;h1&gt;Hub 사용하기&lt;/h1&gt;

&lt;p&gt;Hub의 다양한 명령어에 대해서는 공식 저장소에 간략한 사용법들이 나와있습니다. 여기서는 Hub를 사용해 Github에 저장소를 만들어보고, Github의 핵심 기능중 하나인 풀리퀘스트를 실제로 보내보겠습니다. (단, 여기서는 같은 저장소의 브랜치간에 풀리퀘스트를 보냅니다.)&lt;/p&gt;

&lt;p&gt;먼저 Git 저장소를 가진 디렉토리를 하나 생성해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ pwd
/home/nacyot/prog/github/nacyot/
$ mkdir pull-request &amp;amp;&amp;amp; cd $_
$ git init
Initialized empty Git repository in/home/nacyot/prog/github/nacyot/pull-request/.git/
$ git create
Updating origin
created repository: nacyot/pull-request
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;일반적으로 Git 저장소를 초기화할 때는 &lt;code&gt;git init&lt;/code&gt; 명령어를 사용합니다. 여기서는 추가적으로 &lt;code&gt;git create&lt;/code&gt; 명령어를 사용했습니다. 이 명령어는 hub를 통해 확장된 명령어로 현재 git 저장소로 Github에 저장소를 생성해줍니다. &lt;code&gt;git remote&lt;/code&gt; 원격 저장소 설정이 제대로 되었는지 확인해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ git remote -v
origin  git@github.com:nacyot/pull-request.git (fetch)
origin  git@github.com:nacyot/pull-request.git (push)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이를 통해서 Github &lt;a href="http://github.com/nacyot"&gt;nacyot&lt;/a&gt; 계정에 &lt;a href="http://github.com/nacyot/pull-request"&gt;pull-request 저장소&lt;/a&gt;가 추가되었다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;우선 master 브랜치를 활성화시키기 위해 커밋을 하나 해보겠습니다.&lt;/p&gt;

&lt;p&gt;```sh
$ touch README.md
$ git add .
$ git commit -m&amp;#39;Add README.md&amp;#39;
$ git push origin master&lt;/p&gt;

&lt;p&gt;Counting objects: 3, done.
Writing objects: 100% (3/3), 221 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To git@github.com:nacyot/pull-request.git
* [new branch]      master -&amp;gt; master
```&lt;/p&gt;

&lt;p&gt;이 명령어들은 일반적으로 git에서 사용하는 명령어들입니다. 이제 파일들이 정상적으로 추가되었는지를 확인하기 위해 이 저장소의 웹페이지를 띄워보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sh
$ git browse
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git browse&lt;/code&gt; 명령어도 hub 확장으로 현재 디렉토리에 위치한 git 저장소의 원격 저장소를 근거로 Github 페이지를 찾아 바로 웹브라우져를 열어줍니다. 이 명령어를 통해서 따로 웹브라우져를 실행시키지 않더라도 저장소의 Github 페이지를 바로 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img alt="repository" src="images/2013-12-29-hub-and-pull-request/repository.png" /&gt;&lt;/p&gt;

&lt;p&gt;이제 pull-request 브랜치를 만들고 실제로 풀리퀘스트를 보내보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ git checkout -b pull-request
$ git touch hello.rb
$ git add .
$ git commit -m&amp;#39;Add hello.rb&amp;#39;
$ git push origin pull-request
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;위의 명령어들 역시 git에서 일반적으로 사용하는 명령어들로 추가적인 설명은 생략하겠습니다. 간단히만 얘기하면 pull-request 브랜치를 만들고 &lt;code&gt;hello.rb&lt;/code&gt; 파일을 추가하고 Github 저장소에도 추가했습니다. 이제 nacyot/pull-request 에는 master 브랜치와 pull-request 두 브랜치가 존재합니다.&lt;/p&gt;

&lt;p&gt;여기서는 pull-request 브랜치에서 master 브랜치로 풀리퀘스트를 보내겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ git pull-request
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git pull-request&lt;/code&gt; 명령어를 실행시키면 현재 디렉토리의 github 저장소와 브랜치를 기준으로 풀리퀘스트를 보내기 위한 메시지를 입력할 수 있도록 기본 에디터를 실행해줍니다.&lt;/p&gt;

&lt;p&gt;```
First pull-request&lt;/p&gt;

&lt;h1&gt;Requesting a pull to nacyot:master from nacyot:pull-request&lt;/h1&gt;

&lt;h1&gt;Write a message for this pull request. The first block&lt;/h1&gt;

&lt;h1&gt;of text is the title and the rest is description.&lt;/h1&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;주석을 통해서 풀리퀘스트가 어디로 보내지는지 확인할 수 있습니다. 풀리퀘스트 메시지를 완성하고 저장한 후 에디터를 종료하면 풀리퀘스트가 보내집니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
https://github.com/nacyot/pull-request/pull/1
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;풀리퀘스트를 보내는데 성공하면 위와 같이 풀리퀘스트의 url을 보여줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img alt="pull-request" src="images/2013-12-29-hub-and-pull-request/pull-request.png" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git pull-request&lt;/code&gt; 명령어는 아래와 같이 좀 더 명시적으로 사용할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ git pull-request -m &amp;#39;First pull-request&amp;#39; -b nacyot:master -h nacyot:pull-request
https://github.com/nacyot/pull-request/pull/1
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;code&gt;-m&lt;/code&gt; 플래그는 풀리퀘스트 메시지, &lt;code&gt;-b&lt;/code&gt; 플래그는 풀리퀘스트 목적지, &lt;code&gt;-h&lt;/code&gt; 플래그는 풀리퀘스트를 보내는 브랜치가 됩니다. &lt;code&gt;-b&lt;/code&gt;와 &lt;code&gt;-h&lt;/code&gt; 플래그는 &lt;code&gt;&amp;lt;계정명&amp;gt;:&amp;lt;브랜치명&amp;gt;&lt;/code&gt; 형식으로 기술하며, 저장소는 작업 디렉토리 저장소를 근거로 자동으로 유추됩니다. 마찬가지로 풀리퀘스트에 성공하면 풀리퀘스트의 url을 보여줍니다.&lt;/p&gt;

&lt;h1&gt;결론&lt;/h1&gt;

&lt;p&gt;여기까지 git 명령어를 hub로 확장해서 커맨드라인에서 Github 작업을 좀 더 편하게 하는 방법을 소개했습니다. hub는 웹에서 해야하는 귀찮은 일들을 많이 덜어주는 프로그램입니다. Github에서 저장소를 만들고 풀리퀘스트를 보내려고 웹상에서 브랜치 지정해주고 하는 일은 간단한 작업이지만 꽤나 번거롭습니다. 특히 해당 &amp;#39;저장소&amp;#39;를 찾아서 들어가는 일도 반복되면 귀찮기만 한 일입니다. hub와 함께 좀 더 즐거운 Github 라이프가 되길 바랍니다 &amp;gt;_&amp;lt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>알아두면 도움이 되는 55가지 루비 기법</title>
    <link rel="alternate" href="http://blog.url.com/articles/2013-11-24-ruby-trivias-you-should-know-4/"/>
    <id>http://blog.url.com/articles/2013-11-24-ruby-trivias-you-should-know-4/</id>
    <published>2013-11-24T03:00:00Z</published>
    <updated>2014-01-18T16:38:51+00:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;이 글은 &lt;a href="http://melborne.github.io/"&gt;kyoendo&lt;/a&gt; 씨의 55 Trivia Notations you should know in Ruby 문서를 &lt;a href="http://nacyot.com"&gt;nacyot&lt;/a&gt;이 번역한 글입니다. 번역된 문서는 &lt;a href="https://gist.github.com/nacyot/7624036"&gt;gist&lt;/a&gt;에서 관리되고 있습니다. 원본은 &lt;a href="http://melborne.github.io/2013/03/04/ruby-trivias-you-should-know-4/"&gt;여기&lt;/a&gt;에서 찾아볼 수 있으며 &lt;a href="http://creativecommons.org/licenses/by-nc/2.1/jp/"&gt;cc-by-nc&lt;/a&gt; 라이센스에 따라 공개되어있습니다. 번역본 또한 같은 라이센스를 따릅니다. 관련된 질문은 &lt;a href="http://nacyot.com/guestbook"&gt;GuestBook&lt;/a&gt;이나 &lt;a href="mailto:propellerheaven@gmail.com"&gt;Email&lt;/a&gt;으로 해주시기합니다.&lt;/p&gt;



&lt;hr&gt;

&lt;p&gt;Ruby는 즐거운 언어입니다. Ruby를 사용하다보면 매뉴얼에도 나와있지 않은
&amp;#39;&lt;strong&gt;작은 발견&lt;/strong&gt;&amp;#39;을 만나게 됩니다. 이러한 &amp;#39;발견&amp;#39;은 프로그램의 질이나
효율 개선에 직접적으로 연결되지 않을 지도 모릅니다. 좋기는 커녕 팀
단위로 프로그래밍을 하는 동안에는 사용하지 않는 게 좋을 지도
모릅니다. 하지만 다른 시각에서 생각해보면, 어떤 언어에 아직 모르는
영역이 남아있다는 건 이 언어에 대한 흥미를 잃지 않게 만들어주는 중요한
요인이라는 것도 의심의 여지가 없습니다. 즉 &amp;#39;발견&amp;#39;은 언어를 즐겁게 만들어줍니다 .&lt;/p&gt;

&lt;p&gt;이 블로그에서는 &amp;#39;알아두면 도움이 되는 루비 기법&amp;#39;이라는 주제로 지금까지 3 편의 글을 써왔습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href="http://melborne.github.com/2011/06/22/21-Ruby-21-Trivia-Notations-you-should-know-in-Ruby/"&gt;알아두면 도움이 되는 21가지 루비 기법&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://melborne.github.com/2012/02/08/2-12-Ruby-12-Trivia-Notations-you-should-know-in-Ruby/"&gt;제 2탄! 알아두면 도움이 되는 12가지 루비 기법&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://melborne.github.com/2012/04/26/ruby-trivias-you-should-know/"&gt;제 3탄! 알아두면 도움이 되는 12가지 루비 기법&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 기법들은 인터넷에서 발견한 것, 트위터에서 배운 것, 스스로 발견한 것들을 모은 것들입니다. 이런 기법들을 접할 때마다 제 입에서는 &amp;#39;아하&amp;#39;, &amp;#39;우와&amp;#39; 같은 감탄사가 절로 나왔습니다.&lt;/p&gt;

&lt;p&gt;여기서는 위에서 다룬 45개의 기법과 추가적으로 새로운 10가지 기법을
합쳐 55가지 기법을 소개합니다. 전체적인 내용을 재구성했으면 비교적
이해하기 쉬운 내용을 앞에 배치하고 약간 어려운 부분을 뒤에
배치했습니다. 몇몇 설명에 대해서는 좀 더 간결하게 수정했습니다. 여기서는 언어를
어떻게 사용해야할 것인가, 혹은 어떻게 읽기 쉬운 코드를 작성할 수
있을까 하는 어려운 문제는 제쳐두고 일단 재미나 보이는 기법들에 대해
이렇게 작성할 수 있구나 하면서 즐기셨으면 합니다. Ruby 버전은 1.9나 2.0을 대상으로 합니다.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;그리고 이 글은 E-Books으로도 출간되었습니다. 이 글을 E-Books 형식으로 천천히
음미하고 싶으신 분은 구입을 고려해주세요. epub 형식은 물론 Kindle에서
사용 가능한 mobi 형식도 포함되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://melborne.github.io/books/"&gt;
  &lt;img src="http://melborne.github.io/assets/images/2013/03/ruby_trivia_cover.png" alt="trivia" style="width:200px" /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a title="M'ELBORNE BOOKS" href="http://melborne.github.io/books/"&gt;M&amp;#39;ELBORNE BOOKS&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;1. Array 객체의 스택 메소드&lt;/h3&gt;

&lt;p&gt;x
&lt;code&gt;Array#&amp;lt;&amp;lt;&lt;/code&gt; 메소드는 인수를 하나만 받습니다만 &lt;code&gt;Array#push&lt;/code&gt;는 여러개의
인수를 받을 수 있습니다. 또한 &lt;code&gt;Array#pop&lt;/code&gt;는 한 번에 여러개의 값을 pop 할 수 있습니다.&lt;code&gt;Array#unshift&lt;/code&gt; &lt;code&gt;Array#shift&lt;/code&gt;도 마찬가지입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
 stack = []
 stack.push 1, 2, 3 # =&amp;gt; [1, 2, 3]
 stack.pop 2 # =&amp;gt; [2, 3]
 stack # =&amp;gt; [1]
 stack.unshift 4, 5, 6 # =&amp;gt; [4, 5, 6, 1]
 stack.shift 3 # =&amp;gt; [4, 5, 6]
 stack # =&amp;gt; [1]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;또한 특정 위치에서 여러개의 값을 가져올 때는 &lt;code&gt;Array#values_at&lt;/code&gt;이 편리합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
 lang = %w(ruby python perl haskell lisp scala)
 lang.values_at 0, 2, 5 # =&amp;gt; [&amp;quot;ruby&amp;quot;, &amp;quot;perl&amp;quot;, &amp;quot;scala&amp;quot;]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이 메소드는 Hash 객체에서도 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
lang = {ruby:&amp;#39;matz&amp;#39;, python:&amp;#39;guido&amp;#39;, perl:&amp;#39;larry&amp;#39;, lisp:&amp;#39;mccarthy&amp;#39;}&lt;/p&gt;

&lt;p&gt;lang.values_at :ruby, :perl # =&amp;gt; [&amp;quot;matz&amp;quot;, &amp;quot;larry&amp;quot;]
```&lt;/p&gt;

&lt;h3&gt;2. Kernel#Array&lt;/h3&gt;

&lt;p&gt;서로 다른 타입을 가진 인수를 일괄적으로 처리할 때는 &lt;code&gt;Kernel#Array&lt;/code&gt;가 편리합니다.&lt;/p&gt;

&lt;p&gt;```ruby
 Array 1 # =&amp;gt; [1]
 Array [1,2] # =&amp;gt; [1, 2]
 Array 1..5 # =&amp;gt; [1, 2, 3, 4, 5]&lt;/p&gt;

&lt;p&gt;require &amp;quot;date&amp;quot;
 def int2month(nums)
   Array(nums).map { |n| Date.new(2010,n).strftime &amp;quot;%B&amp;quot;  }
 end&lt;/p&gt;

&lt;p&gt;int2month(3) # =&amp;gt; [&amp;quot;March&amp;quot;]
 int2month([2,6,9]) # =&amp;gt; [&amp;quot;February&amp;quot;, &amp;quot;June&amp;quot;, &amp;quot;September&amp;quot;]
 int2month(4..8) # =&amp;gt; [&amp;quot;April&amp;quot;, &amp;quot;May&amp;quot;, &amp;quot;June&amp;quot;, &amp;quot;July&amp;quot;, &amp;quot;August&amp;quot;]
```&lt;/p&gt;

&lt;h3&gt;3. 요소 구분 콤마&lt;/h3&gt;

&lt;p&gt;배열과 해시의 각 요소를 구분하는 기호로 콤마를 사용하는데 마지막 요소의 콤마는 무시됩니다.&lt;/p&gt;

&lt;p&gt;```ruby
 p designers = [
                 &amp;quot;John McCarthy&amp;quot;,
                 &amp;quot;Yukihiro Matsumoto&amp;quot;,
                 &amp;quot;Larry Wall&amp;quot;,
                 &amp;quot;Alan Kay&amp;quot;,
                 &amp;quot;Martin Odersky&amp;quot;,
               ]&lt;/p&gt;

&lt;p&gt;# &amp;gt;&amp;gt; [&amp;quot;John McCarthy&amp;quot;, &amp;quot;Yukihiro Matsumoto&amp;quot;, &amp;quot;Larry Wall&amp;quot;, &amp;quot;Alan Kay&amp;quot;, &amp;quot;Martin Odersky&amp;quot;]&lt;/p&gt;

&lt;p&gt;p designers = {
                 :lisp =&amp;gt; &amp;quot;John McCarthy&amp;quot;,
                 :ruby =&amp;gt; &amp;quot;Yukihiro Matsumoto&amp;quot;,
                 :perl =&amp;gt; &amp;quot;Larry Wall&amp;quot;,
                 :smalltalk =&amp;gt; &amp;quot;Alan Kay&amp;quot;,
                 :scala =&amp;gt; &amp;quot;Martin Odersky&amp;quot;,
               }&lt;/p&gt;

&lt;p&gt;# &amp;gt;&amp;gt; {:lisp=&amp;gt;&amp;quot;John McCarthy&amp;quot;, :ruby=&amp;gt;&amp;quot;Yukihiro Matsumoto&amp;quot;, :perl=&amp;gt;&amp;quot;Larry Wall&amp;quot;, :smalltalk=&amp;gt;&amp;quot;Alan Kay&amp;quot;, :scala=&amp;gt;&amp;quot;Martin Odersky&amp;quot;}
```&lt;/p&gt;

&lt;p&gt;요소를 자주 추가/삭제하거나 파일에서 eval을 할 때 유용합니다.&lt;/p&gt;

&lt;h3&gt;4. 해시 리터럴&lt;/h3&gt;

&lt;p&gt;Ruby 1.9에는 새로운 해시 리터럴이 추가되었지만, 예전 방식과 혼용해서 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
 designers1 = {
               :lisp =&amp;gt; &amp;quot;John McCarthy&amp;quot;,
               :ruby =&amp;gt; &amp;quot;Yukihiro Matsumoto&amp;quot;,
               :perl =&amp;gt; &amp;quot;Larry Wall&amp;quot;,
               :smalltalk =&amp;gt; &amp;quot;Alan Kay&amp;quot;,
               :&amp;#39;C++&amp;#39; =&amp;gt;  &amp;quot;Bjarne Stroustrup&amp;quot;,
             }&lt;/p&gt;

&lt;p&gt;designers2 = {
               java: &amp;quot;James Gosling&amp;quot;,
               python: &amp;quot;Guido van Rossum&amp;quot;,
               javascript: &amp;quot;Brendan Eich&amp;quot;,
               scala: &amp;quot;Martin Odersky&amp;quot;,
             }&lt;/p&gt;

&lt;p&gt;designers = designers1.merge designers2
  # =&amp;gt; {:lisp=&amp;gt;&amp;quot;John McCarthy&amp;quot;, :ruby=&amp;gt;&amp;quot;Yukihiro Matsumoto&amp;quot;, :perl=&amp;gt;&amp;quot;Larry Wall&amp;quot;, :smalltalk=&amp;gt;&amp;quot;Alan Kay&amp;quot;, :&amp;quot;C++&amp;quot;=&amp;gt;&amp;quot;Bjarne Stroustrup&amp;quot;, :java=&amp;gt;&amp;quot;James Gosling&amp;quot;, :python=&amp;gt;&amp;quot;Guido van Rossum&amp;quot;, :javascript=&amp;gt;&amp;quot;Brendan Eich&amp;quot;, :scala=&amp;gt;&amp;quot;Martin Odersky&amp;quot;}
```&lt;/p&gt;

&lt;h3&gt;5. Enumerable#each&lt;em&gt;with&lt;/em&gt;object&lt;/h3&gt;

&lt;p&gt;Enumerable#inject는 편리한 메소드지만 블록에서 조건은 지정을 하는 경우에도 각 반복에서 결과값이 중첩될 객체가 리턴되는 것이 보장되어야만 합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
 designers.inject([]) { |mem, (lang, name)| mem &amp;lt;&amp;lt; [name,lang].join(&amp;#39;/&amp;#39;) if lang[/l/]; mem }
  # =&amp;gt; [&amp;quot;John McCarthy/lisp&amp;quot;, &amp;quot;Larry Wall/perl&amp;quot;, &amp;quot;Alan Kay/smalltalk&amp;quot;, &amp;quot;Martin Odersky/scala&amp;quot;]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;블록 마지막의 &amp;#39;; mem&amp;#39;부분입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Enumerable#each_with_object&lt;/code&gt;를 이러한 문제를 사용하면 간단히 해결할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
 designers.each_with_object([]) { |(lang, name), mem| mem &amp;lt;&amp;lt; [name,lang].join(&amp;#39;/&amp;#39;) if lang[/l/] }
  # =&amp;gt; [&amp;quot;John McCarthy/lisp&amp;quot;, &amp;quot;Larry Wall/perl&amp;quot;, &amp;quot;Alan Kay/smalltalk&amp;quot;, &amp;quot;Martin Odersky/scala&amp;quot;]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이름이 길어서 가능하면 사용하고 싶지 않습니다만...&lt;/p&gt;

&lt;h3&gt;6. splat 전개&lt;/h3&gt;

&lt;p&gt;Ruby에서 알파벳 배열을 만들 때는 보통 아래와 같은 방법을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
 (1..20).to_a # =&amp;gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
 (&amp;#39;a&amp;#39;..&amp;#39;z&amp;#39;).to_a # =&amp;gt; [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;f&amp;quot;, &amp;quot;g&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;j&amp;quot;, &amp;quot;k&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;n&amp;quot;, &amp;quot;o&amp;quot;, &amp;quot;p&amp;quot;, &amp;quot;q&amp;quot;, &amp;quot;r&amp;quot;, &amp;quot;s&amp;quot;, &amp;quot;t&amp;quot;, &amp;quot;u&amp;quot;, &amp;quot;v&amp;quot;, &amp;quot;w&amp;quot;, &amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;z&amp;quot;]
 (1..10).to_a + (20..30).to_a # =&amp;gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이러한 표현은 &lt;code&gt;*&lt;/code&gt;(splat) 전개를 사용해 아래와 같이 바꿔쓸 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
 [*1..20] # =&amp;gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
 [*&amp;#39;a&amp;#39;..&amp;#39;m&amp;#39;] # =&amp;gt; [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;f&amp;quot;, &amp;quot;g&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;j&amp;quot;, &amp;quot;k&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;m&amp;quot;]
 [*1..10, *20..30] # =&amp;gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;7. 전치 콜론&lt;/h3&gt;

&lt;p&gt;문자열을 심볼로 변환할 때는 일반적으로, String#intern이나
String#to_sym 메소드를 사용합니다만 문자열 리터럴에 앞에 콜론을 놓는
방법도 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
 &amp;#39;goodbye&amp;#39;.intern # =&amp;gt; :goodbye
 &amp;#39;goodbye&amp;#39;.to_sym # =&amp;gt; :goodbye&lt;/p&gt;

&lt;p&gt;:&amp;#39;goodbye&amp;#39; # =&amp;gt; :goodbye&lt;/p&gt;

&lt;p&gt;a = &amp;#39;goodbye&amp;#39;
 :&amp;quot;#{a}&amp;quot; # =&amp;gt; :goodbye
```&lt;/p&gt;

&lt;h3&gt;8. Enumerator#with_index&lt;/h3&gt;

&lt;p&gt;임의의 리스트를 표준 출력할 때 각 리스트의 순서를 나타내는 인덱스 숫자가 필요할 때 일반적으로 &lt;code&gt;Enumerator#with_index&lt;/code&gt;를 사용합니다.&lt;/p&gt;

&lt;p&gt;```ruby
names = Module.constants.take(10)
names.each&lt;em&gt;with&lt;/em&gt;index { |name, i| puts &amp;quot;%d: %s&amp;quot; % [i+1, name] }&lt;/p&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 1: Object&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 2: Module&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 3: Class&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 4: Kernel&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 5: NilClass&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 6: NIL&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 7: Data&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 8: TrueClass&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 9: TRUE&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 10: FalseClass&lt;/h1&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;&lt;code&gt;i+1&lt;/code&gt;를 사용하는 게 영 맘에 들지 않습니다. 여기에 공감하시는 분들을 위해 &lt;code&gt;Enumerator#with_index&lt;/code&gt; 메소드가 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
names = Module.constants.take(10)
names.each.with_index(1) { |name, i| puts &amp;quot;%d: %s&amp;quot; % [i, name] }&lt;/p&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 1: Object&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 2: Module&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 3: Class&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 4: Kernel&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 5: NilClass&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 6: NIL&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 7: Data&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 8: TrueClass&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 9: TRUE&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 10: FalseClass&lt;/h1&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;with_index는 index의 offset을 인수로 받습니다. comparable한 객체를 받아주면 더욱 좋겠습니다만.&lt;/p&gt;

&lt;h3&gt;9. Integer#times&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;times&lt;/code&gt;는 특정 횟수만큼 반복하고 싶을 때 사용합니다.&lt;/p&gt;

&lt;p&gt;```ruby
you&lt;em&gt;said = &amp;#39;てぶくろ&amp;#39;
6.times { puts you&lt;/em&gt;said.reverse!} # =&amp;gt; 6&lt;/p&gt;

&lt;h1&gt;&amp;gt;&amp;gt; ろくぶて&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; てぶくろ&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; ろくぶて&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; てぶくろ&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; ろくぶて&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; てぶくろ&lt;/h1&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;times는 블록을 받지 않으면 Enumerator를 리턴합니다. 따라서 여러개의
객체를 생성할 때 사용할 수 있습니다. 20개의 RGB 컬러 샘플을 만든다고 해보죠.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
20.times.map { [rand(256), rand(256), rand(256)] } # =&amp;gt; [[45, 190, 194], [94, 43, 125], [6, 104, 181], [144, 92, 114], [34, 161, 214], [96, 69, 241], [216, 246, 133], [6, 237, 131], [194, 95, 214], [177, 252, 202], [184, 149, 142], [184, 166, 45], [41, 108, 115], [176, 100, 138], [124, 213, 89], [173, 123, 34], [137, 31, 47], [54, 92, 186], [118, 239, 217], [150, 184, 240]]
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;10. String#succ / Integer#succ&lt;/h3&gt;

&lt;p&gt;Excel과 같이 A에서 부터 차례대로 문자로된 인덱스를 생성하려면 어떻게
해야할까요?최근에 비슷한 문제를 접했습니다. Ruby에선 &lt;code&gt;String#succ&lt;/code&gt; 또는 &lt;code&gt;next&lt;/code&gt;가 있으니 간단히 해결 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
col = &amp;#39;@&amp;#39;
60.times.map { col = col.succ } # =&amp;gt; [&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;D&amp;quot;, &amp;quot;E&amp;quot;, &amp;quot;F&amp;quot;, &amp;quot;G&amp;quot;, &amp;quot;H&amp;quot;, &amp;quot;I&amp;quot;, &amp;quot;J&amp;quot;, &amp;quot;K&amp;quot;, &amp;quot;L&amp;quot;, &amp;quot;M&amp;quot;, &amp;quot;N&amp;quot;, &amp;quot;O&amp;quot;, &amp;quot;P&amp;quot;, &amp;quot;Q&amp;quot;, &amp;quot;R&amp;quot;, &amp;quot;S&amp;quot;, &amp;quot;T&amp;quot;, &amp;quot;U&amp;quot;, &amp;quot;V&amp;quot;, &amp;quot;W&amp;quot;, &amp;quot;X&amp;quot;, &amp;quot;Y&amp;quot;, &amp;quot;Z&amp;quot;, &amp;quot;AA&amp;quot;, &amp;quot;AB&amp;quot;, &amp;quot;AC&amp;quot;, &amp;quot;AD&amp;quot;, &amp;quot;AE&amp;quot;, &amp;quot;AF&amp;quot;, &amp;quot;AG&amp;quot;, &amp;quot;AH&amp;quot;, &amp;quot;AI&amp;quot;, &amp;quot;AJ&amp;quot;, &amp;quot;AK&amp;quot;, &amp;quot;AL&amp;quot;, &amp;quot;AM&amp;quot;, &amp;quot;AN&amp;quot;, &amp;quot;AO&amp;quot;, &amp;quot;AP&amp;quot;, &amp;quot;AQ&amp;quot;, &amp;quot;AR&amp;quot;, &amp;quot;AS&amp;quot;, &amp;quot;AT&amp;quot;, &amp;quot;AU&amp;quot;, &amp;quot;AV&amp;quot;, &amp;quot;AW&amp;quot;, &amp;quot;AX&amp;quot;, &amp;quot;AY&amp;quot;, &amp;quot;AZ&amp;quot;, &amp;quot;BA&amp;quot;, &amp;quot;BB&amp;quot;, &amp;quot;BC&amp;quot;, &amp;quot;BD&amp;quot;, &amp;quot;BE&amp;quot;, &amp;quot;BF&amp;quot;, &amp;quot;BG&amp;quot;, &amp;quot;BH&amp;quot;]
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;11. Comparable.between?&lt;/h3&gt;

&lt;p&gt;값이 특정 범위 안에 있는 지 여부를 판단할 때 사용됩니다. 보통은 다음과 같이 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
pos = 48
status =
  if 0 &amp;lt;= pos &amp;amp;&amp;amp; pos &amp;lt;= 50
    :you_are_in
  else
    :you_are_out
  end
status # =&amp;gt; :you_are_in
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이렇게 짜놓고 CoffeeScript를 보면 분한 마음이 듭니다. 하지만 안심해주세요. Ruby에는 &lt;code&gt;between?&lt;/code&gt; 메소드가 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
pos = 48
status =
  if pos.between?(0, 50)
    :you&lt;em&gt;are&lt;/em&gt;in
  else
    :you&lt;em&gt;are&lt;/em&gt;out
  end
status # =&amp;gt; :you&lt;em&gt;are&lt;/em&gt;in&lt;/p&gt;

&lt;p&gt;pos = &amp;#39;D&amp;#39;
grade =
  if pos.between?(&amp;#39;A&amp;#39;, &amp;#39;C&amp;#39;)
    :you&lt;em&gt;are&lt;/em&gt;good!  else
    :try&lt;em&gt;again!  end
grade # =&amp;gt; :try&lt;/em&gt;again!
```&lt;/p&gt;

&lt;p&gt;저는 case 파 입니다만...&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
pos = 48
status =
  case pos
  when 0..50
    :you_are_in
  else
    :you_are_out
  end
status # =&amp;gt; :you_are_in
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;12. Array#first/last&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Array#first/last&lt;/code&gt;는 가져올 요소의 수를 인수로 받습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
arr = [*1..100]
arr.first(5) + arr.last(5) # =&amp;gt; [1, 2, 3, 4, 5, 96, 97, 98, 99, 100]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Range 객체에서도 같은 메소드를 지원하고 있으니, 위의 예제는 아래와 같이 작성할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
range = (1..100)
range.first(5) + range.last(5) # =&amp;gt; [1, 2, 3, 4, 5, 96, 97, 98, 99, 100]
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;13. 변수 nil 초기화&lt;/h3&gt;

&lt;p&gt;여러 변수를 &lt;code&gt;nil&lt;/code&gt;으로 초기화하려는 경우에 어떻게 하시나요?이렇게
하시나요?&lt;/p&gt;

&lt;p&gt;```ruby
a, b, c, d, e, f, g, h, i, k = [nil] * 10&lt;/p&gt;

&lt;p&gt;[a, b, c, d, e, f, g, h, i, k].all?(&amp;amp;:nil?) # =&amp;gt; true
```&lt;/p&gt;

&lt;p&gt;하지만 다중 대입을 할 때는 값이 없으면 nil이 지정되므로 아래 코드면 충분합니다.&lt;/p&gt;

&lt;p&gt;```ruby
a, b, c, d, e, f, g, h, i, k = nil&lt;/p&gt;

&lt;p&gt;[a, b, c, d, e, f, g, h, i, k].all?(&amp;amp;:nil?) # =&amp;gt; true
```&lt;/p&gt;

&lt;h3&gt;14. 해시 키&lt;/h3&gt;

&lt;p&gt;해시 리터럴은 다음과 같이 작성합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
{a: 1, b: 2, c: 3, a: 4, e: 5} # =&amp;gt; {:a=&amp;gt;4, :b=&amp;gt;2, :c=&amp;gt;3, :e=&amp;gt;5}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;눈치 채셨나요?실수로 키를 중복해서 사용해도 에러는 발생하지 않습니다.&lt;/p&gt;

&lt;p&gt;특히 배열을 해시로 변환할 때는 주의가 필요합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
arr = [a: 1, b: 2, c: 3, a: 4, e: 5]
Hash[ *arr ] # =&amp;gt; {:a=&amp;gt;4, :b=&amp;gt;2, :c=&amp;gt;3, :e=&amp;gt;5}
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;15. 메소드 인수의 인수&lt;/h3&gt;

&lt;p&gt;Ruby에서 인수를 받는 메소드를 호출할 때는 괄호를 생략할 수 있습니다만, 인수가 심볼일 때는 메소드 이름과 인수 사이의 공백도 생략할 수 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
 def name(sym)
   @name = sym
 end&lt;/p&gt;

&lt;p&gt;name:charlie # =&amp;gt; :charlie
```&lt;/p&gt;

&lt;p&gt;이렇게 작성하면 더욱 선언적으로 보입니다.&lt;/p&gt;

&lt;p&gt;하지만 이걸 변수에 넣거나 puts로 출력하는 경우엔 제대로 읽어들이지 못 하기 때문에 한정적인 방법이라고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;또한 * &amp;amp;의 뒤의 스페이스는 무시되므로 아래와 같이 작성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
 def teach_me(question, * args, &amp;amp; block)
   google(question, * args, &amp;amp; block)
 end&lt;/p&gt;

&lt;p&gt;a, b, * c = 1,2,3,4
 c # =&amp;gt; [3,4]
```&lt;/p&gt;

&lt;p&gt;그래서 어쨌다는 걸까요...&lt;/p&gt;

&lt;h3&gt;16. 부정&lt;/h3&gt;

&lt;p&gt;부정의 의미로 사용되는 &lt;code&gt;!&lt;/code&gt; 혹은 &lt;code&gt;not&lt;/code&gt;이 맘에 드시지 않는 분? &lt;/p&gt;

&lt;p&gt;그렇다면 &lt;code&gt;BaiscObject#!&lt;/code&gt;가 있습니다!&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
 true.!# =&amp;gt; false
 false.!# =&amp;gt; true
 1.!# =&amp;gt; false
 &amp;#39;hello&amp;#39;.!.!# =&amp;gt; true
&lt;/code&gt;
...&lt;/p&gt;

&lt;p&gt;다음으로 넘어가죠...&lt;/p&gt;

&lt;h3&gt;17. % 노테이션&lt;/h3&gt;

&lt;p&gt;String#%을 사용하면 문자열을 &lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
 lang = [:ruby, :java]
 &amp;quot;I love %s, not %s&amp;quot; % lang # =&amp;gt; &amp;quot;I love ruby, not java&amp;quot;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;뿐만 아니라 해시도 받을 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
 lang = {a: :java, b: :ruby}
 &amp;quot;I love %{b}, not %{a}&amp;quot; % lang # =&amp;gt; &amp;quot;I love ruby, not java&amp;quot;
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;18. 문자열 분리&lt;/h3&gt;

&lt;p&gt;문자열을 각 문자 별로 분리할 때는 &lt;code&gt;String#split&lt;/code&gt;나 &lt;code&gt;String#chars&lt;/code&gt; 메소드를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
 alpha = &amp;quot;abcdefghijklmnopqrstuvwxyz&amp;quot;
 alpha.split(//) # =&amp;gt; [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;f&amp;quot;, &amp;quot;g&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;j&amp;quot;, &amp;quot;k&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;n&amp;quot;, &amp;quot;o&amp;quot;, &amp;quot;p&amp;quot;, &amp;quot;q&amp;quot;, &amp;quot;r&amp;quot;, &amp;quot;s&amp;quot;, &amp;quot;t&amp;quot;, &amp;quot;u&amp;quot;, &amp;quot;v&amp;quot;, &amp;quot;w&amp;quot;, &amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;z&amp;quot;]&lt;/p&gt;

&lt;p&gt;alpha.chars.to_a # =&amp;gt; [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;f&amp;quot;, &amp;quot;g&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;j&amp;quot;, &amp;quot;k&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;n&amp;quot;, &amp;quot;o&amp;quot;, &amp;quot;p&amp;quot;, &amp;quot;q&amp;quot;, &amp;quot;r&amp;quot;, &amp;quot;s&amp;quot;, &amp;quot;t&amp;quot;, &amp;quot;u&amp;quot;, &amp;quot;v&amp;quot;, &amp;quot;w&amp;quot;, &amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;z&amp;quot;]
```&lt;/p&gt;

&lt;p&gt;또한 ruby 2.0에선 chars 메소드를 사용한 후에 별도로 to_a를 호출해주지 않아도 됩니다.&lt;/p&gt;

&lt;p&gt;하지만 문자열을 여러개의 문자를 기준으로 분리할 때는 &lt;code&gt;String#scan&lt;/code&gt;이 편리합니다.&lt;/p&gt;

&lt;p&gt;```ruby
 alpha.scan(/.../) # =&amp;gt; [&amp;quot;abc&amp;quot;, &amp;quot;def&amp;quot;, &amp;quot;ghi&amp;quot;, &amp;quot;jkl&amp;quot;, &amp;quot;mno&amp;quot;, &amp;quot;pqr&amp;quot;, &amp;quot;stu&amp;quot;, &amp;quot;vwx&amp;quot;]
 alpha.scan(/.{1,3}/) # =&amp;gt; [&amp;quot;abc&amp;quot;, &amp;quot;def&amp;quot;, &amp;quot;ghi&amp;quot;, &amp;quot;jkl&amp;quot;, &amp;quot;mno&amp;quot;, &amp;quot;pqr&amp;quot;, &amp;quot;stu&amp;quot;, &amp;quot;vwx&amp;quot;, &amp;quot;yz&amp;quot;]&lt;/p&gt;

&lt;p&gt;number = &amp;#39;12345678&amp;#39;
 def number.comma&lt;em&gt;value
   reverse.scan(/.{1,3}/).join(&amp;#39;,&amp;#39;).reverse
 end
 number.comma&lt;/em&gt;value # =&amp;gt; &amp;quot;12,345,678&amp;quot;
```&lt;/p&gt;

&lt;h3&gt;19. Array#*&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Array#*&lt;/code&gt;에 정수를 넘겨주면 배열을 해당하는 수만큼 반복한 배열을 리턴합니다만, 문자열을 넘겨주면 문자열을 조인하고 그 사이에 해당하는 문자열로 연결해줍니다.&lt;/p&gt;

&lt;p&gt;```ruby
 [1, 2, 3] * 3 # =&amp;gt; [1, 2, 3, 1, 2, 3, 1, 2, 3]&lt;/p&gt;

&lt;p&gt;[2009, 1, 10] * &amp;#39;-&amp;#39; # =&amp;gt; &amp;quot;2009-1-10&amp;quot;
```&lt;/p&gt;

&lt;p&gt;그럼 이 지식을 활용해 다음 예제에서 x의 출력을 맞춰보세요!&lt;/p&gt;

&lt;p&gt;```ruby
*a, b, c = %w(1 2 3 4 5)&lt;/p&gt;

&lt;p&gt;x = a * b + c&lt;/p&gt;

&lt;p&gt;puts x
```&lt;/p&gt;

&lt;h3&gt;20. Array#uniq&lt;/h3&gt;

&lt;p&gt;배열에서 중복된 값들을 제외할 때 &lt;code&gt;Array#uniq&lt;/code&gt; 메소드를 사용하곤합니다. 이 때 uniq 메소드에 블록을 넘겨 조건을 지정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
 Designer = Struct.new(:name, :lang)
 data = {&amp;#39;matz&amp;#39; =&amp;gt; :ruby, &amp;#39;kay&amp;#39; =&amp;gt; :smalltalk, &amp;#39;gosling&amp;#39; =&amp;gt; :java, &amp;#39;dhh&amp;#39; =&amp;gt; :ruby}
 designers = data.to_a.map { |name, lang| Designer[name, lang] }&lt;/p&gt;

&lt;p&gt;designers # =&amp;gt; [#&lt;struct Designer name="matz", lang=:ruby&gt;, #&lt;struct Designer name="kay", lang=:smalltalk&gt;, #&lt;struct Designer name="gosling", lang=:java&gt;, #&lt;struct Designer name="dhh", lang=:ruby&gt;]&lt;/p&gt;

&lt;p&gt;designers.uniq.map(&amp;amp;:name) # =&amp;gt; [&amp;quot;matz&amp;quot;, &amp;quot;kay&amp;quot;, &amp;quot;gosling&amp;quot;, &amp;quot;dhh&amp;quot;]
 designers.uniq{ |d| d.lang }.map(&amp;amp;:name) # =&amp;gt; [&amp;quot;matz&amp;quot;, &amp;quot;kay&amp;quot;, &amp;quot;gosling&amp;quot;]
```&lt;/p&gt;

&lt;p&gt;아, 그렇죠. No 19의 정답은 &amp;quot;142435&amp;quot;입니다.&lt;/p&gt;

&lt;h3&gt;21. 모든 배열 요소의 동일 여부 확인&lt;/h3&gt;

&lt;p&gt;배열의 모든 요소가 같은지 확인할 때 Array#uniq 메소드를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1].uniq.size==1 # =&amp;gt; true
[1, 1, 1, 1, 1, 1, 1, 2, 1, 1].uniq.size==1 # =&amp;gt; false
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;조건을 지정하고 싶을 땐 uniq에 블록을 넘겨주는 방법이 좋습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
%w(street retest setter tester).uniq { |w| w.chars.sort }.size==1 # =&amp;gt; true
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;22. 문자열 리스트 %w&lt;/h3&gt;

&lt;p&gt;문자열 리스트를 만들 때 %w를 사용하면 편리합니다. 이 때 공백 문자를 포함하고 싶으면 백슬래시로 이스케이프 해줄 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
 designers = %w(John\ McCarthy Yukihiro\ Matsumoto Larry\ Wall Alan\ Kay Martin\ Odersky)
 designers # =&amp;gt; [&amp;quot;John McCarthy&amp;quot;, &amp;quot;Yukihiro Matsumoto&amp;quot;, &amp;quot;Larry Wall&amp;quot;, &amp;quot;Alan Kay&amp;quot;, &amp;quot;Martin Odersky&amp;quot;]
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;23. 동적 상속&lt;/h3&gt;

&lt;p&gt;Ruby 클래스의 상속은 &lt;code&gt;&amp;lt;&lt;/code&gt; 기호를 사용하는데 이때 우변에 클래스 상수나 클래스를 리턴하는 식을 지정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
 class Male
  def laugh
    &amp;#39;Ha ha ha!&amp;#39;
  end
 end&lt;/p&gt;

&lt;p&gt;class Female
  def laugh
    &amp;#39;Fu fu fu..&amp;#39;
  end
 end&lt;/p&gt;

&lt;p&gt;class Me &amp;lt; [Male, Female][rand 2]
 end&lt;/p&gt;

&lt;p&gt;Me.superclass # =&amp;gt; Female
 Me.new.laugh # =&amp;gt; &amp;#39;Fu fu fu..&amp;#39;
```&lt;/p&gt;

&lt;p&gt;환경에 따라 IO를 바꾸는 예제입니다.&lt;/p&gt;

&lt;p&gt;```ruby
 def io(env=:development)
   env==:test ?StringIO : IO
 end&lt;/p&gt;

&lt;p&gt;env = :test&lt;/p&gt;

&lt;p&gt;class MyIO &amp;lt; io(env)
 end&lt;/p&gt;

&lt;p&gt;MyIO.superclass #=&amp;gt; StringIO
```&lt;/p&gt;

&lt;p&gt;즉 Ruby에서는 조건에 따라 상속하려는 클래스를 동적으로 바꿀 수 있습니다.&lt;/p&gt;

&lt;h3&gt;24. 대문자 메소드&lt;/h3&gt;

&lt;p&gt;Ruby는 메소드 이름으로 영어 소문자를 사용하는데 영어 대문자도 사용할
수 있습니다. 대문자 메소드는 상수처럼 보이기도 합니다.&lt;/p&gt;

&lt;p&gt;```ruby
 class Google
   def URL
     &amp;#39;www.google.com&amp;#39;
   end
   private :URL&lt;/p&gt;

&lt;p&gt;def search(word)
     get( URL(), word)
   end
 end
```&lt;/p&gt;

&lt;p&gt;상수는 속상된 서브 클래스에서도 참조 가능하지만 이를 비공개로 하고
싶을 때는 어떨까요. 바로 이럴 때 대문자 메소드를 이용해보는 겁니다.&lt;/p&gt;

&lt;p&gt;인수가 없을 때도 괄호가 생략 불가능한 단점은 있지만, 관련된 복잡한 상수를 정의할 때도 편리하게 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
 class Google
   def search(word, code=:us)
     get( URL(code), word )
   end&lt;/p&gt;

&lt;p&gt;def URL(code)
     { us: &amp;#39;www.google.com&amp;#39;,
       ja: &amp;#39;www.google.co.jp&amp;#39; }[code]
   end
   private :URL
```&lt;/p&gt;

&lt;p&gt;「상수 메소드」라는 이름은 어떨까요.&lt;/p&gt;

&lt;h3&gt;25. 함수 부분 적용&lt;/h3&gt;

&lt;p&gt;비슷한 메소드를 여러번 만드는 건 DRY 원칙에 위배됩니다.&lt;code&gt;Proc#curry&lt;/code&gt;를
사용하면 이러한 문제를 피할 수 있습니다. 계절 판정 예제입니다.&lt;/p&gt;

&lt;p&gt;```ruby
 require &amp;quot;date&amp;quot;&lt;/p&gt;

&lt;p&gt;season = -&amp;gt;range,date{ range.include?Date.parse(date).mon }.curry&lt;/p&gt;

&lt;p&gt;is&lt;em&gt;spring = season[4..6]
 is&lt;/em&gt;summer = season[7..9]
 is&lt;em&gt;autumn = season[10..12]
 is&lt;/em&gt;winter = season[1..3]&lt;/p&gt;

&lt;p&gt;is&lt;em&gt;autumn[&amp;#39;11/23&amp;#39;] # =&amp;gt; true
 is&lt;/em&gt;summer[&amp;#39;1/1&amp;#39;] # =&amp;gt; false
```&lt;/p&gt;

&lt;p&gt;이럴 때 변수명에 &lt;code&gt;?&lt;/code&gt;를 사용할 수 있으면 좋겠다는 생각을 해봅니다.&lt;/p&gt;

&lt;h3&gt;26. Proc에 의한 case 조건&lt;/h3&gt;

&lt;p&gt;Proc은 call 메소드를 사용해 실행할 수 있는데 이 메소드는
&lt;code&gt;Proc#===&lt;/code&gt;라는 다른 이름을 가지고 있습니다. 앞선 계절 판정 함수를 case
식으로 작성하면 아래와 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
 for date in %w(2/4 11/23 6/14 8/3)
   act = 
     case date
     when is_spring; &amp;#39;Wake up!&amp;#39;
     when is_summer; &amp;#39;Cool down!&amp;#39;
     when is_autumn; &amp;#39;Read!&amp;#39;
     when is_winter; &amp;#39;Sleep!&amp;#39;
     end
   puts &amp;quot;#{date} =&amp;gt; #{act}&amp;quot;
 end
 # &amp;gt;&amp;gt; 2/4 =&amp;gt; Sleep! # &amp;gt;&amp;gt; 11/23 =&amp;gt; Read! # &amp;gt;&amp;gt; 6/14 =&amp;gt; Wake up! # &amp;gt;&amp;gt; 8/3 =&amp;gt; Cool down!
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;인수가 넘어가는 게 암묵적으로 이루어져서 case 식이 깔끔하게 느껴집니다.&lt;/p&gt;

&lt;h3&gt;27. Struct 클래스&lt;/h3&gt;

&lt;p&gt;속성만 있는 클래스를 생성할 때는 &lt;code&gt;Struct&lt;/code&gt;가 편리합니다.&lt;/p&gt;

&lt;p&gt;```ruby
 module Fortune
   class Teller
     require &amp;quot;date&amp;quot;
     def self.ask(name, age, occupation)
       Date.today.next_day(rand 10)
     end
   end
 end&lt;/p&gt;

&lt;p&gt;class Person &amp;lt; Struct.new(:name, :age, :occupation)
   def length&lt;em&gt;of&lt;/em&gt;life(date)
     (Fortune::Teller.ask(name, age, occupation) - Date.parse(date)).to_i
   end
 end&lt;/p&gt;

&lt;p&gt;charlie = Person.new(&amp;#39;charlie&amp;#39;, 13, :programmer)
 charlie.length&lt;em&gt;of&lt;/em&gt;life(&amp;#39;2013/3/1&amp;#39;) # =&amp;gt; 6
```&lt;/p&gt;

&lt;p&gt;Struct.new는 블록을 받을 수 있어 아래와 같이 사용할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
 Person = Struct.new(:name, :age, :occupation) do
   def length&lt;em&gt;of&lt;/em&gt;life(date)
     (Fortune::Teller.ask(name, age, occupation) - Date.parse(date)).to_i
   end
 end&lt;/p&gt;

&lt;p&gt;charlie = Person.new(&amp;#39;charlie&amp;#39;, 13, :programmer)
 charlie.length&lt;em&gt;of&lt;/em&gt;life(&amp;#39;2013/3/1&amp;#39;) # =&amp;gt; 3
```&lt;/p&gt;

&lt;h3&gt;28. Struct의 기본 값&lt;/h3&gt;

&lt;p&gt;한 번 더 Struct 이야기입니다. 이번엔 Beverage 객체를 만들어 보겠습니다.&lt;/p&gt;

&lt;p&gt;```ruby
class Beverage &amp;lt; Struct.new(:name, :cost)
end&lt;/p&gt;

&lt;h1&gt;혹은 Beverage = Struct.new(:name, :cost)&lt;/h1&gt;

&lt;p&gt;starbucks = Beverage.new(:staba, 430) # =&amp;gt; #&lt;struct Beverage name=:staba, cost=430&gt;
heineken = Beverage.new(:heineken, 580) # =&amp;gt; #&lt;struct Beverage name=:heineken, cost=580&gt;
```&lt;/p&gt;

&lt;p&gt;여기서 &lt;code&gt;new&lt;/code&gt;에 인수를 넘기지 않으면 속성값에는 nil이 지정됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
Beverage.new # =&amp;gt; #&amp;lt;struct Beverage name=nil, cost=nil&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;가능하면 클래스와 마찬가지로 기본 값을 설정하고 싶죠. 그럴 땐 이렇게 합니다.&lt;/p&gt;

&lt;p&gt;```ruby
class Beverage &amp;lt; Struct.new(:name, :cost)
  def initialize(name=:water, cost=0)
    super(name, cost)
  end
end&lt;/p&gt;

&lt;p&gt;starbucks = Beverage.new(:staba, 430) # =&amp;gt; #&lt;struct Beverage name=:staba, cost=430&gt;
heineken = Beverage.new(:heineken, 580) # =&amp;gt; #&lt;struct Beverage name=:heineken, cost=580&gt;&lt;/p&gt;

&lt;p&gt;water = Beverage.new # =&amp;gt; #&lt;struct Beverage name=:water, cost=0&gt;
```&lt;/p&gt;

&lt;h3&gt;29. retry와 인수 기본값&lt;/h3&gt;

&lt;p&gt;rescue를 사용할 때는 &lt;code&gt;retry&lt;/code&gt;를 사용해서 메소드를 재실행할 수 있습니다.
이를 메소드 인수의 기본 값과 연관지어 편리하게 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
 require &amp;quot;date&amp;quot;
 def last_date(date, last=[28,29,30,31])
   d = Date.parse date
   Date.new(d.year, d.mon, last.pop).day rescue retry
 end&lt;/p&gt;

&lt;p&gt;last&lt;em&gt;date &amp;#39;2013/6/1&amp;#39; # =&amp;gt; 30
 last&lt;/em&gt;date &amp;#39;2012/2/20&amp;#39; # =&amp;gt; 29
 last_date &amp;#39;2013/2&amp;#39; # =&amp;gt; 28
```&lt;/p&gt;

&lt;p&gt;이 예제에서는 31일부터 Date 객체를 생성해 예외가 발생하면 retry를 통해 전 날의 Date객체 생성을 시도합니다.&lt;/p&gt;

&lt;p&gt;사실 마지막 날이 알고 싶은 거면 아래 코드면 충분합니다만...&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
 Date.new(2013,2,-1).day # =&amp;gt; 28
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;30. Array#zip&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Array#zip&lt;/code&gt;을 알고계시나요?여러개의 배열을 한 줄 한 줄 늘여놓고 열단위로 묶어주는 메소드입니다.&lt;/p&gt;

&lt;p&gt;```ruby
[1, 2, 3].zip([4, 5, 6], [7, 8, 9]) # =&amp;gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]&lt;/p&gt;

&lt;p&gt;[:A, :B, :C].zip([:E, :F, :G], [:H, :I, :J]) # =&amp;gt; [[:A, :E, :H], [:B, :F, :I], [:C, :G, :J]]
```&lt;/p&gt;

&lt;p&gt;zip은 일반적으로 하나나 그보다 많은 배열들을 인수로 받는데 값이 연속되는 경우엔 Range를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
[1, 2, 3].zip(4..6, 7..9) # =&amp;gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]&lt;/p&gt;

&lt;p&gt;[:A, :B, :C].zip(:E..:G, :H..:J) # =&amp;gt; [[:A, :E, :H], [:B, :F, :I], [:C, :G, :J]]
```&lt;/p&gt;

&lt;p&gt;또한 zip은 블록을 넘겨받을 수 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
[1, 2, 3].zip(4..6, 7..9) { |xyz| puts xyz.inject(:+) } # =&amp;gt; nil&lt;/p&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 12&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 15&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 18&lt;/h1&gt;

&lt;p&gt;[:A, :B, :C].zip(:E..:G, :H..:J) { |xyz| puts xyz.join } # =&amp;gt; nil&lt;/p&gt;

&lt;h1&gt;&amp;gt;&amp;gt; AEH&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; BFI&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; CGJ&lt;/h1&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;단 리턴값은 nil이므로 블록에서 처리하는 방법으로밖에 사용할 수 없습니다.&lt;/p&gt;

&lt;h3&gt;31. Enumerable#zip&lt;/h3&gt;

&lt;p&gt;zip 메소드는 Enumerable 클래스에도 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
(1..3).zip(4..6, 7..9) # =&amp;gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]&lt;/p&gt;

&lt;p&gt;(:A..:C).zip(:E..:G, :H..:J) # =&amp;gt; [[:A, :E, :H], [:B, :F, :I], [:C, :G, :J]]
```&lt;/p&gt;

&lt;p&gt;Struct도 Enumerable 객체이므로 아래와 같은 것도 가능합니다.&lt;/p&gt;

&lt;p&gt;```ruby
water = Beverage.new  # =&amp;gt; #&lt;struct Beverage name=:water, cost=0&gt;
starbucks = Beverage.new(:staba, 430) # =&amp;gt; #&lt;struct Beverage name=:staba, cost=430&gt;
heineken = Beverage.new(:heineken, 580) # =&amp;gt; #&lt;struct Beverage name=:heineken, cost=580&gt;&lt;/p&gt;

&lt;p&gt;water.zip(starbucks, heineken) # =&amp;gt; [[:water, :staba, :heineken], [0, 430, 580]]
```&lt;/p&gt;

&lt;h3&gt;32. ARGF&lt;/h3&gt;

&lt;p&gt;ARFG는 훌륭합니다. 이는 커맨드 라인 인수를 파일명으로 받아들여 지정된
파일 객체를 가져옵니다. 그런데 이 객체의 클래스가 뭔지 알고계시나요? 이를 확인하려면 class 메소드를 보내보면 되겠죠.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
ARGF.class # =&amp;gt; ARGF.class
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;네. 정답은 &lt;code&gt;ARFG.class&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p&gt;그럼 new 하면 ARGF가 만들어질까요.&lt;/p&gt;

&lt;p&gt;```ruby
ARGF.class # =&amp;gt; ARGF.class
MYARGF = ARGF.class.new  # =&amp;gt; ARGF
MYARGF.class # =&amp;gt; ARGF.class&lt;/p&gt;

&lt;p&gt;puts MYARGF.filename
```&lt;/p&gt;

&lt;p&gt;만들어집니다! 하지만 제대로 작동하지 않습니다.&lt;/p&gt;

&lt;p&gt;```sh&lt;/p&gt;

&lt;h2&gt;% ruby argf_test.rb abc.txt&lt;/h2&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;칫!&lt;/p&gt;

&lt;h3&gt;33. Object#tap&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;tap&lt;/code&gt;은 이 블록의 평가 결과를 버리는 희안한 메소드인데 그 결과가
필요할 때가 있습니다. 그럴 땐 break를 사용하면 됩니다. (thanks to knu 님).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
average = [56, 87, 49, 75, 90, 63, 65].tap { |sco| break sco.inject(:+) / sco.size } # =&amp;gt; 69
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;컵라면을 좋아하는 당신께 아래의 코드를 헌정합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
puts &amp;quot;Eat!&amp;quot;.tap { sleep 180 } # 3분 후에 &amp;#39;Eat!&amp;#39;
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;34. 사용하지 않는 변수&lt;/h3&gt;

&lt;p&gt;배열 데이터를 그냥 버리고 싶을 때가 있죠.&lt;/p&gt;

&lt;p&gt;```ruby
header, *data = DATA.each_line.map { |line| line.chomp.split }
header # =&amp;gt; [&amp;quot;name&amp;quot;, &amp;quot;age&amp;quot;, &amp;quot;job&amp;quot;]
data # =&amp;gt; [[&amp;quot;charlie&amp;quot;, &amp;quot;12&amp;quot;, &amp;quot;:programmer&amp;quot;], [&amp;quot;tommy&amp;quot;, &amp;quot;17&amp;quot;, &amp;quot;:student&amp;quot;], [&amp;quot;nick&amp;quot;, &amp;quot;27&amp;quot;, &amp;quot;:doctor&amp;quot;]]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;END&lt;/strong&gt;
name age job
charlie 12 :programmer
tommy 17 :student
nick 27 :doctor
```&lt;/p&gt;

&lt;p&gt;그런데 여기서 &lt;code&gt;header&lt;/code&gt; 변수를 사용하지 않으면 경고가 나옵니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
header, *data = DATA.each_line.map { |line| line.chomp.split } # !&amp;gt; assigned but unused variable - header
data # =&amp;gt; [[&amp;quot;charlie&amp;quot;, &amp;quot;12&amp;quot;, &amp;quot;:programmer&amp;quot;], [&amp;quot;tommy&amp;quot;, &amp;quot;17&amp;quot;, &amp;quot;:student&amp;quot;], [&amp;quot;nick&amp;quot;, &amp;quot;27&amp;quot;, &amp;quot;:doctor&amp;quot;]]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이를 피하기 위해 변수명을 &lt;code&gt;_&lt;/code&gt;(밑줄)로 지정합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
_, *data = DATA.each_line.map { |line| line.chomp.split }
data # =&amp;gt; [[&amp;quot;charlie&amp;quot;, &amp;quot;12&amp;quot;, &amp;quot;:programmer&amp;quot;], [&amp;quot;tommy&amp;quot;, &amp;quot;17&amp;quot;, &amp;quot;:student&amp;quot;], [&amp;quot;nick&amp;quot;, &amp;quot;27&amp;quot;, &amp;quot;:doctor&amp;quot;]]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;만약 이미 2.0을 사용하고 계시다면 변수 이름 앞에 &lt;code&gt;_&lt;/code&gt;를 붙여주기만 하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
_header, *data = DATA.each_line.map { |line| line.chomp.split }
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;35. 파일 뽑아내기&lt;/h3&gt;

&lt;p&gt;여러 파일이 있을 때 특정한 조건에 맞는 딱 하나의 파일을 찾아내 다른
변수에 저장하고 싶다고 해보죠. &lt;code&gt;Array#delete&lt;/code&gt; 메소드를 사용하면 될 것 같은데, 실제론 어떨까요.&lt;/p&gt;

&lt;p&gt;```ruby
files = [&amp;#39;Gemfile&amp;#39;, &amp;#39;LICENSE.txt&amp;#39;, &amp;#39;README.md&amp;#39;, &amp;#39;Rakefile&amp;#39;, &amp;#39;bin&amp;#39;, &amp;#39;lib&amp;#39;, &amp;#39;maliq.gemspec&amp;#39;, &amp;#39;pkg&amp;#39;, &amp;#39;spec&amp;#39;]&lt;/p&gt;

&lt;p&gt;gemspec = files.delete(/.gemspec$/)
gemspec # =&amp;gt; nil
files # =&amp;gt; [&amp;quot;Gemfile&amp;quot;, &amp;quot;LICENSE.txt&amp;quot;, &amp;quot;README.md&amp;quot;, &amp;quot;Rakefile&amp;quot;, &amp;quot;bin&amp;quot;, &amp;quot;lib&amp;quot;, &amp;quot;maliq.gemspec&amp;quot;, &amp;quot;pkg&amp;quot;, &amp;quot;spec&amp;quot;]
```&lt;/p&gt;

&lt;p&gt;안타깝지만 생각처럼 되지 않습니다. 이는 Array#delete가 &lt;code&gt;==&lt;/code&gt;으로 동일 여부를 판단하기 때문입니다.&lt;/p&gt;

&lt;p&gt;그렇다면 &lt;code&gt;Array#partition&lt;/code&gt;과 다중 대입을 사용해보죠.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
gemspec, files = files.partition { |f| f.match(/\.gemspec$/) }
gemspec # =&amp;gt; [&amp;quot;maliq.gemspec&amp;quot;]
files  # =&amp;gt; [&amp;quot;Gemfile&amp;quot;, &amp;quot;LICENSE.txt&amp;quot;, &amp;quot;README.md&amp;quot;, &amp;quot;Rakefile&amp;quot;, &amp;quot;bin&amp;quot;, &amp;quot;lib&amp;quot;, &amp;quot;pkg&amp;quot;, &amp;quot;spec&amp;quot;]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;다 된 것 같긴 한데 gemspec 파일을 배열로 돌려주는 게 조금 아쉽네요. 하지만 다중 대입 + 괄호를 사용하면 해결할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
(gemspec, *_), files = files.partition { |f| f.match(/\.gemspec$/) }
gemspec # =&amp;gt; &amp;quot;maliq.gemspec&amp;quot;
files # =&amp;gt; [&amp;quot;Gemfile&amp;quot;, &amp;quot;LICENSE.txt&amp;quot;, &amp;quot;README.md&amp;quot;, &amp;quot;Rakefile&amp;quot;, &amp;quot;bin&amp;quot;, &amp;quot;lib&amp;quot;, &amp;quot;pkg&amp;quot;, &amp;quot;spec&amp;quot;]
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;36. Symbol에 주석 사용하기&lt;/h3&gt;

&lt;p&gt;심볼에도 주석을 달고 싶다고 생각해보신 적은 없나요? 그렇다면 이렇게 해보세요.&lt;/p&gt;

&lt;p&gt;```ruby
sym = :#this symbol is nice
hello&lt;/p&gt;

&lt;p&gt;sym # =&amp;gt; :hello
```&lt;/p&gt;

&lt;p&gt;대체 이걸 어디에 쓰시려고...&lt;/p&gt;

&lt;h3&gt;37. Kernel#loop&lt;/h3&gt;

&lt;p&gt;끝없이 반복하고 싶은 경우엔 &lt;code&gt;Kernel#loop&lt;/code&gt;에 블록을 넘겨주면 됩니다.&lt;/p&gt;

&lt;p&gt;```ruby
 require &amp;quot;prime&amp;quot;&lt;/p&gt;

&lt;p&gt;prime = Prime.each&lt;/p&gt;

&lt;p&gt;n = 0
 loop do
   printf &amp;quot;%d &amp;quot; % prime.next
   break if n &amp;gt; 10
   n += 1
 end
 # &amp;gt;&amp;gt; 2 3 5 7 11 13 17 19 23 29 31 37 
```&lt;/p&gt;

&lt;p&gt;여기선 loop에 블록을 넘기지 않으면 Enumerator가 리턴됩니다. 이를
이용하면 loop에 인덱스를 추가할 수 있습니다.( thanks to @no6v 님)&lt;/p&gt;

&lt;p&gt;```ruby
 loop # =&amp;gt; #&lt;Enumerator: main:loop&gt;&lt;/p&gt;

&lt;p&gt;loop.with&lt;em&gt;index do |&lt;/em&gt;,n|
   printf &amp;quot;%d &amp;quot; % prime.next
   break if n &amp;gt; 10
 end
 # &amp;gt;&amp;gt; 2 3 5 7 11 13 17 19 23 29 31 37 
```&lt;/p&gt;

&lt;p&gt;블록의 첫번째 인수가 nil이 되어버립니다만.&lt;/p&gt;

&lt;h3&gt;38. BasicObject#instance_eval&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;instance_eval&lt;/code&gt;은 객체 생성을 DSL처럼 할 때 자주 사용됩니다.&lt;/p&gt;

&lt;p&gt;```ruby
class Person
  def initialize(&amp;amp;blk)
    instance_eval(&amp;amp;blk)
  end
  def name(name)
    @name = name
  end
  def age(age)
    @age = age
  end
  def job(job)
    @job = job
  end
  def profile
    [@name, @age, @job] * &amp;#39;-&amp;#39;
  end
end&lt;/p&gt;

&lt;p&gt;t = Person.new do
  name &amp;#39;Charlie&amp;#39;
  age  13
  job  :programmer
end&lt;/p&gt;

&lt;p&gt;t.profile # =&amp;gt; &amp;quot;Charlie-13-programmer&amp;quot;
```&lt;/p&gt;

&lt;p&gt;하지만 이러한 콘텍스트를 일시적으로 바꾸는 방법은 DSL이 아니라도
편리하게 사용할 수 있습니다. 테스트 결과의 평균값을 구해보죠. 우선은 일반적인 방법으로.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
scores = [56, 87, 49, 75, 90, 63, 65]
scores.inject(:+) / scores.size # =&amp;gt; 69
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;짧은 코드인데 scores 변수가 3번이나 나옵니다.&lt;/p&gt;

&lt;p&gt;instance_eval을 사용하면 score를 사용하지 않을 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
[56, 87, 49, 75, 90, 63, 65].instance_eval { inject(:+) / size } # =&amp;gt; 69
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;다음으로 표준편차 sd를 구해보죠. 우선은 일반적인 방법으로&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
scores = [56, 87, 49, 75, 90, 63, 65]
avg = scores.inject(:+) / scores.size
sigmas = scores.map { |n| (avg - n)**2 }
sd = Math.sqrt(sigmas.inject(:+) / scores.size) # =&amp;gt; 14.247806848775006
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;instance&lt;em&gt;eval로.
```ruby
scores = [56, 87, 49, 75, 90, 63, 65]
sd = scores.instance&lt;/em&gt;eval do
  avg = inject(:+) / size
  sigmas = map { |n| (avg - n)**2 }
  Math.sqrt(sigmas.inject(:+) / size)
end
sd # =&amp;gt; 14.247806848775006
```&lt;/p&gt;

&lt;p&gt;비슷한 변수를 블록 안에 집어넣는 것은 물론 블록에서 식이 정리되니 더 보기 좋지 않나요?&lt;/p&gt;

&lt;h3&gt;39. 정규 표현식 : 이름 있는 참조&lt;/h3&gt;

&lt;p&gt;정규 표현식 안에서 &lt;code&gt;()&lt;/code&gt;를 부분 매치에 사용할 수 있습니다. 더욱이 이 매치에 이름을 붙이고 싶으면 &lt;code&gt;?\&amp;lt;pattern\&amp;gt;&lt;/code&gt;을 사용하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
langs = &amp;quot;python lisp ruby haskell erlang scala&amp;quot;
m = langs.match(/(?&amp;lt;lang&amp;gt;\w+)/) # =&amp;gt; #&amp;lt;MatchData &amp;quot;python&amp;quot; lang:&amp;quot;python&amp;quot;&amp;gt;
m[&amp;#39;lang&amp;#39;] # =&amp;gt; &amp;quot;python&amp;quot;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;그리고 정규표현 리터럴을 좌변에 사용하면 이를 지역 변수처럼 사용할 수
있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
langs = &amp;quot;python lisp ruby haskell erlang scala&amp;quot;
if /(?&lt;most_fun_lang&gt;r\w+)/ =~ langs
  printf &amp;quot;you should learn %s!&amp;quot;, most&lt;em&gt;fun&lt;/em&gt;lang
end&lt;/p&gt;

&lt;h1&gt;&amp;gt;&amp;gt; you should learn ruby!&lt;/h1&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h3&gt;40. 정규표현:POSIX 문자 클래스&lt;/h3&gt;

&lt;p&gt;Ruby 1.9에서 &lt;code&gt;\w&lt;/code&gt;는 일본어에 매치하지 않습니다.1.9에서 일본어에도 매치시키기 위해서는 POSIX 문자 클래스 &lt;code&gt;word&lt;/code&gt;를 사용하는 방법이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
need_japanese = &amp;quot;this-日本語*is*_really_/\\変わってる!&amp;quot;
need_japanese.scan(/\w+/) # =&amp;gt; [&amp;quot;this&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;_really_&amp;quot;]
need_japanese.scan(/[[:word:]]+/) # =&amp;gt; [&amp;quot;this&amp;quot;, &amp;quot;日本語&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;_really_&amp;quot;, &amp;quot;変わってる&amp;quot;]
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;41. String#match&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;String#match&lt;/code&gt;는 MatchData 객체를 리턴하므로 다음과 같이 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
date = &amp;quot;2012february14&amp;quot;
m = date.match(/\D+/)
mon, day, year = m.to_s.capitalize, m.post_match, m.pre_match
&amp;quot;#{mon} #{day}, #{year}&amp;quot; # =&amp;gt; &amp;quot;February 14, 2012&amp;quot;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;하지만 match는 블록을 받으므로 다음과 같이 사용해도 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
date = &amp;quot;2012february14&amp;quot;
mon, day, year = date.match(/\D+/) { |m| [m.to_s.capitalize, m.post_match, m.pre_match] }
&amp;quot;#{mon} #{day}, #{year}&amp;quot; # =&amp;gt; &amp;quot;February 14, 2012&amp;quot;
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;42. String#unpack&lt;/h3&gt;

&lt;p&gt;문자열을 정해진 길이를 기준으로 나누고 싶을 땐 어떻게 하는 게
좋을까요? 먼저 정규표현식을 사용해보죠.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
a_day = &amp;#39;20120214&amp;#39;
a_day.match(/(.{4})(.{2})(.{2})/).captures # =&amp;gt; [&amp;quot;2012&amp;quot;, &amp;quot;02&amp;quot;, &amp;quot;14&amp;quot;]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;String#unpack&lt;/code&gt;를 사용하면 좀 더 간단히 해결할 수 있습니다. (thanks to @no6v 님)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
a_day = &amp;#39;20120214&amp;#39;
a_day.unpack(&amp;#39;A4A2A2&amp;#39;) # =&amp;gt; [&amp;quot;2012&amp;quot;, &amp;quot;02&amp;quot;, &amp;quot;14&amp;quot;]
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;43. Enumerable#each&lt;em&gt;with&lt;/em&gt;object&lt;/h3&gt;

&lt;p&gt;Enumerable#map 메소드를 활용하는 방법으로 블록 대신에 &lt;code&gt;&amp;amp;&lt;/code&gt;에 심볼을 붙이는 기술이 알려져 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
langs = [&amp;quot;ruby&amp;quot;, &amp;quot;python&amp;quot;, &amp;quot;lisp&amp;quot;, &amp;quot;haskell&amp;quot;]
langs.map(&amp;amp;:capitalize) # =&amp;gt; [&amp;quot;Ruby&amp;quot;, &amp;quot;Python&amp;quot;, &amp;quot;Lisp&amp;quot;, &amp;quot;Haskell&amp;quot;]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;하지만 이 기술은 인수를 받는 메소드는 사용할 수 없다는 문제가 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
langs = [&amp;quot;ruby&amp;quot;, &amp;quot;python&amp;quot;, &amp;quot;lisp&amp;quot;, &amp;quot;haskell&amp;quot;]
langs.map(:+, &amp;#39;ist&amp;#39;) # =&amp;gt; &lt;/p&gt;

&lt;h1&gt;~&amp;gt; -:2:in `map&amp;#39;: wrong number of arguments (2 for 0) (ArgumentError)&lt;/h1&gt;

&lt;h1&gt;~&amp;gt;    from -:2:in `&lt;main&gt;&amp;#39;&lt;/h1&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;이럴 땐 &lt;code&gt;each_with_object&lt;/code&gt; 메소드를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
langs = [&amp;quot;ruby&amp;quot;, &amp;quot;python&amp;quot;, &amp;quot;lisp&amp;quot;, &amp;quot;haskell&amp;quot;]&lt;/p&gt;

&lt;p&gt;langs.each&lt;em&gt;with&lt;/em&gt;object(&amp;#39;ist&amp;#39;).map(&amp;amp;:+) # =&amp;gt; [&amp;quot;rubyist&amp;quot;, &amp;quot;pythonist&amp;quot;, &amp;quot;lispist&amp;quot;, &amp;quot;haskellist&amp;quot;]&lt;/p&gt;

&lt;p&gt;[1, 2, 3].each&lt;em&gt;with&lt;/em&gt;object(10).map(&amp;amp;:+) # =&amp;gt; &lt;a href="1..5"&gt;11, 12, 13&lt;/a&gt;.each&lt;em&gt;with&lt;/em&gt;object(2).map(&amp;amp;:**) # =&amp;gt; [1, 4, 9, 16, 25]
```&lt;/p&gt;

&lt;p&gt;이름이 조금 길죠. 그것보다 네. 그냥 map에 블록을 넘기세요.&lt;/p&gt;

&lt;p&gt;그리고 이런 방법도 있습니다. (thanks to @tmaeda 님)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
[1, 2, 3].map(&amp;amp;10.method(:+)) # =&amp;gt; [11, 12, 13]
&lt;/code&gt;
리시버와 인수가 역전되므로 용도는 한정적입니다만.&lt;/p&gt;

&lt;h3&gt;44. Float::INFINITY&lt;/h3&gt;

&lt;p&gt;임의의 수열을 만들고자 할 때 하지만 크기가 미리 정해지지 않는 경우가
있습니다. 일단은 &lt;code&gt;Enumerator&lt;/code&gt;로 시도해보죠.&lt;/p&gt;

&lt;p&gt;```ruby
sequence = Enumerator.new { |y| i=1; loop { y &amp;lt;&amp;lt; i; i+=1 } }&lt;/p&gt;

&lt;p&gt;sequence.take(10) # =&amp;gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
100.times.map { sequence.next } # =&amp;gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
```&lt;/p&gt;

&lt;p&gt;단 &lt;code&gt;Enumerator&lt;/code&gt;를 사용하지 않아도 비슷한 작업을 할 수 있는데, 이 때 무한을 의미하는 상수 &lt;code&gt;Float::INFINITY&lt;/code&gt;를 사용합니다.&lt;/p&gt;

&lt;p&gt;```ruby
sequence = 1..Float::INFINITY
sequence.take(10) # =&amp;gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&lt;/p&gt;

&lt;p&gt;seq = sequence.to_enum
100.times.map { seq.next } # =&amp;gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
```&lt;/p&gt;

&lt;p&gt;Infinity는 0으로 나눠서 얻을 수 있으니 아래와 같이 작성할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
(1..1.0/0).take(10) # =&amp;gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&lt;/p&gt;

&lt;p&gt;1.step(1.0/0, 1.5).take(20) # =&amp;gt; [1.0, 2.5, 4.0, 5.5, 7.0, 8.5, 10.0, 11.5, 13.0, 14.5, 16.0, 17.5, 19.0, 20.5, 22.0, 23.5, 25.0, 26.5, 28.0, 29.5]
```&lt;/p&gt;

&lt;h3&gt;45. Enumerable#grep&lt;/h3&gt;

&lt;p&gt;case의 동일성 판단은 &lt;code&gt;===&lt;/code&gt; 메소드를 사용합니다.&lt;/p&gt;

&lt;p&gt;```ruby
temp = 85
status =
  case temp
  when 1..40;   :low
  when 80..100; :Danger
  else :ok
  end
status # =&amp;gt; :Danger&lt;/p&gt;

&lt;p&gt;class Trivia
end
t = Trivia.new&lt;/p&gt;

&lt;p&gt;klass =
  case t
  when String; &amp;#39;no good&amp;#39;
  when Array;  &amp;#39;no no&amp;#39;
  when Trivia; &amp;#39;Yes!Trivia!&amp;#39;
  end
klass # =&amp;gt; &amp;quot;Yes!Trivia!&amp;quot;
```&lt;/p&gt;

&lt;p&gt;예는 &lt;code&gt;Range#===&lt;/code&gt;와 &lt;code&gt;Module#===&lt;/code&gt;를 사용한 동일성 판정입니다.&lt;/p&gt;

&lt;p&gt;사실 &lt;code&gt;Enumerable#grep&lt;/code&gt;에 의한 패턴 매치도 ===로 동일 여부를 판단합니다.&lt;/p&gt;

&lt;p&gt;```ruby
numbers = 5.step(80, 5).to_a # =&amp;gt; [5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80]
numbers.grep(20..50) # =&amp;gt; [20, 25, 30, 35, 40, 45, 50]&lt;/p&gt;

&lt;p&gt;t1, t2, t3, t4, t5 = &amp;#39;trivia&amp;#39;, Trivia.new, [:trivia], {trivia:1}, Trivia.new&lt;/p&gt;

&lt;p&gt;[t1, t2, t3, t4, t5].grep(Trivia) # =&amp;gt; [#&lt;a href="Trivia:0x000001008613b0"&gt;Trivia:0x000001008613b0&lt;/a&gt;, #&lt;a href="Trivia:0x000001008610e0"&gt;Trivia:0x000001008610e0&lt;/a&gt;]
```&lt;/p&gt;

&lt;h3&gt;46. String#gsub&lt;/h3&gt;

&lt;p&gt;문자열에서 나타나는 부분 문자열이 나타나는 회수가 필요한 경우가
있습니다. 보통은 &lt;code&gt;String#scan&lt;/code&gt;을 사용하면 됩니다.&lt;/p&gt;

&lt;p&gt;```ruby
DATA.read.scan(/hello/i).count # =&amp;gt; 48&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;END&lt;/strong&gt;
You say &amp;quot;Yes&amp;quot;, I say &amp;quot;No&amp;quot;.
You say &amp;quot;Stop&amp;quot; and I say &amp;quot;Go, go, go&amp;quot;.
Oh no.
You say &amp;quot;Goodbye&amp;quot; and I say &amp;quot;Hello, hello, hello&amp;quot;.
I don&amp;#39;t know why you say &amp;quot;Goodbye&amp;quot;, I say &amp;quot;Hello, hello, hello&amp;quot;.
I don&amp;#39;t know why you say goodbye, I say hello.
I say &amp;quot;High&amp;quot;, you say &amp;quot;Low&amp;quot;.
You say &amp;quot;Why?&amp;quot; And I say &amp;quot;I don&amp;#39;t know&amp;quot;.
Oh no.
You say &amp;quot;Goodbye&amp;quot; and I say &amp;quot;Hello, hello, hello&amp;quot;.
I don&amp;#39;t know why you say &amp;quot;Goodbye&amp;quot;, I say &amp;quot;Hello, hello, hello&amp;quot;.
(Hello, goodbye, hello, goodbye. Hello, goodbye.)
I don&amp;#39;t know why you say &amp;quot;Goodbye&amp;quot;, I say &amp;quot;Hello&amp;quot;.
(Hello, goodbye, hello, goodbye. Hello, goodbye. Hello, goodbye.)
Why, why, why, why, why, why, do you
Say &amp;quot;Goodbye, goodbye, bye, bye&amp;quot;.
Oh no.
You say &amp;quot;Goodbye&amp;quot; and I say &amp;quot;Hello, hello, hello&amp;quot;.
I don&amp;#39;t know why you say &amp;quot;Goodbye&amp;quot;, I say &amp;quot;Hello, hello, hello&amp;quot;.
I don&amp;#39;t know why you say &amp;quot;Goodbye&amp;quot;, I say &amp;quot;Hello&amp;quot;.
You say &amp;quot;Yes&amp;quot;, I say &amp;quot;No&amp;quot;.
(I say &amp;quot;Yes&amp;quot;, but I may mean &amp;quot;No&amp;quot;).
You say &amp;quot;Stop&amp;quot;, I say &amp;quot;Go, go, go&amp;quot;.
(I can stay still it&amp;#39;s time to go).
Oh, oh no.
You say &amp;quot;Goodbye&amp;quot; and I say &amp;quot;Hello, hello, hello&amp;quot;.
I don&amp;#39;t know why you say &amp;quot;Goodbye&amp;quot;, I say &amp;quot;Hello, hello, hello&amp;quot;.
I don&amp;#39;t know why you say &amp;quot;Goodbye&amp;quot;, I say &amp;quot;Hello, hello, hello&amp;quot;.
I don&amp;#39;t know why you say &amp;quot;Goodbye&amp;quot;, I say &amp;quot;Hello-wow, oh. Hello&amp;quot;.
Hela, heba, helloa. Hela, heba, helloa. Hela, heba, helloa.
Hela, heba, helloa. (Hela.) Hela, heba, helloa. Hela, heba, helloa.
Hela, heba, helloa. Hela, heba, helloa. Hela, heba, helloa.
```
훌륭한 가사네요.&lt;/p&gt;

&lt;p&gt;하지만 &lt;code&gt;String#gsub&lt;/code&gt;는 블록을 넘기지 않으면 Enumerator 객체를 리턴하니 같은 일을 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
DATA.read.gsub(/hello/i).count # =&amp;gt; 48&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;END&lt;/strong&gt;
You say &amp;quot;Yes&amp;quot;, I say &amp;quot;No&amp;quot;.
You say &amp;quot;Stop&amp;quot; and I say &amp;quot;Go, go, go&amp;quot;.
Oh no.
You say &amp;quot;Goodbye&amp;quot; and I say &amp;quot;Hello, hello, hello&amp;quot;.
....
```&lt;/p&gt;

&lt;h3&gt;47. 클래스 메소드 정의&lt;/h3&gt;

&lt;p&gt;클래스나 모듈의 메소드를 정의할 때는 일반적으로 아래와 같이 합니다.&lt;/p&gt;

&lt;p&gt;```ruby
class Calc
  class &amp;lt;&amp;lt; self
    def &amp;gt;&amp;gt;(exp)
      eval exp
    end
  end
end&lt;/p&gt;

&lt;p&gt;Calc &amp;gt;&amp;gt; &amp;#39;1 + 2&amp;#39; # =&amp;gt; 3
Calc &amp;gt;&amp;gt; &amp;#39;10 ** 2&amp;#39; # =&amp;gt; 100
```&lt;/p&gt;

&lt;p&gt;바깥 쪽 클래스의 정의를 &lt;code&gt;Class.new&lt;/code&gt;나 &lt;code&gt;Module.new&lt;/code&gt;을 사용하면 다음과 같이 작성할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
class &amp;lt;&amp;lt; Calc = Class.new
  def &amp;gt;&amp;gt;(exp)
    eval exp
  end
end&lt;/p&gt;

&lt;p&gt;Calc &amp;gt;&amp;gt; &amp;#39;123 / 4.0&amp;#39; # =&amp;gt; 30.75
Calc &amp;gt;&amp;gt; &amp;#39;2 * Math::PI&amp;#39; # =&amp;gt; 6.283185307179586
```&lt;/p&gt;

&lt;p&gt;이 자체는 별 게 없습니다반 &lt;code&gt;Calc.&amp;gt;&amp;gt;&lt;/code&gt;라는 메소드 이름이 irb 스러워서 좋지 않나요?&lt;/p&gt;

&lt;h3&gt;48. true, false, nil&lt;/h3&gt;

&lt;p&gt;Ruby에서 다루는 모든 데이터는 객체라 숫자도 클래스도
그리고 &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt;도 모두 객체라는 건 알고 계시겠죠. 따라서 당연하게도 이러한 객체들은 메소드를 가지고 있고 메소드를 추가할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
def true.true?  &amp;#39;Beleive me. you are true.&amp;#39;
end&lt;/p&gt;

&lt;p&gt;def false.true?  &amp;#39;I said, you are false!&amp;#39;
end&lt;/p&gt;

&lt;p&gt;my&lt;em&gt;point, your&lt;/em&gt;point = 87, 35
border = 60
my&lt;em&gt;result = my&lt;/em&gt;point &amp;gt; border
your&lt;em&gt;result = your&lt;/em&gt;point &amp;gt; border&lt;/p&gt;

&lt;p&gt;my&lt;em&gt;result # =&amp;gt; true
my&lt;/em&gt;result.true?# =&amp;gt; &amp;quot;Beleive me. you are true.&amp;quot;
your&lt;em&gt;result # =&amp;gt; false
your&lt;/em&gt;result.true?# =&amp;gt; &amp;quot;I said, you are false!&amp;quot;
```&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nil&lt;/code&gt;에도 메소드를 정의해보죠.&lt;code&gt;===&lt;/code&gt; 메소드를 정의해서 case에서 사용해보죠.&lt;/p&gt;

&lt;p&gt;```ruby
def nil.===(other)
  other.nil?|| other.empty?end&lt;/p&gt;

&lt;p&gt;def proceed(obj)
  Array(obj).join.split(//).join(&amp;#39;*&amp;#39;)
end&lt;/p&gt;

&lt;p&gt;full = &amp;quot;I&amp;#39;m full.&amp;quot;
empty = &amp;quot;&amp;quot;
&lt;em&gt;nil&lt;/em&gt; = nil&lt;/p&gt;

&lt;p&gt;objects = [full, empty, &lt;em&gt;nil&lt;/em&gt;, %w(I am full), [], {:hello =&amp;gt; &amp;#39;world&amp;#39;}, {}]&lt;/p&gt;

&lt;p&gt;for obj in objects
  case obj
  when nil
    puts &amp;quot;Stop it!&lt;code&gt;#{obj.inspect}&lt;/code&gt; is empty or nil.&amp;quot;
  else
    puts proceed obj
  end
end&lt;/p&gt;

&lt;h1&gt;&amp;gt;&amp;gt; I&lt;em&gt;&amp;#39;&lt;/em&gt;m* &lt;em&gt;f&lt;/em&gt;u&lt;em&gt;l&lt;/em&gt;l*.&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; Stop it!&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; is empty or nil.&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; Stop it!&lt;code&gt;nil&lt;/code&gt; is empty or nil.&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; I&lt;em&gt;a&lt;/em&gt;m&lt;em&gt;f&lt;/em&gt;u&lt;em&gt;l&lt;/em&gt;l&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; Stop it!&lt;code&gt;[]&lt;/code&gt; is empty or nil.&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; h&lt;em&gt;e&lt;/em&gt;l&lt;em&gt;l&lt;/em&gt;o&lt;em&gt;w&lt;/em&gt;o&lt;em&gt;r&lt;/em&gt;l*d&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; Stop it!&lt;code&gt;{}&lt;/code&gt; is empty or nil.&lt;/h1&gt;

&lt;p&gt;```
너무 심취했나요.&lt;/p&gt;

&lt;h3&gt;49. 강제 타입 변환 coerce&lt;/h3&gt;

&lt;p&gt;숫자 리스트에 n배를 곱하면 각각의 요소가 n배가 되는 객체가 필요하다고
해보죠. Array를 상속한 NumList로 이를 구현해보겠습니다.&lt;/p&gt;

&lt;p&gt;```ruby
class NumList &amp;lt; Array
  def *(n)
    map { |e| e * n }
  end
end&lt;/p&gt;

&lt;p&gt;numlist = NumList[1, 2, 3]&lt;/p&gt;

&lt;p&gt;numlist * 3 # =&amp;gt; [3, 6, 9]
```&lt;/p&gt;

&lt;p&gt;욕심을 내서 곱하는 수를 앞에 놓아도 작동하도록 만들어보겠습니다.&lt;/p&gt;

&lt;p&gt;```ruby
3 * numlist # =&amp;gt; &lt;/p&gt;

&lt;h1&gt;~&amp;gt; -:15:in `*&amp;#39;: NumList can&amp;#39;t be coerced into Fixnum (TypeError)&lt;/h1&gt;

&lt;h1&gt;~&amp;gt;    from -:15:in `&lt;main&gt;&amp;#39;&lt;/h1&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;당연히 &lt;code&gt;Fixnum#*&lt;/code&gt; 메소드는 인수로 NumList 객체를 받을 수 없으므로
에러가 납니다. 설마 Fixnum#* 수정하시진 않겠죠. 어떻게 해야할까요.&lt;/p&gt;

&lt;p&gt;이를 때는 &lt;code&gt;coerce&lt;/code&gt;(강제 타입 변환)을 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
class NumList &amp;lt; Array
  def *(n)
    map { |e| e * n }
  end&lt;/p&gt;

&lt;p&gt;def coerce(n)
    [self, n]
  end
end&lt;/p&gt;

&lt;p&gt;numlist = NumList[1, 2, 3]&lt;/p&gt;

&lt;p&gt;numlist * 3 # =&amp;gt; [3, 6, 9]
3 * numlist # =&amp;gt; [3, 6, 9]
```&lt;/p&gt;

&lt;p&gt;Fixnum#* 메소드는 인수가 형변환이 불가능할 경우 객체의 coerce 메소드를 호출하는데 이를 이용하는 방법입니다.&lt;/p&gt;

&lt;h3&gt;50. DATA.rewind&lt;/h3&gt;

&lt;p&gt;DATA는 __END__ 이후의 부분을 File 객체로 불러들인 객체입니다.
따라서 rewind 메소드를 사용할 수 있는다. 이는 __END__ 이후의 첫
행으로 돌아가는 게 아니라 전체 파일의 첫 행으로 돌아갑니다. 따라서 이를 사용하면, 아차차.. Quine를 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby&lt;/p&gt;

&lt;h1&gt;!/usr/bin/env ruby&lt;/h1&gt;

&lt;p&gt;require &amp;quot;g&amp;quot;
def evaluate(str)
  op = %w(+ * \/)
  digit = /-*\d+/
  if m = str.match(/(#{op})\s+(#{digit})\s+(#{digit})/)
    op, a, b = m.captures
    inner = a.to&lt;em&gt;i.send(op, b.to&lt;/em&gt;i)
    str = m.pre&lt;em&gt;match + inner.to&lt;/em&gt;s + m.post&lt;em&gt;match
    evaluate(str)
  else
    str
  end
end
g evaluate(&amp;quot;+ * 3 4 5&amp;quot;)
DATA.rewind
puts DATA.to&lt;/em&gt;a
&lt;strong&gt;END&lt;/strong&gt;
```&lt;/p&gt;

&lt;p&gt;이 코드를 실행하면 evaluate의 결과가 출력되는 것과 함께 코드 자체가 표준 출력으로 출력됩니다.&lt;/p&gt;

&lt;h3&gt;51. Ruby 키워드&lt;/h3&gt;

&lt;p&gt;Ruby 키워드는 언어의 예약어가 아니므로 명시적인 문맥에서 사용하기만 한다면
메소드 이름으로 사용하는 것도 가능합니다. 여기에서는 &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;을 Trivia 클래스에서 정의해보겠습니다.&lt;/p&gt;

&lt;p&gt;```ruby
class Trivia
  def case(klass)
    case self
    when klass; &amp;#39;You are my sunshine.&amp;#39;
    else &amp;#39;No, you are Alien for me&amp;#39;
    end
  end&lt;/p&gt;

&lt;p&gt;def if(bool, arg)
    if bool
      yield arg
    else
      arg.reverse
    end
  end&lt;/p&gt;

&lt;p&gt;def for(list)
    list.map { |e| yield e }
  end
end&lt;/p&gt;

&lt;p&gt;t = Trivia.new&lt;/p&gt;

&lt;p&gt;t.case(Trivia) # =&amp;gt; &amp;quot;You are my sunshine.&amp;quot;
t.case(Array) # =&amp;gt; &amp;quot;No, you are Alien for me&amp;quot;&lt;/p&gt;

&lt;p&gt;t.if(true, &amp;#39;my name is charlie&amp;#39;) { |str| str.upcase } # =&amp;gt; &amp;quot;MY NAME IS CHARLIE&amp;quot;
t.if(false, &amp;#39;my name is charlie&amp;#39;) { |str| str.upcase } # =&amp;gt; &amp;quot;eilrahc si eman ym&amp;quot;&lt;/p&gt;

&lt;p&gt;t.for([&lt;em&gt;1..10]) { |i| i&lt;/em&gt;*2 } # =&amp;gt; [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```&lt;/p&gt;

&lt;h3&gt;52. YAML 태그 지정&lt;/h3&gt;

&lt;p&gt;사용자 데이터를 다루는 프로그램을 만들 때 프로그램과 데이터를 분리하기 위해 &lt;code&gt;yaml 라이브러리&lt;/code&gt;를 사용하면 편리합니다.&lt;/p&gt;

&lt;p&gt;```ruby
require &amp;quot;yaml&amp;quot;&lt;/p&gt;

&lt;p&gt;langs&lt;em&gt;array = YAML.load(DATA)
puts langs&lt;/em&gt;array.map { |lang| &amp;quot;My favorite language is &amp;quot; + lang }&lt;/p&gt;

&lt;h1&gt;&amp;gt;&amp;gt; My favorite language is Ruby&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; My favorite language is Lisp&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; My favorite language is C++&lt;/h1&gt;

&lt;h2&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Ruby&lt;/li&gt;
&lt;li&gt;Lisp&lt;/li&gt;
&lt;li&gt;C++
```&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 &lt;code&gt;!ruby/&lt;/code&gt;으로 시작하는 태그를 사용하면 문자열에 해당하는
클래스를 지정할 수 있는데 &lt;code&gt;!ruby/object:&amp;lt;클래스 이름&amp;gt;&lt;/code&gt; 태그를 사용하면
임의의 클래스를 지정할 수도 있습니다. Language 클래스 객체로 YAML 데이터를 읽어와보겠습니다.&lt;/p&gt;

&lt;p&gt;```ruby
 require &amp;quot;yaml&amp;quot;
 class Language
   attr_accessor :name, :born, :designer
   def profile
     [name, born, designer] * &amp;#39;-&amp;#39;
   end
 end&lt;/p&gt;

&lt;p&gt;members = YAML.load(DATA)&lt;/p&gt;

&lt;p&gt;puts members.map { |member| member.profile }&lt;/p&gt;

&lt;p&gt;# &amp;gt;&amp;gt; Ruby-1993-Yukihiro Matsumoto
 # &amp;gt;&amp;gt; Lisp-1958-Joh McCarthy
 # &amp;gt;&amp;gt; C++-1983-Bjarne Stroustrup&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;ul&gt;
&lt;li&gt;!ruby/object:Language
name: Ruby
born: 1993
designer: Yukihiro Matsumoto&lt;/li&gt;
&lt;li&gt;!ruby/object:Language
name: Lisp
born: 1958
designer: Joh McCarthy&lt;/li&gt;
&lt;li&gt;!ruby/object:Language
name: C++
born: 1983
designer: Bjarne Stroustrup
```&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;53. 단항연산자 ~ (tilde)&lt;/h3&gt;

&lt;p&gt;단항연산자 &lt;code&gt;~&lt;/code&gt;는 사실 메소드인데 이 메소드가 어디서 정의되어있는 지 
아시나요? 맞습니다. &lt;code&gt;Fixnum&lt;/code&gt;과 &lt;code&gt;Bignum&lt;/code&gt;에서 NOT 연산을 하기 위해 만들어진 연산자입니다.&lt;/p&gt;

&lt;p&gt;```ruby
~1 # =&amp;gt; -2
~2 # =&amp;gt; -3
~3 # =&amp;gt; -4
~7 # =&amp;gt; -8&lt;/p&gt;

&lt;p&gt;1.to&lt;em&gt;s(2) # =&amp;gt; &amp;quot;1&amp;quot;
2.to&lt;/em&gt;s(2) # =&amp;gt; &amp;quot;10&amp;quot;
3.to&lt;em&gt;s(2) # =&amp;gt; &amp;quot;11&amp;quot;
7.to&lt;/em&gt;s(2) # =&amp;gt; &amp;quot;111&amp;quot;&lt;/p&gt;

&lt;p&gt;(~1).to&lt;em&gt;s(2) # =&amp;gt; &amp;quot;-10&amp;quot;
(~2).to&lt;/em&gt;s(2) # =&amp;gt; &amp;quot;-11&amp;quot;
(~3).to&lt;em&gt;s(2) # =&amp;gt; &amp;quot;-100&amp;quot;
(~7).to&lt;/em&gt;s(2) # =&amp;gt; &amp;quot;-1000&amp;quot;
```&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Regexp&lt;/code&gt;에도 정의되어있습니다. 이 메소드는 gets에서 입력을 받아 &lt;code&gt;$_&lt;/code&gt;와 패턴 매치를 하기위해 사용됩니다.&lt;/p&gt;

&lt;p&gt;```ruby
$_ = &amp;#39;Ruby is a dynamic, open source programming language with a focus on simplicity and productivity.&amp;#39;&lt;/p&gt;

&lt;p&gt;pos = ~ /\w{8,}/
puts &amp;quot;8+long-word &lt;code&gt;#{$&amp;amp;}&lt;/code&gt; appeared at #{pos}&amp;quot;&lt;/p&gt;

&lt;h1&gt;&amp;gt;&amp;gt; 8+long-word &lt;code&gt;programming&lt;/code&gt; appeared at 31&lt;/h1&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;단항연산자의 특이한 점은 리시버가 메소드 뒤에 오는 점입니다. 이런
특징을 활용해 편리한 메소드들을 잔뜩 정의해서 써야만 하겠죠. 연산 우선 순위도 높아 메소드 체인에서도 문제 없이 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;```ruby
class String
  def ~
    reverse
  end
end&lt;/p&gt;

&lt;p&gt;class Symbol
  def ~
    swapcase
  end
end&lt;/p&gt;

&lt;p&gt;class Array
  def ~
    reverse
  end
end&lt;/p&gt;

&lt;p&gt;class Hash
  def ~
    invert
  end
end&lt;/p&gt;

&lt;p&gt;~&amp;#39;よるなくたにし なんてしつけいい&amp;#39; # =&amp;gt; &amp;quot;いいけつしてんな しにたくなるよ&amp;quot;&lt;/p&gt;

&lt;p&gt;s = &amp;#39;godtoh&amp;#39;
~s.swapcase # =&amp;gt; &amp;quot;HOTDOG&amp;quot;&lt;/p&gt;

&lt;p&gt;~:Hello # =&amp;gt; :hELLO&lt;/p&gt;

&lt;p&gt;~[1,2,3,4] # =&amp;gt; [4, 3, 2, 1]&lt;/p&gt;

&lt;p&gt;~{ruby: 1, lisp: 2} # =&amp;gt; {1=&amp;gt;:ruby, 2=&amp;gt;:lisp}
```&lt;/p&gt;

&lt;p&gt;뭐 확실히 &lt;code&gt;~&lt;/code&gt;만으론 메소드의 의도를 파악하기 힘듭니다만...&lt;/p&gt;

&lt;h3&gt;54. 멀티 바이트 메소드&lt;/h3&gt;

&lt;p&gt;1.9부터 메소드 이름에 멀티 바이트 문자를 사용할 수 있는데 실제 활용
사례는 별로 없습니다. 이래서는 Ruby가 불쌍해지니 이러한 방법을 포교해보죠.&lt;/p&gt;

&lt;p&gt;```ruby
class String
  def ©(name=&amp;#39;anonymous&amp;#39;)
    self + &amp;quot; - Copyright © #{name} #{Time.now.year} All rights reserved. -&amp;quot;
  end&lt;/p&gt;

&lt;p&gt;def 
    self + &amp;#39; - Designed by Apple in California -&amp;#39;
  end
end&lt;/p&gt;

&lt;p&gt;&amp;#39;this is my work&amp;#39;.©(:Charlie) # =&amp;gt; &amp;quot;this is my work - Copyright © Charlie 2012 All rights reserved. -&amp;quot;&lt;/p&gt;

&lt;p&gt;poetry = &amp;lt;&amp;lt;EOS
Ruby is not a Gem
Gem is not a Jam
Jam is not a Jelly
Jam is about Traffic
Gem is about Library
Ruby is about Language!EOS&lt;/p&gt;

&lt;p&gt;puts poetry.©&lt;/p&gt;

&lt;h1&gt;&amp;gt;&amp;gt; Ruby is not a Gem&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; Gem is not a Jam&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; Jam is not a Jelly&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; Jam is about Traffic&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; Gem is about Library&lt;/h1&gt;

&lt;h1&gt;&amp;gt;&amp;gt; Ruby is about Language!# &amp;gt;&amp;gt;  - Copyright © anonymous 2012 All rights reserved. -&lt;/h1&gt;

&lt;p&gt;&amp;#39;hello, apple&amp;#39;. # =&amp;gt; &amp;quot;hello, apple - Designed by Apple in California -&amp;quot;
```&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&lt;/code&gt;는 Mac keyboard에서 &lt;code&gt;~$k&lt;/code&gt;(Option+Shift+k)를 누르면 나옵니다. (역주:
이 기호는 애플 상표 기호로, Mac에서만 제대로 나옵니다.)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Numeric&lt;/code&gt;에는 화폐 메소드를 추가해보죠. 여기서는 &lt;code&gt;def method&lt;/code&gt;를 사용해 일일히 클래스를 다시 여는 번거로움을 줄여보겠습니다.&lt;/p&gt;

&lt;p&gt;```ruby
def def&lt;em&gt;method(name, klass=self.class, &amp;amp;body)
  blk = block&lt;/em&gt;given??body : -&amp;gt;{ &amp;quot;#{name}: not implemented yet.&amp;quot; }
  klass.class&lt;em&gt;eval { define&lt;/em&gt;method(&amp;quot;#{name}&amp;quot;, blk) }
end&lt;/p&gt;

&lt;p&gt;currencies = %w(¥ € £ $).zip [:JPY, :EUR, :GBP, :USD]
currencies.each do |cur, sym|
  def&lt;em&gt;method(cur, Numeric) do
    int, dec = Exchange(self, sym).to&lt;/em&gt;s.split(&amp;#39;.&amp;#39;)
    dec = dec ?&amp;quot;.#{dec[/.{1,2}/]}&amp;quot; : &amp;#39;&amp;#39;
    cur + int.reverse.scan(/.{1,3}/).join(&amp;#39;,&amp;#39;).reverse + dec
  end
end&lt;/p&gt;

&lt;p&gt;def Exchange(num, &lt;em&gt;for&lt;/em&gt;)
  num * {USD:1.0, JPY:81.3, EUR:0.76, GBP:0.62}[&lt;em&gt;for&lt;/em&gt;]
end&lt;/p&gt;

&lt;p&gt;123.45.¥ # =&amp;gt; &amp;quot;¥10,036.48&amp;quot;
1000000.¥ # =&amp;gt; &amp;quot;¥81,300,000.0&amp;quot;
123.€ # =&amp;gt; &amp;quot;€93.48&amp;quot;
1000000.€ # =&amp;gt; &amp;quot;€760,000.0&amp;quot;
123.45.£ # =&amp;gt; &amp;quot;£76.53&amp;quot;
1000000.£ # =&amp;gt; &amp;quot;£620,000.0&amp;quot;
```&lt;/p&gt;

&lt;p&gt;뭐 입력이 좀 힘들긴 합니다만..&lt;/p&gt;

&lt;h3&gt;55. 비밀 메소드&lt;/h3&gt;

&lt;p&gt;위의 예처럼 Ruby에서는 키워드나 기호를 메소드 이름에 사용할 수
있습니다만 사용하지 못 하는 것도 있습니다. 예를 들어, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;,&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;#&lt;/code&gt;, &lt;code&gt;$&lt;/code&gt; 는 메소드 이름에서 사용할 수 없습니다.&lt;/p&gt;

&lt;p&gt;```ruby
def .
end&lt;/p&gt;

&lt;h1&gt;~&amp;gt; -:1: syntax error, unexpected &amp;#39;.&amp;#39;&lt;/h1&gt;

&lt;p&gt;def ,
end&lt;/p&gt;

&lt;h1&gt;~&amp;gt; -:1: syntax error, unexpected &amp;#39;,&amp;#39;&lt;/h1&gt;

&lt;p&gt;def @
end&lt;/p&gt;

&lt;h1&gt;~&amp;gt; -:1: syntax error, unexpected $undefined&lt;/h1&gt;

&lt;p&gt;def =
end&lt;/p&gt;

&lt;h1&gt;~&amp;gt; -:1: syntax error, unexpected &amp;#39;=&amp;#39;&lt;/h1&gt;

&lt;p&gt;def (
end&lt;/p&gt;

&lt;h1&gt;~&amp;gt; -:2: syntax error, unexpected keyword_end&lt;/h1&gt;

&lt;p&gt;def #
end&lt;/p&gt;

&lt;h1&gt;~&amp;gt; -:4: syntax error, unexpected $end&lt;/h1&gt;

&lt;p&gt;def $
end&lt;/p&gt;

&lt;h1&gt;~&amp;gt; -:1: syntax error, unexpected $undefined&lt;/h1&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;보통은 여기서 납득하고 넘어가겠죠. 하지만 &lt;code&gt;define_method&lt;/code&gt;를 사용하면 이러한
기호들도 메소드 이름으로 사용할 수 있습니다. 먼저 def_method를 사용해 이런 메소드를 정의해보죠.&lt;/p&gt;

&lt;p&gt;```ruby
def def&lt;em&gt;method(name, klass=self.class, &amp;amp;body)
  blk = block&lt;/em&gt;given??body : -&amp;gt;{ &amp;quot;#{name}: not implemented yet.&amp;quot; }
  klass.class&lt;em&gt;eval { define&lt;/em&gt;method(&amp;quot;#{name}&amp;quot;, blk) }
end&lt;/p&gt;

&lt;p&gt;class Trivia&lt;/p&gt;

&lt;p&gt;end&lt;/p&gt;

&lt;p&gt;methods = [&amp;quot;.&amp;quot;, &amp;quot;,&amp;quot;, &amp;quot;@&amp;quot;, &amp;quot;=&amp;quot;, &amp;quot;(&amp;quot;, &amp;quot;#&amp;quot;, &amp;quot;$&amp;quot;]
methods.each { |meth| def_method meth, Trivia }&lt;/p&gt;

&lt;p&gt;Trivia.public&lt;em&gt;instance&lt;/em&gt;methods(false) # =&amp;gt; [:&amp;quot;.&amp;quot;, :&amp;quot;,&amp;quot;, :&amp;quot;@&amp;quot;, :&amp;quot;=&amp;quot;, :&amp;quot;(&amp;quot;, :&amp;quot;#&amp;quot;, :&amp;quot;$&amp;quot;]
```&lt;/p&gt;

&lt;p&gt;되죠?&lt;/p&gt;

&lt;p&gt;하지만 이 메소드들에는 치명적인 단점이 하나 있습니다.&lt;/p&gt;

&lt;p&gt;그건...&lt;/p&gt;

&lt;p&gt;호출이 불가능하는 겁니다! ^^;&lt;/p&gt;

&lt;p&gt;```ruby
t = Trivia.new&lt;/p&gt;

&lt;p&gt;t.. # =&amp;gt; 
t., # =&amp;gt; 
t.@ # =&amp;gt; 
t.= # =&amp;gt; 
t.( # =&amp;gt; 
t.# # =&amp;gt; 
t.$ # =&amp;gt; &lt;/p&gt;

&lt;h1&gt;~&amp;gt; -:42: syntax error, unexpected &amp;#39;)&amp;#39;&lt;/h1&gt;

&lt;h1&gt;~&amp;gt; ...1335430361&lt;em&gt;15646&lt;/em&gt;549583 = (t..);$stderr.puts(&amp;quot;!XMP1335430361...&lt;/h1&gt;

&lt;h1&gt;~&amp;gt; ...                               ^&lt;/h1&gt;

&lt;h1&gt;~&amp;gt; -:43: syntax error, unexpected &amp;#39;,&amp;#39;&lt;/h1&gt;

&lt;h1&gt;~&amp;gt; ...&lt;em&gt;1335430361&lt;/em&gt;15646_549583 = (t.,);$stderr.puts(&amp;quot;!XMP133543036...&lt;/h1&gt;

&lt;h1&gt;~&amp;gt; ...                               ^&lt;/h1&gt;

&lt;h1&gt;~&amp;gt; -:44: syntax error, unexpected $undefined&lt;/h1&gt;

&lt;h1&gt;~&amp;gt; ...&lt;em&gt;1335430361&lt;/em&gt;15646_549583 = (t.@);$stderr.puts(&amp;quot;!XMP133543036...&lt;/h1&gt;

&lt;h1&gt;~&amp;gt; ...                               ^&lt;/h1&gt;

&lt;h1&gt;~&amp;gt; -:45: syntax error, unexpected &amp;#39;=&amp;#39;&lt;/h1&gt;

&lt;h1&gt;~&amp;gt; ...&lt;em&gt;1335430361&lt;/em&gt;15646_549583 = (t.=);$stderr.puts(&amp;quot;!XMP133543036...&lt;/h1&gt;

&lt;h1&gt;~&amp;gt; ...                               ^&lt;/h1&gt;

&lt;h1&gt;~&amp;gt; -:48: syntax error, unexpected $undefined&lt;/h1&gt;

&lt;h1&gt;~&amp;gt; ...&lt;em&gt;1335430361&lt;/em&gt;15646_549583 = (t.$);$stderr.puts(&amp;quot;!XMP133543036...&lt;/h1&gt;

&lt;h1&gt;~&amp;gt; ...                               ^&lt;/h1&gt;

&lt;h1&gt;~&amp;gt; -:65: syntax error, unexpected $end, expecting &amp;#39;)&amp;#39;&lt;/h1&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;단 &lt;code&gt;Object#send&lt;/code&gt;나 &lt;code&gt;Method#call&lt;/code&gt; 메소드를 사용해 호출하는 건 가능한데 귀찮습니다.&lt;/p&gt;

&lt;p&gt;```ruby
t = Trivia.new&lt;/p&gt;

&lt;p&gt;t.send &amp;#39;.&amp;#39; # =&amp;gt; &amp;quot;.: not implemented yet.&amp;quot;
t.method(&amp;#39;,&amp;#39;).call # =&amp;gt; &amp;quot;,: not implemented yet.&amp;quot;&lt;/p&gt;

&lt;p&gt;def_method(&amp;#39;@&amp;#39;, Trivia) do |num|
  &amp;quot;#{self.class}&amp;quot;.center(num, &amp;#39;@&amp;#39;)
end&lt;/p&gt;

&lt;p&gt;def_method(&amp;#39;(&amp;#39;, Trivia) do |str|
  &amp;quot;( #{str} )&amp;quot;
end&lt;/p&gt;

&lt;p&gt;t.send &amp;#39;@&amp;#39;, 12 # =&amp;gt; &amp;quot;@@@Trivia@@@&amp;quot;
t.send &amp;#39;(&amp;#39;, &amp;#39;I love Ruby&amp;#39;  # =&amp;gt; &amp;quot;( I love Ruby )&amp;quot;
``&lt;code&gt;
즉 이러한 기호들을 사용한 메소드는 일반적인 방법으로는 정의하거나
호출하는 게 불가능하지만, 일반적이지 않은 특별한 방법을 사용하면
정의할 수도 있고 호출할 수도 있는 특수한 메소드들이라고 할 수
있습니다. 저는 이러한 메소드들을 특수한 방법으로 숨겨진 메소드, 즉
&lt;/code&gt;비밀(hidden)` 메소드라고 이름 붙였습니다. 어디에 사용할 지는... 저도 잘 모르겠습니다..&lt;/p&gt;

&lt;p&gt;이상으로 Ruby 55가지 기법을 설명했습니다. 새로운 발견은 있으셨나요? &lt;/p&gt;

&lt;p&gt;(추신：2013-03-31)@no6v 님 이름이 @no6v1 님으로 되어있었습니다. 수정했습니다. 죄송합니다.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;a href="/books/"&gt;
  &lt;img src="http://melborne.github.io/assets/images/2013/03/ruby_trivia_cover.png" alt="trivia" style="width:200px" /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://gum.co/owIqH" class="gumroad-button"&gt;E-Book 알아두면 도움이 되는 55가지 루비 기법 EPUB/MOBI판&lt;/a&gt;&lt;script type="text/javascript" src="https://gumroad.com/js/gumroad-button.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="https://gumroad.com/js/gumroad.js"&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;이 링크는 Gumroad의 상품 구매 페이지입니다. 클릭하면 오버레이 윈도우가
뜨고 여기서 카드 정보를 입력하면 구입이 가능합니다. 구입을 하려면 카드
정보와 이메일 주소를 입력해야합니다. 구입이 정상적으로 완료되면 입력한 이메일로 다운로드 가능한 링크가 보내집니다.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>AngularJs 스타일 가이드</title>
    <link rel="alternate" href="http://blog.url.com/articles/2013-10-30-angularjs-style-guide/"/>
    <id>http://blog.url.com/articles/2013-10-30-angularjs-style-guide/</id>
    <published>2013-10-30T03:00:00Z</published>
    <updated>2014-01-18T16:38:51+00:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;이 글은 Minko Gechev 씨의 &lt;a href="https://github.com/mgechev/angularjs-style-guide"&gt;AngularJS Style Guide&lt;/a&gt; 문서를 &lt;a href="http://nacyot.com"&gt;nacyot&lt;/a&gt;이 변역한 글입니다. 번역된 문서는 &lt;a href="https://github.com/nacyot/angularjs-style-guide"&gt;Github 저장소&lt;/a&gt;에서 관리되고 있으며 원본은 &lt;a href="https://github.com/mgechev/angularjs-style-guide"&gt;여기&lt;/a&gt;에서 찾아볼 수 있습니다. 관련된 질문은 &lt;a href="http://nacyot.com/guestbook"&gt;GuestBook&lt;/a&gt;이나 &lt;a href="mailto:propellerheaven@gmail.com"&gt;Email&lt;/a&gt;으로 해주시기합니다.&lt;/p&gt;



&lt;h1&gt;소개&lt;/h1&gt;

&lt;p&gt;이 스타일 가이드의 목표는 AngularJS 어플리케이션을 제작하는 데 있어서 현재의 베스트 프렉티스를 알려드리는 일입니다.&lt;/p&gt;

&lt;p&gt;이 문서의 베스트 프렉티스는 아래 자료들로부터 수집되었습니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;AngularJS 소스 코드&lt;/li&gt;
&lt;li&gt;제가 읽은 소스 코드와 문서들&lt;/li&gt;
&lt;li&gt;제 경험&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;주의&lt;/strong&gt;: 이 문서는 아직 작성중입니다. 이 문서의 가장 큰 목표는 community-driven입니다. 따라서 스타일의 차이를 줄이는 일을 AngularJS 커뮤니티에 있어서 반가운 일일 것입니다.&lt;/p&gt;

&lt;p&gt;이 스타일 가이드에서 자바스크립트 프로그래밍의 가이드라인을 제공하진 않습니다. 자바스크립트에 관련한 문서는 아래에서 찾을 수 있습니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml"&gt;구글 자바스크립트 스타일 가이드&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style"&gt;모질라 자바스크립트 스타일 가이드&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/styleguide/javascript"&gt;GitHub&amp;#39;s 자바스크립트 스타일 가이드&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://javascript.crockford.com/code.html"&gt;Douglas Crockford&amp;#39;s 자바스크립트 스타일 가이드&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;AngularJS 어플리케이션 제작에 있어서는 &lt;a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml"&gt;구글 자바스크립트 스타일 가이드&lt;/a&gt;를 추천합니다..&lt;/p&gt;

&lt;p&gt;AngularJS GitHub 위키에는 &lt;a href="https://github.com/ProLoser"&gt;ProLoser&lt;/a&gt;가 작성한 관련된 부분이 있습니다. &lt;a href="https://github.com/angular/angular.js/wiki"&gt;여기&lt;/a&gt;에서 확인하실 수 있습니다..&lt;/p&gt;

&lt;h1&gt;차례&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="#general"&gt;일반&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="#directory-structure"&gt;디렉토리 구조&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#optimize-the-digest-cycle"&gt;Digest cycle 최적화&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#others"&gt;기타&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#modules"&gt;모듈&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#controllers"&gt;컨트롤러&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#directives"&gt;디렉티브&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#filters"&gt;필터&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#services"&gt;서비스&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#templates"&gt;템플릿&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#routing"&gt;라이팅&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#testing"&gt;테스트&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#contribution"&gt;기여&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;일반&lt;/h1&gt;

&lt;h3&gt;디렉토리 구조&lt;/h3&gt;

&lt;p&gt;규모가 큰 AngularJS 어플리케이션엔 다수의 컴포넌트가 있으므로 디렉토리 계층 구조를 만드는 것이 좋습니다.&lt;/p&gt;

&lt;p&gt;주로 두 가지 접근법이 사용됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;컴포넌트 타입 별로 상위 디렉터리를 구성하고, 기능별로 하위 폴더를 구성.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 접근법을 사용한 디렉토리 구조는 다읍과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── app
│   ├── app.js
│   ├── controllers
│   │   ├── page1
│   │   │   ├── FirstCtrl.js
│   │   │   └── SecondCtrl.js
│   │   └── page2
│   │       └── ThirdCtrl.js
│   ├── directives
│   │   ├── page1
│   │   │   └── directive1.js
│   │   └── page2
│   │       ├── directive2.js
│   │       └── directive3.js
│   ├── filters
│   │   ├── page1
│   │   └── page2
│   └── services
│       ├── CommonService.js
│       ├── cache
│       │   ├── Cache1.js
│       │   └── Cache2.js
│       └── models
│           ├── Model1.js
│           └── Model2.js
├── lib
└── test
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;기능 별로 상위 디렉토리를 나누고, 컴포넌트 타입 별로 하위 디렉토리를 구성.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음과 같은 디렉토리 구조가 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── app
│   ├── app.js
│   ├── common
│   │   ├── controllers
│   │   ├── directives
│   │   ├── filters
│   │   └── services
│   ├── page1
│   │   ├── controllers
│   │   │   ├── FirstCtrl.js
│   │   │   └── SecondCtrl.js
│   │   ├── directives
│   │   │   └── directive1.js
│   │   ├── filters
│   │   │   ├── filter1.js
│   │   │   └── filter2.js
│   │   └── services
│   │       ├── service1.js
│   │       └── service2.js
│   └── page2
│       ├── controllers
│       │   └── ThirdCtrl.js
│       ├── directives
│       │   ├── directive2.js
│       │   └── directive3.js
│       ├── filters
│       │   └── filter3.js
│       └── services
│           └── service3.js
├── lib
└── test
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;디렉티브 디렉토리를 만들 땐 디렉티브에 관련된 파일들(템플릿, CSS/SASS 파일, 자바스크립트)을 한 폴더에 모읍니다. 이런 방식으로 디렉토리를 구성한다면 프로젝트 어디서나 이 구조를 일관적으로 사용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app
└── directives
    ├── directive1
    │   ├── directive1.html
    │   ├── directive1.js
    │   └── directive1.sass
    └── directive2
        ├── directive2.html
        ├── directive2.js
        └── directive2.sass
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 디렉티브 디렉토리 구성은 위에서 제시한 두 가지 디렉토리 구성법에서 모두 사용할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;두 방식을 사용하는 데 있어서 또 하나 작은 선택지는 &lt;a href="http://joshdmiller.github.io/ng-boilerplate/#/home"&gt;ng-boilerplate&lt;/a&gt;을 사용하는 것입니다. 특정 컴포넌트의 유닛 테스트는 컴포넌트와 같은 폴더에 저장합니다. 이를 통해 컴포넌트의 코드가 변경되었을 때 테스트 코드를 찾기 쉬우며, 테스트를 컴포넌트의 사용법을 다룬 문서처럼 사용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;services
├── cache
│   ├── cache1.js
│   └── cache1.spec.js
└── models
    ├── model1.js
    └── model1.spec.js
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;app.js&lt;/code&gt; 파일에는 라우트 정의와 설정이 포함되어야 하며, 필요한 경우 초기화 작업을 해줍니다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;각각의 자바스크립트 파일에는 오직 하나의 컴포넌트만을 포함하세요. 파일 이름은 컴포넌트의 이름과 같아야합니다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://yeoman.io"&gt;Yeoman&lt;/a&gt;이나 &lt;a href="http://joshdmiller.github.io/ng-boilerplate/#/home"&gt;ng-boilerplate&lt;/a&gt;와 같은 Angular 프로젝트 구조 템플릿을 사용합니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;저는 같은 종류의 컴포넌트를 찾기 쉬운 첫번째 방법을 선호합니다.&lt;/p&gt;

&lt;p&gt;각 컴포넌트의 명명 규칙은 각 컴포넌트 절에서 설명합니다.&lt;/p&gt;

&lt;h3&gt;Digest cycle 최적화&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;가장 중요한 변수만 감시합니다(예를 들어 실시간 통신이 필요한 경우 각각의 메시지를 받을 때 digest loop를 일으키지 않아야합니다).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$watch&lt;/code&gt;는 가능한한 간단하게 작성합니다. 무겁과 느린 처리를 하나의 &lt;code&gt;$watch&lt;/code&gt;에 집어넣으면 어플리케이션 전체를 느리게 만듭니다. (자바스크립트는 싱글 쓰레드에서 작동하므로 $digest 루프 또한 싱글 쓰레드로 작동합니다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;기타&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;사용해야 함.

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;setTimeout&lt;/code&gt; 대신 &lt;code&gt;$timeout&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;window&lt;/code&gt; 대신 &lt;code&gt;$window&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;document&lt;/code&gt; 대신 &lt;code&gt;$document&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$.ajax&lt;/code&gt; 대신 &lt;code&gt;$http&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이를 통해 테스트를 쉽게 만들고 예상치 못한 작동을 방지 할 수 있습니다. @@@ &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;아래의 툴을 사용해 작업을 자동화해야합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://yeoman.io"&gt;Yeoman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://gruntjs.com"&gt;Grunt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://bower.io"&gt;Bower&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;콜백 대신에 promises(&lt;code&gt;$q&lt;/code&gt;)를 사용하세요. $q를 사용하면 코드가 깔끔해지고, 여러분을 콜백 지옥에서 구원해줄 것입니다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;가능할 땐 &lt;code&gt;$http&lt;/code&gt; 대신 &lt;code&gt;$resource&lt;/code&gt;를 사용. 높은 수준의 추상화는 자질구레한 작업으로부터 해방시켜줍니다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AngularJS pre-minifier(&lt;a href="https://github.com/btford/ngmin"&gt;ngmin&lt;/a&gt;, &lt;a href="https://github.com/olov/ng-annotate"&gt;ng-annotate&lt;/a&gt;)를 사용해 minification 시의 문제를 미리 방지합니다..&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;전역 변수를 사용하지 마세요. 모든 의존성은 의존성 주입(DI)로 해결하시기 바랍니다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;$scope&lt;/code&gt;를 오염시키지 마세요. 오직 템플릿에서 사용하는 변수와 함수들만 추가하세요.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/angular/angular.js/pull/4366/files"&gt;&lt;code&gt;nginit&lt;/code&gt;보다 컨트롤러를 사용하세요&lt;/a&gt;. &lt;code&gt;ngInit&lt;/code&gt;의 유일한 적절한 사용법은 &lt;code&gt;ngRepeat&lt;/code&gt; 프로퍼티의 별칭을 만드는 일입니다. 이 외의 모든 경우엔 변수 범위(scope)를 초기화하는데 &lt;code&gt;ngInit&lt;/code&gt; 대신 컨트롤러를 사용해야합니다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;변수명, 프로퍼티명, 메소드명 앞에 &lt;code&gt;$&lt;/code&gt;를 사용하지 않습니다. &lt;code&gt;$&lt;/code&gt;를 앞에 붙이는 명명법은 AngularJS와 관련되어 특별한 의미로 사용됩니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;모듈&lt;/h1&gt;

&lt;p&gt;모듈의 구성은 일반적으로 두 가지 기준이 사용됩니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;기능&lt;/li&gt;
&lt;li&gt;컴포넌트 타입&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;두 접근법에 큰 차이는 없지만 첫번째 방법이 좀 더 깔끔합니다. 또한 (아직 AngularJS 로드맵에는 없습니다만) 모듈의 지연 로딩이 지원된다면 어플리케이션의 성능도 좋아질 것입니다.&lt;/p&gt;

&lt;h1&gt;컨트롤러&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;컨트롤러에서 DOM을 조작하지 마세요. 컨트롤러 대신 디렉티브를 사용하시기 바랍니다.&lt;/li&gt;
&lt;li&gt;컨터르롤러의 이름은 컨트롤러의 이름을 기준으로 지어야 하며(예를 들어 shopping cart, homepage, admin panel), 이름의 끝에는 &lt;code&gt;Ctrl&lt;/code&gt;을 붙여줍니다. 컨트롤러 이름은 UpperCamelCase를 사용해 작성합니다(&lt;code&gt;HomePageCtrl&lt;/code&gt;, &lt;code&gt;ShoppingCartCtrl&lt;/code&gt;, &lt;code&gt;AdminPanelCtrl&lt;/code&gt;, etc.).&lt;/li&gt;
&lt;li&gt;컨트롤러를 전역 공간에 정의하지 마세요(이런 사용법이 AngularJS 자체에서 제약이 되어있지 않더라도, 이러한 방법은 전역 공간을 더럽히는 안 좋은 방법입니다).&lt;/li&gt;
&lt;li&gt;&lt;p&gt;컨트롤러를 정의할 때 배열 문법을 사용하세요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.controller(&amp;#39;MyCtrl&amp;#39;, [&amp;#39;dependency1&amp;#39;, &amp;#39;dependency2&amp;#39;, ..., &amp;#39;dependencyn&amp;#39;, function (dependency1, dependency2, ..., dependencyn) {
  //...body
}]);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이런 식으로 정의하면 minification에서 발생할 수 있는 문제를 피할 수 있습니다. &lt;a href="https://github.com/olov/ng-annotate"&gt;ng-annotate&lt;/a&gt;나 grunt task &lt;a href="https://github.com/mzgol/grunt-ng-annotate"&gt;grunt-ng-annotate&lt;/a&gt;와 같은 툴을 사용하면 자동적으로 배열을 사용해 컨트롤러를 정의합니다.
* 컨트롤러의 의존성은 원래 이름을 사용하세요. 이를 통해 일기 쉬운 코드를 만들 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    module.controller(&amp;#39;MyCtrl&amp;#39;, [&amp;#39;$scope&amp;#39;, function (s) {
      //...body
    }]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 예제보다는 아래의 예제가 읽기 쉽습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    module.controller(&amp;#39;MyCtrl&amp;#39;, [&amp;#39;$scope&amp;#39;, function ($scope) {
      //...body
    }]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 스크롤이 필요할 정도로 코드가 길어졌을 때 특히 유용합니다. 원래의 이름을 사용하지 않으면 코드를 작성하는 프로그래머가 의존성의 이름을 까먹어버릴지도 모릅니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;컨트롤라는 가능한 최소한의 기능만을 가져야합니다. 추상적이고 일반적으로 쓰이는 함수들은 서비스에 정의하세요.&lt;/li&gt;
&lt;li&gt;다른 컨트롤러와 소통이 필요한 경우엔 메소드 호출이나 &lt;code&gt;$emit&lt;/code&gt;, &lt;code&gt;$broadcast&lt;/code&gt;, &lt;code&gt;$on&lt;/code&gt; 메소드를 사용해주세요. &lt;code&gt;$emit&lt;/code&gt;이나 &lt;code&gt;$broadcasted&lt;/code&gt;되는 메소드는 최소한으로 유지합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$emit&lt;/code&gt;나 &lt;code&gt;$broadcast&lt;/code&gt;를 통해서 넘겨지는 모든 메시지는 이름 충돌이나 버그를 방지하기 위해 목록을 작성해서 관리하세요.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="#filters"&gt;filter&lt;/a&gt;에 데이터 포맷 로직이나 캡슐화가 필요한 경우에는 아래와 같이 의존선을 선언하시기 바랍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.controller(&amp;#39;myFormat&amp;#39;, function () {
  return function () {
    //body...
  };
});

module.controller(&amp;#39;MyCtrl&amp;#39;, [&amp;#39;$scope&amp;#39;, &amp;#39;myFormatFilter&amp;#39;, function ($scope, myFormatFilter) {
  //body...
}]);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;디렉티브&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;디렉티브의 이름은 lowerCamelCase를 사용하세요.&lt;/li&gt;
&lt;li&gt;link 함수에서 &lt;code&gt;$scope&lt;/code&gt; 대신 &lt;code&gt;scope&lt;/code&gt;를 사용하세요. complie이나 post/pre link 함수들에선 이미 함수가 불려졌을 때 넘어온 인수들이 정의되어있습니다. DI를 사용해 이것들을 변경할 수 없습니다. 이 스타일은 AngularJS 소스코드에서 사용하는 스타일입니다.&lt;/li&gt;
&lt;li&gt;여러분만의 특별한 전치사를 붙여서 사용하세요. 이는 Third-party 라이브러리와 이름 충돌을 방지해줍니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ng&lt;/code&gt;와 &lt;code&gt;ui&lt;/code&gt;를 전치사로 사용하지 마세요. 이 단어들은 AngularJS와 AngularJS UI에서 사용되는 전치사입니다.&lt;/li&gt;
&lt;li&gt;디렉티브를 통해서만 DOM 조작을 해주세요.&lt;/li&gt;
&lt;li&gt;재사용 가능한 컴포넌트를 만들려면 독립된 범위(scope)를 만들어주세요.&lt;/li&gt;
&lt;li&gt;디렉티브는 주석(comments)이나 클래스(clases)보단 요소(elements)나 속성(attributes)으로 사용하세요. 이는 코드의 가독성을 향상시켜줍니다.&lt;/li&gt;
&lt;li&gt;범위(scope)를 없앨 때는 &lt;code&gt;$scope.$on(&amp;#39;$destroy&amp;#39;, fn)&lt;/code&gt;를 사용하세요. 이러한 접근은 특히 third-party 플러그인을 디렉티브로 감싸서 사용할 때 유용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;필터&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;이름은 lowerCamelCase를 사용하세요&lt;/li&gt;
&lt;li&gt;필터는 가능한 한 가볍게 만들어주세요. 필터는 간혹 &lt;code&gt;$digest&lt;/code&gt; 루프 내에서 호출될 수 있기 때문에 느린 필터는 어플리케이션 전체를 느리게 만들 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;서비스&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;서비스명은 camelCase나 CamelCase로 작성.&lt;/li&gt;
&lt;li&gt;서비스엔 비지니스 로직을 캡슐화.&lt;/li&gt;
&lt;li&gt;비지니스 로직을 캡슐화하고 있는 서비스들은 &lt;code&gt;factory&lt;/code&gt; 대신에 &lt;code&gt;service&lt;/code&gt;를 선호합니다.&lt;/li&gt;
&lt;li&gt;세션 수준의 캐시는 &lt;code&gt;$cacheFactory&lt;/code&gt;를 사용하세요. 이는 요청(request)나 무거운 처리를 캐시하고 싶을 때 사용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;템플릿&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;문서가 반짝이는 현상을 방지하기 위해서 &lt;code&gt;{{}}&lt;/code&gt; 대신에 &lt;code&gt;ng-bind&lt;/code&gt;나 &lt;code&gt;ng-cloak&lt;/code&gt;를 사용하세요.&lt;/li&gt;
&lt;li&gt;템플릿에서는 복잡한 코드 사용을 가능한 자제.&lt;/li&gt;
&lt;li&gt;동적으로 src 속성을 사용해야한다면 &lt;code&gt;src&lt;/code&gt;를 &lt;code&gt;{{}}&lt;/code&gt;와 같이 사용하는 대신에 &lt;code&gt;ng-src&lt;/code&gt;를 사용하세요.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;style&lt;/code&gt;속성을 $scope에 정의된 문자열로 사용하고 싶을 때 &lt;code&gt;{{}}&lt;/code&gt;를 사용하는 대신에 &lt;code&gt;ng-style&lt;/code&gt;를 사용하면 $scope에 객체를 선언해 여러가지 속성을 한꺼번에 지정할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
$scope.divStyle = {
  width: 200,
  position: relative
};
...

&amp;lt;div ng-style=&amp;quot;divStyle&amp;quot;&amp;gt;IE에서도 작동하는 아름다운 스타일을 가진 div&amp;lt;/div&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;라우팅&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;view가 보여지기 전에 &lt;code&gt;resolve&lt;/code&gt;를 사용해 의존관계를 해결해주세요.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;테스트&lt;/h1&gt;

&lt;p&gt;TBD&lt;/p&gt;

&lt;h1&gt;기여&lt;/h1&gt;

&lt;p&gt;이 문서는 communty-driven을 지향하며, 문서에 대한 기여는 언제든 대환영입니다.
부족한 부분을 보충해주시거나 여러분이 사용하는 모국어로 문서를 번역해주셔도 좋습니다.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Rspec과 Guard를 활용한 루비 테스트 자동화</title>
    <link rel="alternate" href="http://blog.url.com/articles/2013-10-02-ruby-test-automation-with-rspec-and-guard/"/>
    <id>http://blog.url.com/articles/2013-10-02-ruby-test-automation-with-rspec-and-guard/</id>
    <published>2013-10-02T03:00:00Z</published>
    <updated>2014-01-18T16:38:51+00:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;루비 테스트로는 minitest와 Rspec이 많이 사용됩니다.. 저는 대부분 Rspec을 사용합니다만, 어느 쪽이건 이러한 테스트를 매번 직접 실행해주기는 매우 귀찮은 일입니다. 이러한 부분을 자동화하기 위해서 과거에는 Autotest 같은 툴이 사용되었습니다. Autotest는 특정 파일이 수정되면 테스트를 자동으로 실행하는 방식으로 작동합니다. 현재는 Autotest 대신에 Guard를 많이 사용하는데, Guard는 특정한 파일을 감시하다가 이러한 파일에 변화가 있을 때 특정한 명령어를 수행하는 좀 더 범용적인 툴이라고 생각하면 됩니다. 여기서는 Guard를 사용해 rspec 테스트를 자동화하는 법을 소개합니다.&lt;/p&gt;



&lt;h2&gt;Spring&lt;/h2&gt;

&lt;p&gt;먼저 테스트 속도 향상을 위해 Rails preloader인
&lt;a href="https://github.com/jonleighton/spring"&gt;spring&lt;/a&gt;을 설정해 두었습니다.
자세한 사항은 spring github 페이지를 참조하시면 됩니다. 간단한
사용법은 spring을 앞에 붙여주면 됩니다. 별도로 spring server 실행
명령어를 사용할 필요가 없으며, 명령어를 처음 실행할 때 자동으로
실행됩니다.&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h1&gt;spring 설정 전 테스트&lt;/h1&gt;

&lt;h1&gt;rvm 사용시 bundle exec 는 생략하셔도 됩니다.&lt;/h1&gt;

&lt;p&gt;bundle exec rake rspec&lt;/p&gt;

&lt;h1&gt;spring 설정 후 테스트&lt;/h1&gt;

&lt;p&gt;bundle exec spring rake rspec
```&lt;/p&gt;

&lt;p&gt;테스트를 지속적으로 실행하게 되므로 spring을 사용하는 편이 압도적으로
속도가 빠릅니다. 문제가 있다면 가끔씩 spring 서버에 문제가 생겨서
제대로 작동을 안 하는 경우가 있는데, 그럴 경우엔&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
bundle exec spring stop
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;을 실항해서 spring을 종료하시고 다시 명령어를 실행시켜주시면됩니다.&lt;/p&gt;

&lt;h2&gt;Guard&lt;/h2&gt;

&lt;p&gt;단순히 spec 폴더의 파일들을 테스트 하는 것은 rake면 충분합니다만,
작업과정의 변경사항에 대한 자동적인 테스트를 실행시키기 위해서는
&lt;a href="https://github.com/guard/guard"&gt;Guard&lt;/a&gt;가 필요합니다. Guard는 watch와
비슷한 역할을 해주는 프로그램으로 파일을 감시하다가 특정 파일이
변경되면 거기에 해당하는 스크립트를 실행시켜줍니다. 이러한 세팅은
Guardfile에 들어가 있으며 현재는 rspec(+spring)에 대해 기본설정이
적용되어 있습니다. 아래의 명령어로 초기화합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
bundle exec guard init rspec
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;guard는 spring과는 별개로 작동하고 guard에서 파일 변화를 캐치해서
테스트를 실행할 때만 내부적으로 spring을 사용합니다. spring과
연동시켜주기 위해서 아래의 설정을 Guardfile에 추가해줍니다.&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h1&gt;default&lt;/h1&gt;

&lt;p&gt;guard :rspec do&lt;/p&gt;

&lt;h1&gt;after&lt;/h1&gt;

&lt;p&gt;guard :rspec, :spring =&amp;gt; true do
```&lt;/p&gt;

&lt;p&gt;따라서 Rails 어플리케이션의 루트에서 아래의 명령어로 실행시키시면
됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
bundle exec guard
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;보통은 tmux나 screen에서 하나의 윈도우를 할당해놓고 사용하는 게
일반적입니다. 이렇게 해두면 다른 윈도우나 텍스트 에디터에서 Rails
어플리케이션 파일이나 테스트 파일을 변경하면 guard가 자동으로 캐치해서
해당하는 부분의 spec 테스트를 실행시켜줍니다. 이런 식으로 테스트
결과를 계속 확인하면서 작업할 수 있습니다. 또한 guard 프로그램 내에서
여러가지 명령어를 실행시킬 수 있으며, 명령어 없이 엔터를 눌러주면 전체
테스트를 실행시켜 줍니다. guard는 단순히 rspec 자동화를 위해 만들어 진
gem은 아니라, cucumber나 서버 재실행 등 다른 작업을 실행시키는 데도
확장해서 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;테스트 결과에 대한 알림은 Ubuntu 같은 경우는 notification을 시스템
쪽으로 자동으로 주는 것 같고, Mac 같은 경우는 growl과 연동해서
사용하는 게 보통입니다. 다양한 notification 지원에 대해서는 Guard
github 페이지에 좀 더 자세히 나와있으니 참조하시면 될 것 같습니다.&lt;/p&gt;

&lt;h2&gt;Rspec setting&lt;/h2&gt;

&lt;p&gt;rspec을 실행하는 데 기본 옵션 설정은 HOME 디렉토리의 .rspec 파일이나,
Rails 어플리케이션 루트의 .rspec 파일에 기록합니다.&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h1&gt;테스트 결과에 색을 입혀 출력해줍니다.&lt;/h1&gt;

&lt;p&gt;--colour&lt;/p&gt;

&lt;h1&gt;테스트 실행 결과에 테스트 이름을 같이 보여줍니다. rspec을 사용하면&lt;/h1&gt;

&lt;p&gt;기본적으로 테스트를 .으로 출력하는데, 이게 불편하실 때 사용하시면
  됩니다.
--format d
```&lt;/p&gt;

&lt;h2&gt;spec_helper.rb&lt;/h2&gt;
</content>
  </entry>
</feed>
