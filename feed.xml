<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nacyot의 프로그래밍 이야기</title>
  <subtitle>Nacyot의 프로그래밍 이야기</subtitle>
  <id>http://blog.nacyot.com/</id>
  <link href="http://blog.nacyot.com/"/>
  <link href="http://blog.nacyot.com/feed.xml" rel="self"/>
  <updated>2014-02-10T15:16:00Z</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>도커(Docker) 튜토리얼 : 0.8 맥에서 설치하기</title>
    <link rel="alternate" href="http://blog.nacyot.com/articles/2014-02-11-dokcer-08-on-macosx/"/>
    <id>http://blog.nacyot.com/articles/2014-02-11-dokcer-08-on-macosx/</id>
    <published>2014-02-10T15:16:00Z</published>
    <updated>2014-02-16T15:50:24+00:00</updated>
    <author>
      <name>nacyot(Daekwon Kim)</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a href="http://docker.io"&gt;도커&lt;/a&gt;는 리눅스 위에서 격리된 또 다른 리눅스 환경을 구축할 수 있도록 해주는 가상화 어플리케이션입니다. 기존의 가상화 어플리케이션에서 하드웨어 전체를 가상화하는 것과 달리 리눅스 컨테이너를 활용하고 있는 도커는 아주 빠르고 쉽게 가상화 환경을 사용할 수 있도록 해줍니다. 이전 &lt;a href="http://blog.nacyot.com/articles/2014-01-27-easy-deploy-with-docker/"&gt;도커(Docker) 소개 글&lt;/a&gt;을 올린 바 있습니다만, 바로 얼마 전 도커가 0.8로 업데이트되었습니다. 0.8에서 가장 큰 변화중 하나는 맥을 지원하는 부분입니다. 여기서는 어떤 방식으로 맥을 지원하는 지 알아보고 실제로 설치하는 법에서 다루도록 하겠습니다.&lt;/p&gt;



&lt;h2&gt;TL;DR, 맥에서 바로 도커 시작하기&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Virtual 박스 설치&lt;/li&gt;
&lt;li&gt;docker, boot2docker 설치&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;
$ brew tap homebrew/binary
$ brew install docker boot2docker
&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;boot2docker 실행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;
export DOCKER_HOST=tcp://¶
$ ./boot2docker init
$ ./boot2docker up
&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;도커 컨테이너 실행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;
$ docker pull ubuntu
$ docker run -rm -i -t ubuntu:latest /bin/bash
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;맥에서 도커를 실행하는 원리&lt;/h2&gt;

&lt;p&gt;도커는 기본적으로 리눅스 컨테이너(이하 lxc)를 지원하는 운영체제만 사용할 수 있습니다. 처음에는 우분투만 지원을 했습니다만 현재는 좀 더 다양한 운영체제를 지원하도록 확장해나가는 과정에 있습니다. 하지만 원론적으로 lxc를 지원하고 있지 않은 윈도우나 맥에서는 도커를 사용할 수 없습니다. &lt;/p&gt;

&lt;p&gt;하지만 엄밀히 말하면 이전에도 맥이나 윈도우에서 도커를 사용하는 것이 불가능한 것은 아니었습니다. 그러면 어떻게 설치를 하는지, 간단히 말해 &lt;a href="http://www.vagrantup.com/"&gt;Vagrant&lt;/a&gt;나 아예 별개의 가상화 어플리케이션을 통해서 리눅스 운영체제를 실행시키는 방식이었습니다. 이렇나 방식이 당연히 가능한 건, 아예 OS를 lxc를 지원하는 리눅스를 가상 머신으로 올려놓기 때문입니다. 물론 이렇게도 도커를 사용하는 것이 불가능한 것은 아닙니다만, VM의 성능도 성능이고 리눅스 운영체제에 비해서 &amp;#39;한 다리&amp;#39; 건너서 사용한다는 인상을 지우기는 어렵습니다.&lt;/p&gt;

&lt;p&gt;그런데 &lt;a href="http://blog.docker.io/2014/02/docker-0-8-quality-new-builder-features-btrfs-storage-osx-support/"&gt;도커 블로그에선 0.8 발표&lt;/a&gt;와 함께 맥의 공식 지원을 언급하고 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Today we are happy to introduce Docker 0.8, with a focus on Quality and 3 notable features: new builder instructions, a new BTRFS storage driver, and official support for Mac OSX. You can see the full Changelog on the repository, and read below for details on each feature.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그렇다면 여기서 공식으로 지원한다는 얘기는 무슨 얘기일까요? 맥이 lxc를 지원하지 않는다면 네이티브에서 도커를 실행한다는 건 근본적으로 불가능합니다. 그렇다면 여전히 근본적인 해결책은 아닙니다만, 여기서 공식지원이 의미하는 바는 기존에 VM을 사용하는 부하를 극도로 줄인 환경을 도커가 직접 제공해준다는 걸 의미합니다. 가상 머신은 여전히 올라갑니다. 이 때 사용되는 운영체제가 &lt;a href="https://github.com/steeve/boot2docker"&gt;boot2docker&lt;/a&gt;라는 단지 도커만을 위한 초경량 리눅스 &lt;a href="http://tinycorelinux.net/"&gt;Tiny Core Linux&lt;/a&gt; 배포판 중 하나입니다. 이 운영체제는 RAM에서 작동하며 매우 적은 용량에 단 몇 초만에 부팅이 가능합니다(그렇다고 이야기하고 있습니다). 도커 컨테이너 만큼은 아니겠지만 매우 빠릅니다. 이러한 가상 머신 부분의 경량화와 맥 클라이언트에서 Docker 명령어를 직접 사용할 수 있게 함으로써, 맥에서 네이티브나 다름없는 도커 지원을 실현했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img alt="docker2boot" src="https://github-camo.global.ssl.fastly.net/fd2fda3c0d55a0a63873f4221ddbe2f1dda145c5/687474703a2f2f692e696d6775722e636f6d2f68497775644b332e676966" /&gt;&lt;/p&gt;

&lt;p&gt;네이티브 환경에 비하면 약간의 불만족은 남아있겠습니다만, 그럼에도 불구하고 개발환경을 구축하는 데는  손색이 없습니다. &lt;/p&gt;

&lt;h2&gt;맥에서 boot2docker를 활용한 도커 설치&lt;/h2&gt;

&lt;p&gt;네, 그렇다면 실제로 설치를 해보도록 하겠습니다. &lt;/p&gt;

&lt;p&gt;먼저 docker2boot를 사용하기 위해서는 &lt;a href="https://www.virtualbox.org/wiki/Downloads"&gt;VirtualBox&lt;/a&gt;를 설치해야합니다. 공식 사이트에서 MacOSX용 dmg 파일을 다운로드 받아 설치 과정을 진행해주시기 바랍니다.&lt;/p&gt;

&lt;p&gt;도커 공식 사이트에서는 &lt;a href="http://docs.docker.io/en/latest/installation/mac/"&gt;맥에서 설치를 위한 문서&lt;/a&gt;를 제공하고 있으니 참조하시기 바랍니다. 먼저 boot2docker를 다운로드 받고 실행권한을 추가해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ mkdir ~/bin
$ cd ~/bin
$ curl https://raw.github.com/steeve/boot2docker/master/boot2docker &amp;gt; boot2docker
$ chmod +x boot2docker
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;다음으로 도커를 다운로드 받고 실행권한을 추가해줍니다. 이 때 DOCKER_HOST를 추가하는 가상 머신의 도커에 접속하기 위함입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ curl -o docker http://get.docker.io/builds/Darwin/x86_64/docker-latest
$ chmod +x docker
$ export DOCKER_HOST=tcp://
$ sudo cp docker /usr/local/bin/
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;도커와 boot2docker 설치 과정은 homebrew를 통해서도 진행이 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ brew tap homebrew/binary
$ brew install docker boot2docker
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;다음으로 boot2docker를 실행시킵니다. 이 과정을 거치기 전에 VirtualBox를 설치했는지 꼭 확인하시기 바랍니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ ./boot2docker init
$ ./boot2docker up
[2014-02-10 23:40:41] Starting boot2docker-vm...
[2014-02-10 23:41:01] Started.
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;맥북 에어에서 실제로 걸린 시간은 이미지 다운로드하는데 30여초, 기동하는데 20여초가 걸렸습니다. 설치는 끝이났습니다. 이제 설치가 잘 되었는지 버전 출력을 해보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker version
Client version: 0.8.0
Go version (client): go1.2
Git commit (client): cc3a8c8
Server version: 0.8.0
Git commit (server): cc3a8c8
Go version (server): go1.2
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;도커 실행 테스트&lt;/h2&gt;

&lt;p&gt;그렇다면 정말로 가상머신이 잘 올라간 상태로 도커가 사용 가능한지 테스트해보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker pull ubuntu
Pulling repository ubuntu
eb601b8965b8: Download complete
9cc9ea5ea540: Download complete
9f676bd305a4: Download complete
9cd978db300e: Download complete
5ac751e8d623: Download complete
511136ea3c5a: Download complete
f323cf34fd77: Download complete
1c7f181e78b9: Download complete
6170bb7b0ad1: Download complete
321f7f4200f4: Download complete
7a4f87241845: Download complete
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이미지 pull도 한 번 해보고,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu              13.10               9f676bd305a4        6 days ago          178 MB
ubuntu              saucy               9f676bd305a4        6 days ago          178 MB
ubuntu              13.04               eb601b8965b8        6 days ago          166.5 MB
ubuntu              raring              eb601b8965b8        6 days ago          166.5 MB
ubuntu              12.10               5ac751e8d623        6 days ago          161 MB
ubuntu              quantal             5ac751e8d623        6 days ago          161 MB
ubuntu              10.04               9cc9ea5ea540        6 days ago          180.8 MB
ubuntu              lucid               9cc9ea5ea540        6 days ago          180.8 MB
ubuntu              12.04               9cd978db300e        6 days ago          204.4 MB
ubuntu              latest              9cd978db300e        6 days ago          204.4 MB
ubuntu              precise             9cd978db300e        6 days ago          204.4 MB
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;pull 해온 이미지 리스트도 한 번 보고, 컨테이너 리스트도 출력해보죠.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS             PORTS               NAMES
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;오오 pull도 되고 images 명령어도 먹는 걸 볼 수 있습니다. 아직 실행한 컨테이너는 없으니 아무것도 뜨지 않습니다. 일단 작동하고 있는 것 같습니다. 마지막으로 컨테이너를 올려보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker run -rm -i -t ubuntu:latest /bin/bash
root@e616c4c3fd53:/# 
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;컨테이너 안의 쉘이 실행된 화면을 바로 확인하실 수 있습니다.&lt;/p&gt;

&lt;h2&gt;트러블 슈팅&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
export DOCKER_HOST=tcp://¶
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;명령어를 통해 DOCKER_HOST를 반드시 설정해줘야합니다. 이 설정을 하지 않으면&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker images
2014/02/10 23:48:19 dial unix /var/run/docker.sock: no such file or directory
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;와 같은 에러가 발생합니다. 이는 도커가 기본적으로 로컬 머신 상의 /var/run/docker.sock를 통해서 작동하기 때문입니다. 이를 가상 머신에서 가동중인 docker와 바로 연동할 수 있도록 &lt;code&gt;tcp://&lt;/code&gt;로 연결하도록 설정해주는 것입니다. 같은 의미로 &lt;code&gt;export DOCKER_HOST=localhost&lt;/code&gt;를 실행해도 됩니다.&lt;/p&gt;

&lt;p&gt;또한 &lt;code&gt;./boot2docker&lt;/code&gt; 명령어를 통해서 &lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ ./boot2docker
Usage ./boot2docker {init|start|up|pause|stop|restart|status|info|delete|ssh|download}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;boot2docker를 재실행하거나 멈추는 작업을 수행할 수 있습니다.&lt;/p&gt;

&lt;h2&gt;정리&lt;/h2&gt;

&lt;p&gt;이제 무거운 가상 머신 없이도 맥에서 도커를 부담없이 설치하고 사용해볼 수 있습니다 &amp;gt;_&amp;lt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>깃허브(Github) 후크 API와 Slack에 알림 전달하기</title>
    <link rel="alternate" href="http://blog.nacyot.com/articles/2014-01-30-github-hook-api-slack-sample/"/>
    <id>http://blog.nacyot.com/articles/2014-01-30-github-hook-api-slack-sample/</id>
    <published>2014-01-30T08:30:00Z</published>
    <updated>2014-02-16T15:50:24+00:00</updated>
    <author>
      <name>nacyot(Daekwon Kim)</name>
    </author>
    <content type="html">&lt;p&gt;후크(hook)는 특정 이벤트나 작업이 진행될 때 자동적으로 다른 스크립트를 실행시켜줍니다. 깃(Git)에서는 기본적으로 후크를 지원하고 있습니다. 저장소 폴더의 &lt;code&gt;.git/hooks&lt;/code&gt;에서 샘플 스크립트와 사용할 수 있는 후크 이벤트들을 확인해볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;깃허브(&lt;a href="http://github.com"&gt;Github&lt;/a&gt;)에서도 이러한 후크 기능을 지원하고 있으며 깃허브와 연동된 부분에 대한 이벤트를 추가적으로 지원하고 있습니다. 대부분의 경우 서비스 후크 기능을 통해서 다른 서비스와의 통합을 쉽게 할 수록 지원하고 있으며, 재미있게도 이렇게 다른 서비스와 통합하는 부분도 공개가 되어있어 관심이 있으시면 &lt;a href="https://github.com/github/github-services"&gt;실제 코드&lt;/a&gt;를 확인해볼 수도 있습니다. 특히 현재는 웹후크(Webhook) 기능을 추가되어 깃허브에서 서비스 후크를 지원하지 않는 서비스와도 중간에서 매개할 수 있는 서버나 통합기능이 있다면 얼마든지 활용가능합니다.&lt;/p&gt;



&lt;p&gt;후크란 일반적인 API와는 반대 방향으로 작동합니다. 예를 들어 보통 API를 호출하면 어떤 정보를 되돌려줍니다만, 후크는 등록이 되어있으면 어떤 이벤트가 발생할 때 거꾸로 깃허브에서 내가 등록한 Webhook URL로 정보를 보내줍니다. 여기서는 깃허브 Hook API를 조작하는 방법에 대해서 간략히 살펴보고 하나의 예제로 깃헙에서 보내주는 웹후크 알림을 처리할 수 있는 간단한 &lt;a href="http://www.padrinorb.com/"&gt;Padrino&lt;/a&gt; 서버를 만들어 &lt;a href="https://slack.com/"&gt;슬랙(Slack)&lt;/a&gt;라는 협엄&amp;amp;채팅 서비스로 알림을 보내는 과정을 다뤄보겠습니다.&lt;/p&gt;

&lt;h2&gt;깃허브(Githbu) 후크 API&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://developer.github.com/v3/repos/hooks/"&gt;Hooks | GitHub API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;API의 자세한 사항은 깃허브 API 문서에서 확인할 수 있습니다. 여기서는 깃허브에서 지원하는 이벤트 종류와 웹후크를 추가했을 때 어떤 이벤트들이 추가되는지 살펴보겠습니다.&lt;/p&gt;

&lt;h3&gt;지원하는 후크 이벤트 종류&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;push : 저장소에 푸쉬가 들어왔을 때 발생. 기본 이벤트&lt;/li&gt;
&lt;li&gt;issues: 이슈가 열리거나 닫혔을 때 발생.&lt;/li&gt;
&lt;li&gt;issue_comment: 이슈에 코멘트가 달렸을 때 발생.&lt;/li&gt;
&lt;li&gt;commit_comment: 커밋에 코멘트가 달렸을 때 발생.&lt;/li&gt;
&lt;li&gt;create: 저장소나 브랜치, 태그가 추가되었을 때 발생.&lt;/li&gt;
&lt;li&gt;delete: 브랜치나, 태그가 삭제되었을 때 발생.&lt;/li&gt;
&lt;li&gt;pull_request: 풀리퀘스트가 열리거나 닫혔을 때, 동기화 되었을 때 발생.&lt;/li&gt;
&lt;li&gt;pull&lt;em&gt;request&lt;/em&gt;review_comment: 풀리퀘스트 리뷰 안의 커밋에 커멘트가 달렸을 때.&lt;/li&gt;
&lt;li&gt;gollum: 위키가 업데이트되었을 때 발생.&lt;/li&gt;
&lt;li&gt;watch: 사용자가 저장소를 와치했을 때 발생.&lt;/li&gt;
&lt;li&gt;release: 릴리즈가 추가되었을 때 발생.&lt;/li&gt;
&lt;li&gt;fork: 저장소가 포크되었을 때 발생.&lt;/li&gt;
&lt;li&gt;member: Organization의 저장소가 아닐 때 멤버가 추가되면 발생.&lt;/li&gt;
&lt;li&gt;public: 저장소가 비공개에서 공개로 전환되었을 때 발생.&lt;/li&gt;
&lt;li&gt;team_add: 저장소에 팀이 추가되었거나 변경되었을 때 발생.&lt;/li&gt;
&lt;li&gt;status: API를 통해 커밋의 상태가 변경되었을 때 발생.&lt;/li&gt;
&lt;li&gt;deployment: API를 통해 저장소의 새로운 배포가 생성되었을 때 발생.&lt;/li&gt;
&lt;li&gt;deployment_status: API를 통해서 저장소의 특정 배포의 상태가 변경되었을 때 발생.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이벤트가 발생했을 때 깃허브에서 보내주는 내용은 &lt;a href="http://developer.github.com/v3/activity/events/types/#deploymentevent"&gt;Event Types&lt;/a&gt;에서 자세히 확인할 수 있으며 배포에 관한 부분은 &lt;a href="http://developer.github.com/v3/repos/deployments/#list-deployment-statuses"&gt;Deployments API&lt;/a&gt;를 확인하시기 바랍니다.&lt;/p&gt;

&lt;h3&gt;저장소에 웹후크 등록하고 상태 확인하기&lt;/h3&gt;

&lt;p&gt;깃허브에서 저장소에 웹후크나 서비스 후크를 등록하기 위해서는 저장소의 관리 권한이 있어야합니다. 먼저 저장소의 오른쪽에 보이는 Settings 메뉴에 들어갑니다.&lt;/p&gt;

&lt;p&gt;&lt;img alt="Github settings" src="../../images/2014-01-30-github-hook-api-slack-sample/settings.png" /&gt;&lt;/p&gt;

&lt;p&gt;들어와서 왼쪽에 보시면 Service Hooks라는 메뉴를 찾을 수 있습니다. Service Hooks 누르면 Github에서 바로 통합 가능한 서비스 리스트들을 전부 확인할 수 있습니다. 채팅 서비스인 &lt;a href="http://hipchat.com/"&gt;Hipchat&lt;/a&gt;을 비롯해, 빌드 서비스인 &lt;a href="https://circleci.com/"&gt;CircleCI&lt;/a&gt;, &lt;a href="https://travis-ci.org/"&gt;Travis&lt;/a&gt;, 코드 매트릭스 관리 서비스인 &lt;a href="https://codeclimate.com/?v=original"&gt;Code Climate&lt;/a&gt;, 테스트 커버리지 리포트 서비스인 &lt;a href="https://coveralls.io/"&gt;Coveralls&lt;/a&gt;등 다양한 서비스를 지원하고 있습니다. 여기서는 맨 위에 있는 Webhook URLs를 사용하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img alt="Webhook" src="../../images/2014-01-30-github-hook-api-slack-sample/webhook.png" /&gt;&lt;/p&gt;

&lt;p&gt;Webhook URLs를 클릭하시면 이벤트가 발생했을 때 정보를 받을 URL을 지정할 수 있습니다. 아직 후크 메시지를 받아 처리할 수 있는 서버가 없으므로 여기서는 서버를 등록하면 어떤 식으로 메시지가 오는 지, 어떤 이벤트들을 등록되어있는지 보여드리도록 하겠습니다. Webhook URLs에 &lt;code&gt;notifier.nacyot.com&lt;/code&gt;라는 Slack에 깃허브 저장소의 변경사항을 전달해주는 어플리케이션을 등록했다고 가정해보죠. &lt;/p&gt;

&lt;p&gt;깃허브에서 저장소에 등록된 후크 정보를 확인하는 API URL은 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
https://api.github.com/repos/&amp;lt;계정이름&amp;gt;/&amp;lt;저장소이름&amp;gt;/hooks
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;curl&lt;/code&gt;을 통해서 Github에 Hook가 어떻게 등록되어있는지 요청을 보내보도록하겠습니다. &lt;code&gt;-u&lt;/code&gt; 플래그 뒤로는 인증을 할 계정이름을 넣어줍니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
Commend &amp;gt; curl -u nacyot https://api.github.com/repos/nacyot/slack_notifier/hooks
Enter host password for user &amp;#39;nacyot&amp;#39;:
[
  {
    &amp;quot;url&amp;quot;: &amp;quot;https://api.github.com/repos/nacyot/bbapi/hooks/1829382&amp;quot;,
    &amp;quot;test_url&amp;quot;: &amp;quot;https://api.github.com/repos/nacyot/bbapi/hooks/1829382/test&amp;quot;,
    &amp;quot;id&amp;quot;: 1829382,
    &amp;quot;name&amp;quot;: &amp;quot;web&amp;quot;,
    &amp;quot;active&amp;quot;: true,
    &amp;quot;events&amp;quot;: [
      &amp;quot;push&amp;quot;,
    ],
    &amp;quot;config&amp;quot;: {
      &amp;quot;url&amp;quot;: &amp;quot;notifier.nacyot.com&amp;quot;,
      &amp;quot;content_type&amp;quot;: &amp;quot;form&amp;quot;,
      &amp;quot;insecure_ssl&amp;quot;: &amp;quot;1&amp;quot;
    },
    &amp;quot;last_response&amp;quot;: {
      &amp;quot;code&amp;quot;: 504,
      &amp;quot;status&amp;quot;: &amp;quot;timeout&amp;quot;,
      &amp;quot;message&amp;quot;: &amp;quot;Service Timeout&amp;quot;
    },
    &amp;quot;updated_at&amp;quot;: &amp;quot;2014-01-28T01:29:02Z&amp;quot;,
    &amp;quot;created_at&amp;quot;: &amp;quot;2014-01-26T02:27:38Z&amp;quot;
  }
]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;다음과 같은 응답이 되돌아 옵니다. 이는 현재 등록된 후크의 URL과 어떤 이벤트가 등록되어있는지를 비롯한 여러가지 정보를 담고 있습니다. 특히 주목할 부분은 &lt;code&gt;id&lt;/code&gt;와 &lt;code&gt;events&lt;/code&gt;그리고 &lt;code&gt;url&lt;/code&gt; 부분입니다. 웹에서 지정한대로 정상적으로 등록이 된 걸 알 수 있습니다. 단, 웹에서 등록을 하면 기본 이벤트인 &lt;code&gt;push&lt;/code&gt; 이벤트밖에 등록이 되지 않습니다. 그렇다면 이슈에 관련된 이벤트나 위키가 수정되었을 때 알림을 받고자 한다면 어떻게 해야할까요?&lt;/p&gt;

&lt;p&gt;여기서는 마찬가지로 &lt;code&gt;curl&lt;/code&gt;을 사용해 새로운 이벤트를 등록해보겠습니다. 여기서 등록할 이벤트는 &lt;code&gt;issue&lt;/code&gt;, &lt;code&gt;issue_comment&lt;/code&gt;, 그리고 위키 업데이트를 알려주는 &lt;code&gt;gollum&lt;/code&gt; 이벤트입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
curl -u nacyot https://api.github.com/repos/nacyot/slack_notifier/hooks/1829382 -X PATCH -d &amp;#39;{&amp;quot;add_events&amp;quot;: [&amp;quot;issue&amp;quot;, &amp;quot;issue_comment&amp;quot;, &amp;quot;gollum&amp;quot;] }&amp;#39;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;위에서 후크 정보를 조회했던 &lt;code&gt;curl&lt;/code&gt; 정보를 참고로 적당한 형태로 바꿔주시기 바랍니다. 특히 여기서는 &lt;code&gt;/hooks/&lt;/code&gt; 뒤에 앞서서 조회했던 후크의 &lt;code&gt;id&lt;/code&gt; 값을 집어넣어줘야합니다. 다시 처음 url로 후크 정보를 조회해보면 정상적으로 이벤트들이 추가된 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
...
    &amp;quot;events&amp;quot;: [
      &amp;quot;push&amp;quot;,
      &amp;quot;issue&amp;quot;,
      &amp;quot;issue_comment&amp;quot;,
      &amp;quot;gollum&amp;quot;
    ],
...
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이제 저장소에서 이슈와 관련 이벤트가 발생하거나 위키에 페이지가 추가되거나 업데이트될 때 알림이 오게 됩니다. 이번엔 실제로 알림이 오는 것을 확인해보겠습니다. 위키 페이지를 하나 생성해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img alt="Creating Wiki page" src="../../images/2014-01-30-github-hook-api-slack-sample/wiki.png" /&gt;&lt;/p&gt;

&lt;p&gt;이번엔 &lt;code&gt;notifier.nacyot.com&lt;/code&gt;에 요청이 들어오는지 확인해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
07:15:35 web.1  |   DEBUG -      POST (1.6938s) / - 200 OK
07:15:35 web.1  | 192.30.252.54 - - [30/Jan/2014 07:15:35] &amp;quot;POST / HTTP/1.1&amp;quot; 200 - 1.6956
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;정상적으로 들어오네요. 네, 앞서서 이야기했듯이 이 서버가 해주는 역할은 깃허브로부터 후크를 받고 이를 Slack이라는 채팅 서비스에 연결해주는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img alt="Slack Room" src="../../images/2014-01-30-github-hook-api-slack-sample/github_slack.png" /&gt;&lt;/p&gt;

&lt;p&gt;채팅방에도 메시지가 잘 들어오는 것을 알 수 있습니다. (시간 차이는 시간 설정 때문에 9시간 차이가 나서 그렇습니다)&lt;/p&gt;

&lt;h2&gt;Slack과 깃허브 저장소 이벤트 통합&lt;/h2&gt;

&lt;p&gt;약간 순서가 거꾸로된 듯한 느낌이 들기도 합니다만, 여기서부터는 위에서 다룬 Slack에 메시지를 전달하는 서버에 대해서 다루도록 하겠습니다. 위에서 다룬 이벤트의 종류만 봐도 알 수 있습니다만, 의외로 Github에서는 다양한 이벤트들을 지원하고 있다는 것을 알 수 있습니다. 그리고 이러한 이벤트들이 깃허브 생태계를 구성하는 강력한 원동력이 되고 있습니다. 깃허브에서 서비스 후크로 바로 통합할 수 있는 서비스라면 두 서비스 간의 통합 기능을 이용하는 게 가장 편리합니다. 하지만 원하는 기능을 직접 구현하고 싶다거나 아직 서비스 후크가 갖춰지지 않은 서비스와 통합을 하려는 경우엔 직접 깃허브에서 보내는 메시지를 처리해줄 서버를 만들 필요가 있습니다.&lt;/p&gt;

&lt;p&gt;예를 들어서 제가 속해있는 Remotty 팀에서는 지금까지 힙챗(Hipchat)이라는 협업 채팅 툴을 사용해왔습니다만, 최근에 공개된 Slack이라는 서비스로 갈아탈 준비를 하고 있습니다.[^1] 하지만 깃허브과 통합을 하는데 약간의 애로사항이 있어서 이전을 포기했습니다. 얼마 전까지만 해도 Webhook을 통해서 Slack 서비스를 연동하면 커밋이 푸쉬되는 알림밖에는 전해주질 않았습니다. Hipchat 같은 경우는 깃허브에서 다루는 거의 모든 이벤트를 전달해줍니다. 특히 이슈와 관련된 부분도 필수적이고, 위키를 적극 사용하고 있었기에 이런 알림이 비활성화되는 것은 치명적인 단점으로 부각될 수밖에 없었습니다. 그리고 조금 더 올라가보면 바로 그런 통합이 가능했기 때문에 Hipchat을 사용하기로 했었으니까요.&lt;/p&gt;

&lt;p&gt;이러한 문제에 대해서 슬랙 쪽 통합 방식이 최근에 변경되면서 현재는 이슈와 풀리퀘스트 부분의 알림을 보내주도록 추가가 되었습니다. 원래는 Slack의 hook_url을 직접 추가하는 방식으로 통합을 했습니다만, 최근에는 Github 인증을 하면 Slack에서 hook url을 추가해주고 이슈와 풀리퀘스트 관련 이슈들을 더해줍니다. 이러한 약간의 변화가 다시 슬랙으로 넘어가자는 의견에 힘을 실어주었습니다. 하지만 여전히 위키를 지원해주지 않는 문제가 남아있었습니다.&lt;/p&gt;

&lt;p&gt;[^1]: 현재 완전히 이전한 상태입니다.&lt;/p&gt;

&lt;p&gt;금방 지원해 줄 것 같기는 했습니다만, 당장 필요했던 관계로 직접 알림을 보내주는 서버를 만들기로 했습니다. 현재 루비의 Padrino[^2]로 만든 깃허브에서 위키 변경 사항 알림 &lt;a href="https://github.com/nacyot/slack_notifier"&gt;서버를 slack_notifier&lt;/a&gt;라는 이름으로 올려둔 상태입니다. 이 서버가 하는 일은 정말 딱 위키 알림을 Github에서 받고 Slack으로 전달해주는 일뿐입니다.&lt;/p&gt;

&lt;p&gt;[^2]: Padrino는 Sinatra를 확장한 경량 웹프레임워크입니다.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/nacyot/slack_notifier/blob/master/app/controllers/hook.rb"&gt;로직&lt;/a&gt;도 정말 단순합니다. &lt;code&gt;hook_controller&lt;/code&gt;에 다음과 같은 내용이 들어가있을 뿐입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
Slack::Post.configure(
                      subdomain: params[:subdomain],
                      token: params[:token],
                      username: &amp;quot;Github&amp;quot;
                      )
Slack::Post.post &amp;quot;#{login}#{action} &amp;lt;#{url}|#{title}&amp;gt;&amp;quot;, &amp;quot;#&amp;quot; + params[:room]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;내부적으로 [slack-post][slack-post]라는 젬을 사용해 깃허브에서 서버의 특정 페이지에 접근하면(이벤트를 알려주면), Slack에 메시지를 보내주는 방식입니다. 현재는 서버에 데이터를 저장하는 기능이 없어서 token과 메시지를 전달할 곳을 전부 Url 인자로 받아서 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;자, 그럼 직접 사용해보도록 하죠.&lt;/p&gt;

&lt;h3&gt;도커(Docker) X slack_notifier&lt;/h3&gt;

&lt;p&gt;루비 서버를 올리는 게 어려운 일은 아닙니다만, 부가적인 처리 과정이나 설명해질 부분이 많아지므로 해당하는 부분에 대해서는 다루지 않도록 하겠습니다. 여기서는 이러한 과정을 생략하기 위해 이전 포스트에서 이야기했던 [도커(Docker)]를 출동시키겠습니다. 빠밤.&lt;/p&gt;

&lt;p&gt;먼저 도커를 설치합니다. (여기서는 우분투를 가정합니다. 필요한 경우 가상머신이나 클라우드 서비스를 사용하시기 바랍니다. Remotty 팀에서도 SKT에서 지원받고 있는 VM을 활용해 개발 지원 서비스들을 운영중에 있습니다)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ curl -s https://get.docker.io/ubuntu/ | sudo sh
...
$ docker --version
Client version: 0.7.6
Go version (client): go1.2
Git commit (client): bc3b2ec
Server version: 0.7.6
Git commit (server): bc3b2ec
Go version (server): go1.2
Last stable version: 0.7.6
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;다음으로 어플리케이션을 클론하고 &lt;code&gt;docker build&lt;/code&gt;를 수행합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ git clone https://github.com/nacyot/slack_notifier
$ docker build -t nacyot/slack_notifier:latest -q=true ./slack_notifier
...
$ docker images
REPOSITORY              TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
nacyot/slack_notifier   latest              d35792687e8c        4 days ago          751.1 MB
ubuntu                  12.04               8dbd9e392a96        9 months ago        128 MB
ubuntu                  12.10               b750fe79269d        10 months ago       175.3 MB
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker imaegs&lt;/code&gt; 명령어로 정상적으로 빌드된 것을 확인할 수 있습니다. 이제 생성한 이미지로부터 실제 어플리케이션 컨테이너를 실행시킵니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker run -d -p 4000:4000 nacyot/slack_notifier:latest
7c42ae39691c
$ docker ps
CONTAINER ID        IMAGE                         COMMAND                CREATED             STATUS              PORTS                    NAMES
7c42ae39691c        nacyot/slack_notifier:first   /bin/sh -c bundle ex   4 days ago          Up 2 days           0.0.0.0:4000-&amp;gt;4000/tcp   slack_notifier  
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker ps&lt;/code&gt;를 통해서 컨테이너가 정상적으로 실행되고 있는 것을 확인할 수 있습니다. 이제 깃허브에 WebHook을 등록할 차례입니다. 그 전에 먼저 Slack 쪽에서 서비스 등록을 하고 토큰을 생성할 필요가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
http://&amp;lt;SLACK_SUBDOMAI&amp;gt;.slack.com/services/new/incoming-webhook
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;위 주소로 접속하시면 incoming-webhook을 바로 등록할 수 있습니다. &lt;code&gt;Add integration&lt;/code&gt; 버튼을 누르면 오른쪽에 토큰 정보가 출력됩니다. 토큰 정보를 가지고 아래 URL을 완성합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
http://&amp;lt;서버주소&amp;gt;:4000/hook?subdomain=&amp;lt;SLACK_SUBDOMAIN&amp;gt;&amp;amp;token=&amp;lt;SLACK_TOKEN&amp;gt;&amp;amp;room=&amp;lt;SLACK_ROOM&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;SLACK_ROOM에는 알림을 전달할 채널 이름을 지정합니다. 이제 이 URL을 원하시는 Github 저장소의 WebHook에 등록만 해주면 모든 준비는 완료됩니다. 하지만 여기까지 설정하고 위키를 수정해도 알림은 가지 않습니다. 앞서서 Github API에 대해서 다룬 바 있습니다만, 기본 Hook로는 &lt;code&gt;push&lt;/code&gt;밖에 등록이 되지 않기 때문입니다. 이 서버에서 인식할 수 있는 이벤트는 위키를 다루는 &lt;code&gt;gollum&lt;/code&gt;밖에 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
curl -u &amp;lt;USER_NAME&amp;gt; https://api.github.com/repos/&amp;lt;USER_NAME&amp;gt;/&amp;lt;REPO_NAME&amp;gt;/hooks/&amp;lt;HOOK_ID&amp;gt; -X PATCH -d &amp;#39;{&amp;quot;add_events&amp;quot;: [&amp;quot;gollum&amp;quot;] }&amp;#39;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;앞서 다룬 것과 마찬가지 방법으로 &lt;code&gt;gollum&lt;/code&gt; 이벤트를 추가해줍니다. 네 이걸로 모든 설정이 끝났습니다. 이제 해당하는 저장소의 위키를 수정해보면 서버에 알림이 가고 서버가 Slack으로 위키를 수정했다는 알림이 가게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img alt="Slack Room" src="../../images/2014-01-30-github-hook-api-slack-sample/github_slack.png" /&gt;&lt;/p&gt;

&lt;p&gt;만약 정상적으로 메시지가 가지 않을 경우엔 Github Webhook 등록 페이지에서 Test Hook 버튼을 누르고 &lt;code&gt;docker logs &amp;lt;CONTAINER_ID&amp;gt;&lt;/code&gt; 명령어를 통해서 요청이 정상 전달되는지부터 확인할 필요가 있습니다. 일단 이러한 방법을 통해서 무사히 Slack으로 이전을 마쳤습니다.&lt;/p&gt;

&lt;h2&gt;정리&lt;/h2&gt;

&lt;p&gt;네, 정리하겠습니다.&lt;/p&gt;

&lt;p&gt;이 글에서는 Github Hook API 서버를 다루고 중간에서 깃허브이 전달해주는 메시지를 처리하는 서비스를 소개해보았습니다. 여기서 든 예제는 팀의 필요에 기반해서 만들어진 정말 간단한 예제입니다만, 필요하다면 좀 더 복잡하고 고도화된 서버를 개발할 수도 있을 것입니다.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>도쿠(Dokku)로 만드는 미니 히로쿠(Heroku)</title>
    <link rel="alternate" href="http://blog.nacyot.com/articles/2014-01-30-deploying-application-with-dokku/"/>
    <id>http://blog.nacyot.com/articles/2014-01-30-deploying-application-with-dokku/</id>
    <published>2014-01-29T16:30:00Z</published>
    <updated>2014-02-16T15:50:24+00:00</updated>
    <author>
      <name>nacyot(Daekwon Kim)</name>
    </author>
    <content type="html">&lt;p&gt;지난 번 &lt;a href="http://docker.io/"&gt;도커&lt;/a&gt; 시리즈의 첫번째 글에서는 &lt;a href="http://blog.nacyot.com/articles/2014-01-27-easy-deploy-with-docker/"&gt;도커(Docker) 튜토리얼 : 깐 김에 배포까지&lt;/a&gt; 도커를 설치하고 이미지와 컨테이너의 개념 그리고 마지막으로 Dockerfile을 통해서 이미지를 생성하고 실제로 배포하는 부분까지 다뤄봤습니다. 이번 글에서는 도커를 활용해 간단히 어플리케이션 배포 서버를 구축할 수 있게 도와주는 &lt;a href="https://github.com/progrium/dokku/blob/master/dokku"&gt;도쿠&lt;/a&gt;(Dokku)를 다루도록 하겠습니다.&lt;/p&gt;



&lt;h2&gt;도쿠(Dokku) 소개&lt;/h2&gt;

&lt;p&gt;Jeff Lindsay이 개발한 도쿠는 도커(Docker)를 활용해 100줄 남짓한 쉘스크립트 본체와 도쿠를 둘러싼 몇 가지 모듈들을 활용해 미니 &lt;a href="https://heroku.com"&gt;히로쿠&lt;/a&gt;(Heroku)와 같은 PaaS 환경을 구축할 수 있도록 해줍니다. 도쿠 스스로가 미니 히로쿠라고 표현하고 있습니다만, 사용해보시면 아시겠지만 정말 히로쿠와 비슷합니다. 실제로 내부적으로 도쿠는 히로쿠에서 공개한 각 언어별 빌드팩들을 그대로 사용하고 있습니다. 히로쿠를 통해서 서비스를 배포해보셨거나 &lt;a href="http://ruby.railstutorial.org/"&gt;Rails Tutorial&lt;/a&gt;을 따라하면서 배포를 연습해보셨던 분들이라면 꽤나 반갑게 느껴지실 겁니다. 실제로 활용을 하건 안하건, 이런 훌륭한 시스템(생태계)을 직접 구축해볼 수 있다니!&lt;/p&gt;

&lt;p&gt;도커도 도쿠도 매력적이지 않을 수 없습니다.&lt;/p&gt;

&lt;p&gt;히로쿠나 PaaS에 대해서 잘 모르는 분들은 이런 개념이 낯설게 느껴지실 지도 모릅니다. 히로쿠나 PaaS 역시 클라우드 생태계의 한 축을 구성하고 있는 단어들입니다. 클라우드하면 가상화입니다. 클라우드의 본질적인 가치는 하드웨어 추상화에 있습니다. 하드웨어를 추상화하기 위해서는 다양한 기술과 관리를 위한 기술들이 필요합니다만, 이렇게 추상화된 하드웨어를 이용하는 입장에서는 &amp;#39;더 이상&amp;#39; 하드웨어라는 물리적인 영역을 신경쓰지 않아도 됩니다. 개발과는 거리가 있습니다만, 이런 종류의 추상화를 가장 잘 보여주는 게 &lt;strong&gt;구글 검색창&lt;/strong&gt;입니다. 그 안에서 어떠한 로직과 방법으로 데이터를 분석하는지는 전혀 알 필요없이, 우리는 구글의 엄청나게 거대한 시스템을 사용할 수 있습니다. 그렇게 보자면 서비스는 가장 높은 단계의 추상화라고 할 수 있습니다. &lt;/p&gt;

&lt;p&gt;IaaS나 Paas는 이보다 좀 더 낮은 단계의 추상화를 제공합니다. 서비스를 이용하는 사람은 서버가 어떤 하드웨어로 구성되어있고, 램은 몇 기가고 CPU는 뭘 쓰고 있고 신경쓸 필요가 없을 뿐더러, 어떤 운영체게 위에서 돌아가는지, 어플리케이션이 어떤 언어를 사용하고, 어떤 구조로 만들어져있고 데이터베이스가 어떻게 분산되어있는지도 신경쓸 필요가 없습니다. 앞의 문장을 &lt;strong&gt;어디까지 신경써야 하는가&lt;/strong&gt;를 가지고 단계를 나눌 수 있습니다. 앞서 이야기했듯이 서비스는 위에서 아무것도 신경쓰지 않습니다. 여기서 한단계 내려가면 사용하는 언어와 어플리케이션만 신경써야하는 단계가 있습니다. 이 아래에 있는 것들은 서비스로 지원합니다. 여기가 PaaS가 위치한 곳입니다. 여기서 더 아래로 내려가면 CPU의 성능과 램의 용량을 따지고 어떤 운영체제를 사용하고  각각의 시스템들을 어떻게 연동시켜야하는지 하는 부분이 나옵니다. 심지어 시스템의 크기까지 제어할 수 있습니다. 여기가 바로 IaaS가 위치한 곳입니다. 더 아래로 내려가면 네, 실제 서버 구성부터 이것저것 모든 것을 다 해야합니다. 해보신 분들은 아시겠지만 이런 일은 한 마디로 말해서 고역입니다. 운영체제도 하드웨어도 같지 않은 같지 않은 수십대의 시스템을 효과적으로 관리한다는 건 거의 불가능에 가깝습니다. 거기다가 고장까지 고려하면 더더욱 쉽지 않은 일입니다.&lt;/p&gt;

&lt;p&gt;다시 클라우드입니다만, 클라우드의 본질적인 가치는 어플리케이션을 개발하는데 있어서 우리가 어디까지 신경서야하는 지 그 위치를 &lt;strong&gt;선택가능한 옵션&lt;/strong&gt;으로 떨어뜨려줬다는 데 있습니다. 그건 내가 해줄게 하는 겁니다. AWS가 나오기 전에 서비스를 만드는 사람들에게 그런 종류의 선택권은 존재하지 않았습니다. 구체적이 서비스를 예를 들면 &lt;a href="http://aws.amazon.com/en/ec2/"&gt;AmazonWS EC2&lt;/a&gt;가 IaaS라면 히로쿠나 구글 앱 엔진은 대표적인 PaaS 서비스입니다. 더욱 재미있는 건 Heroku가 다름 아닌 AWS 위에서 돌아가고 있다는 사실입니다. &lt;/p&gt;

&lt;p&gt;특히 히로쿠는 &lt;a href="http://rubyonrails.org/"&gt;루비 온 레일즈&lt;/a&gt;를 시작으로 현재는 자바, Nodejs, 파이썬 어플리케이션까지 지원하고 있습니다. 히로쿠를 사용하면 회사나 개발자는 딱 &lt;strong&gt;어플리케이션&lt;/strong&gt;만 만들어내면 됩니다. 거짓말 조금 보태서 어디서 어떻게 관리하고 배포할 지 일절 고민할 필요가 없습니다. 어플리케이션을 만들고 Heroku에 있는 Git 서버에 푸쉬하기만 하면 어플리케이션을 자동으로 빌드하고 연결한 도메인으로 배포해줍니다. 이건 그저 감탄만 나올 정도로 너무 훌륭합니다만(!) 같은 크기에 있어서 IaaS 서비스보다 PaaS가 일반적으로 더 비싼 편이기 때문에 가격 정책이나 여러가지를 고려해서 맞는 서비스를 이용한 게 현명한 일입니다.&lt;/p&gt;

&lt;p&gt;네, 본 주제로 돌아가죠. 다시 도쿠입니다. 도쿠는 바로 Docker라는 가상화 기술을 활용해 이러한 PaaS를 직접 구축하게 도와주는 절대로 &lt;strong&gt;크지 않은&lt;/strong&gt; 어플리케이션입니다. 절대로 많은 것을 요구하지도 않고 어렵지도 않습니다. 도커에 대해서 조금 아시면 좋고, 우분투를 사용하고 계신다면 당장 사용해볼 수 있습니다.&lt;/p&gt;

&lt;h2&gt;도쿠 설치하기&lt;/h2&gt;

&lt;p&gt;당연한 이야기입니다. 도쿠를 사용하기 위해서는 먼저 설치를 해야합니다. Dokku는 현재 우분투 12나 13.04를 사용할 것을 권장하고 있습니다. 우분투 13.10에서도 사용한 바 정상적으로 사용이 가능했습니다만 몇 가지 이슈가 있어서 13.10에서 사용하는 것은 권장하지 않고 있는 상황입니다.&lt;a href="https://github.com/dotcloud/docker/issues/1906"&gt;^2&lt;/a&gt; 먼저 Docker는 설치가 되어있다고 가정하겠습니다. 아직 설치가 되어있지 않다면 &lt;a href="http://blog.nacyot.com/articles/2014-01-27-easy-deploy-with-docker/"&gt;도커(Docker) 튜토리얼 : 깐 김에 배포까지&lt;/a&gt;나 도커 공식 홈페이지를 참조해 설치해주시기 바랍니다.&lt;/p&gt;

&lt;p&gt;하나 주의해야하는 점은 도쿠 서버는 어디까지나 배포 서버입니다. 불가능한 건 아니지만, 가능하면 개발 서버와 분리된 환경이나 서버가 따로 없다면 가상 머신 상에서 테스트 해보기를 권장합니다. 또한 도메인 설정이 되어있어야 정상적으로 사용가능합니다(없이도 테스트나 사용은 가능합니다만 권장하지 않습니다). 자세한 내용은 각 설정에 대해서 얘기하는 부분에서 자세히 다룹니다.&lt;/p&gt;

&lt;p&gt;바로 도쿠를 설치하겠습니다. 도쿠 역시 원큐에 설치가능한 쉘스크립트를 제공하고 있습니다. &lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ wget -qO- https://raw.github.com/progrium/dokku/v0.2.1/bootstrap.sh | sudo DOKKU_TAG=v0.2.1 bash
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;현재 최신 안정 버진인 &lt;code&gt;0.2.1&lt;/code&gt;을 설치합니다. 도쿠 공식 문서에 따르면 우분투 12.04에서는 &lt;code&gt;python-software-properties&lt;/code&gt; 패키지가 필요할 지도 모른다고 이야기하고 있습니다. 아래와 같은 메시지가 뜨면서 설치가 실패하는 경우가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
/var/lib/dokku/plugins/nginx-vhosts/install: line 5: add-apt-repository: command not found
make: *** [plugins] Error 127
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이때는 &lt;code&gt;apt-get install python-software-properties&lt;/code&gt;를 실행시켜 필요한 패키지를 설치해주세요.&lt;/p&gt;

&lt;p&gt;설치가 끝났으면 제대로 설치가 되었는지 확인해봅니다.&lt;/p&gt;

&lt;p&gt;```
...
Almost done! For next steps on configuration:                                                                                       https://github.com/progrium/dokku#configuring&lt;/p&gt;

&lt;p&gt;$ dokku version
v0.2.1
```&lt;/p&gt;

&lt;p&gt;버전이 제대로 출력되는 걸 보니 정상적으로 설치가 끝났습니다. 이제 간단한 설정을 해줄 필요가 있습니다.&lt;/p&gt;

&lt;h3&gt;도메인 설정&lt;/h3&gt;

&lt;p&gt;도커는 기본적으로 배포환경이기 때문에 도메인을 지정해줄 필요가 있습니다. 도커를 설치하면 자동적으로 &lt;code&gt;dokku&lt;/code&gt; 유저가 시스템에 추가되고, &lt;code&gt;/home/dokku&lt;/code&gt; 디렉토리에서 현재 배포중인 앱과 설정에 관련된 파일들을 확인할 수 있습니다. 먼저 여기에 &lt;code&gt;VHOST&lt;/code&gt;라는 파일을 추가하고 자신이 사용할 도메인을 지정해줍니다. 예를 들어서 &lt;code&gt;&amp;lt;APP_NAME&amp;gt;.nacyot.com&lt;/code&gt;을 도메인으로 사용하고자 한다면 &lt;code&gt;/home/dokku/VHOST&lt;/code&gt; 파일에 다음과 같이 추가해줍니다(파일이 없으면 루트나 dokku 권한으로 직접 생성해주세요).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
nacyot.com
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;뒤에서 좀 더 이야기하겠습니다만, 여기서 도메인을 설정하게 되면 따로 아무런 설정을 하지 않더라도앱 배포시 앱의 이름을 활용해 서브도메인으로 곧장 배포가 됩니다. 당연하지만 이를 위해서는 일반적으로 도메인을 사용하는 것과 마찬가지로 DNS 서버에 &lt;code&gt;A Record&lt;/code&gt;를 추가해야합니다. 예를 들어 &lt;code&gt;nacyot.com&lt;/code&gt; 아래의 모든 도메인을 도쿠로 배포하는 어플리케이션의 서브 도메인을 사용하도록 하려면 &lt;code&gt;*.nacyot.com&lt;/code&gt;을 &lt;code&gt;&amp;lt;Dokku_IP_APPRESS&amp;gt;&lt;/code&gt; 도쿠 서버의 아이피 주소를 가리키도록 설정하시면 됩니다. 이 때 도메인이 없는 경우에는 VHOST 파일을 삭제해주시기바랍니다. 이렇게하면 랜덤하게 생성된(사실은 49000번대에서 순차적으로 생성되는) 포트에 앱이 자동으로 연결됩니다. 하지만 이 포트는 앱을 생성할 때마다 유동적으로 변하므로 미리 DNS 서버를 설정해놓고 도메인을 사용하는 게 좋습니다.&lt;/p&gt;

&lt;h3&gt;Git Server 설정&lt;/h3&gt;

&lt;p&gt;앞어서 히로쿠를 간단히 소개하면서 히로쿠의 Git 서버에 푸쉬만 하면 어플리케이션을 자동으로 빌드하고 배포해준다는 이야기를 했습니다. 도쿠도 마찬가지 방식을 사용합니다. 따라서 Push를 보내는 쪽이 적절한 권한을 가지고 있는지 인증 절차를 거칠 필요가 있습니다. 도쿠 README 파일에서는 아래의 명령어를 실행시키라고 이야기하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ cat ~/.ssh/id_rsa.pub | ssh progriumapp.com &amp;quot;sudo sshcommand acl-add dokku progrium&amp;quot;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;잠깐! 이 명령어를 실행시키기 전에 약간의 이해가 필요합니다. 도쿠는 어디까지나 배포서버라는 것을 전제로 하고 있습니다. 즉, 도쿠는 어디까지나 개발서버 머나먼 어딘가에서 어플리케이션을 실제로 배포해주는 배포서버입니다. 그리고 어플리케이션을 개발하고 배포하려는 사람(머신)은 다른 곳에 있습니다. 이 명령어는 도쿠 서버에서 사용하는 명령어가 아니라 개발 서버에서 ssh를 통해 Git 저장소를 접근할 수 있도록 권한 설정을 해주는 명령어입니다. 즉 이 명령어는 개발 서버에 있는 ssh 공개키를 도쿠 서버에 넘겨서 접근 권한을 줍니다. 위 명령어를 좀 더 정확히 표현하자면 아래와 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ cat ~/.ssh/id_rsa.pub | ssh &amp;lt;아이디&amp;gt;@&amp;lt;서버_아이피_주소_혹은_도메인&amp;gt; &amp;quot;sudo sshcommand acl-add dokku progrium&amp;quot;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;꺽쇠 안의 부분을 도쿠 서버에 맞게 적당히 바꿔주시고 개발 서버에서 이 명령어를 실행해야합니다. 또한 이 때 root 계정이나 root에 준하는 권한을 가진 권한을 사용한다면 바로 실행이 되겠지만 sudo를 실행시 비밀번호를 묻는 경우 이 명령어가 정상적으로 처리되지 않습니다. 정 실행이 어려운 경우엔 도쿠 서버에서 직접 공개키를 &lt;code&gt;echo&lt;/code&gt;해서 실행하셔도 무방합니다. 실패하는 경우 &lt;code&gt;failed&lt;/code&gt;라는 메시지가 뜨며 권한 등록에 성공하면 콜론으로 구분된 문자열이 출력됩니다.&lt;/p&gt;

&lt;p&gt;제대로 등록됐는지 확인하기 위해 개발 서버에서 테스트로 접근해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ ssh dokku@&amp;lt;도쿠_서버_아이피_혹은_도메인&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이 때 연결이 끊어졌다는 메시지가 나오면 정상이고, dokku 계정의 패스워드를 물어본다면 제대로 등록이 안 된 상황입니다. ssh 키나 등록 부분에 문제가 없는지 확인해볼 필요가 있습니다. 특히 얼마 전까지만 해도 계정을 git을 사용했었고, ssh 등록 명령어도 &lt;code&gt;gitreceive upload-key dokku&lt;/code&gt;를 사용했었기 때문에 예전 문서를 참조했는지도 확인이 필요합니다.&lt;/p&gt;

&lt;p&gt;고생하셨습니다. 자 이제 설치가 끝났으니 본격적으로 도쿠의 세계로 출발해보죠.&lt;/p&gt;

&lt;h2&gt;첫 어플리케이션 배포&lt;/h2&gt;

&lt;p&gt;이제 끝나갑니다. 여기서는 도쿠의 README 문서를 따라 샘플 어플리케이션을 배포해보도록 하겠습니다. 샘플 어플리케이션으로는 히로쿠에서 제공하는 &lt;code&gt;node-js-sample&lt;/code&gt;을 사용합니다. 참고로(!) 이 작업들은 개발 머신에서 진행합니다. &lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ git clone https://github.com/heroku/node-js-sample.git
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;먼저 git 저장소에서 어플리케이션을 클론합니다. 이제 &lt;code&gt;node-js-sample&lt;/code&gt; 폴더로 이동해 원격 저장소로 도쿠 서버를 등록하고 푸쉬해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ cd node-js-sample
$ git remote add dokku dokku@&amp;lt;도쿠_서버_주소&amp;gt;:&amp;lt;앱_이름&amp;gt;
$ git push dokku master
Counting objects: 313, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (270/270), done.
Writing objects: 100% (313/313), 200.76 KiB | 0 bytes/s, done.
Total 313 (delta 15), reused 313 (delta 15)
----&amp;gt; Building node-sample ...
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;도쿠 서버 주소&lt;/code&gt;는 실제 도쿠 서버의 주소를 아이피나 도메인으로 지정하면 되고, 앱 이름은 원하는 이름을 사용하면 됩니다. 이 때 앱 이름이 곧 서브 도메인 이름이 됩니다. 예를 들어 &lt;code&gt;node-sample&lt;/code&gt;으로 이름을 지정하면 도메인은 &lt;code&gt;VHOST&lt;/code&gt;에서 설정한 메인 도메인과 연결되어 &lt;code&gt;node-sample.nacyot.com&lt;/code&gt;이 됩니다. 자동으로 빌드가 진행됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
...
-----&amp;gt; Building runtime environment
-----&amp;gt; Discovering process types
Procfile declares types -&amp;gt; web
-----&amp;gt; Releasing node-sample ...
-----&amp;gt; Deploying node-sample ...
-----&amp;gt; Cleaning up ...
=====&amp;gt; Application deployed:
http://node-sample.nacyot.com
To dokku@&amp;lt;...&amp;gt;:node-sample
* [new branch]      master -&amp;gt; master
$
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;1분 여 남짓 기다리면, 자 이제 빌드가 끝났습니다. 배포도 끝났습니다. DNS 설정이 이미 적용 되어있다면 배포 즉시 &lt;code&gt;node-sample.nacyot.com&lt;/code&gt; 도메인으로 접속해 어플리케이션을 확인해볼 수 있습니다. 정상적으로 배포가 되었다면 &lt;code&gt;Hello, world&lt;/code&gt;라는 문자열이 여러분을 반길 것입니다.&lt;/p&gt;

&lt;p&gt;빌드도 알아서 해주고, 서버 설정도 알아서 해줍니다. 훌륭한 PaaS 시스템이라고 할 수 있습니다. 여러분은 그저 어플리케이션만 만들고 Push해주면 됩니다. 끝입니다.&lt;/p&gt;

&lt;p&gt;어플리케이션은 여러분이 만들어야 하는 부분이니,&lt;/p&gt;

&lt;p&gt;헐... 더 할 얘기가 없네요. 너무 간단하죠?&lt;/p&gt;

&lt;h2&gt;&lt;a href="https://github.com/progrium/buildstep"&gt;빌드스텝&lt;/a&gt;(Buildstep)&lt;/h2&gt;

&lt;p&gt;히로쿠를 써보신 분들이라면 눈치 까셨겠지만 빌드 과정에서 나오는 메시지들이 히로쿠에서 어플리케이션을 푸시할 때 나오는 메시지들과 매우 닮아있습니다. 실제로 도쿠 어플리케이션을 빌드하는 방법은 히로쿠에서 제공하는 빌드팩이라는 오픈소스를 통해서 이루어집니다. 사실 도쿠가 어떻게 도커를 사용하고 빌드팩을 사용하는지 이렇게 봐서는 이해가 어려울지도 모릅니다.&lt;/p&gt;

&lt;p&gt;도쿠는 분명 도커 기반으로 작동합니다. 하지만 이번 글에서는 아직 도커에 관련된 부분이 아직 나오지 않았습니다. 이제 도커가 나설 차례입니다. 도쿠를 설치하면 도커에서는 어떤일이 일어났을까요. 도쿠를 설치한 상태에서(위의 과정을 따라오셨다면, 설치가 되어있겠죠) 도커의 이미지를 확인해보겠습니다. 도쿠 서버에서 아래 명령어를 실행시켜주세요.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker images
REPOSITORY           TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
progrium/buildstep   latest              107a86e32874        6 hours ago         1.42 GB
ubuntu               quantal             426130da57f7        3 days ago          127.9 MB
centos               6.4                 539c0211cd76        10 months ago       300.6 MB
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;progrium/buildstep&lt;/code&gt;이라는 이미지가 하나 추가된 것을 알 수 있습니다. 위 예제의 이미지는 커스터마이징이 되어있어서 아마 출력되는 용량은 더 작을 것입니다. 이 빌드스텝이라는 이미지가 도쿠 시스템의 하이라이트입니다. 빌드스탭은 어플리케이션이 빌드가 될 베이스가 되는 이미지입니다. 즉 위의 &lt;code&gt;node-js-sample&lt;/code&gt;에서 푸시를 하게 되면 실제로 일어나는 일은 이 &lt;code&gt;buildstep&lt;/code&gt;이라는 이미지를 바탕으로 푸시된 어플리케션을 빌드해서 새로운 이미지를 생성하는 일입니다.&lt;/p&gt;

&lt;p&gt;따라서 실제로 어플리케이션을 푸쉬한 다음에 이미지들을 확인해보면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker imaegs
REPOSITORY           TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
app/node-sample      latest              4d88b88215cc        11 minutes ago      1.582 GB
progrium/buildstep   latest              107a86e32874        6 hours ago         1.42 GB
ubuntu               quantal             426130da57f7        3 days ago          127.9 MB
centos               6.4                 539c0211cd76        10 months ago       300.6 MB
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;보시면 아시겠지만 &lt;code&gt;app/node-sample&lt;/code&gt;이라는 새로운 이미지가 추가된 것을 확인할 수 있습니다. 추정컨테 마치 &lt;code&gt;progrium/buildstep&lt;/code&gt; 이미지에서 뭔가가 추가된 것 같이 용량도 별반 다르지 않습니다. 그런데 이것만으로는 정말론 &lt;code&gt;app/node-sample&lt;/code&gt;의 부모 이미지가 &lt;code&gt;progrium/buildstep&lt;/code&gt;인지 확인할 수 없습니다. 따라서 &lt;code&gt;history&lt;/code&gt; 명령을 통해서 &lt;code&gt;app/node-sample&lt;/code&gt;의 이력을 조회해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker history app/node-sample
IMAGE               CREATED             CREATED BY                                   SIZE
4d88b88215cc        18 minutes ago      /build/builder                               162.4 MB
30848b99f896        19 minutes ago      /bin/bash -c mkdir -p /app &amp;amp;&amp;amp; tar -xC /app   1.976 kB
107a86e32874        6 hours ago         /bin/bash                                    517.1 MB
b1c426dee3ff        29 hours ago                                                     875.5 MB
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;아래에서부터 이력을 쫓아보면 아시겠지만 &lt;code&gt;107a86e32874(progrium/buildstep)&lt;/code&gt;에서 &lt;code&gt;4d88b88215cc(app/node-sample)&lt;/code&gt;이 파생된 것을 확인할 수 있습니다. 네, 이로써 &lt;code&gt;buildstep&lt;/code&gt;이 도쿠를 통한 어플리케이션에 있어서 모든 근원이라는 것을 확인했습니다. 이쯤되면 &lt;code&gt;buildstep&lt;/code&gt;이 도대체 뭔가 하는 궁금증이 생기게 마련입니다. 그렇다면 빌드스텝 안을 까보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker run -rm -i -t progrium/buildstep:latest /bin/bash
root@3a6b0a823acb:/# ls
boot   cache  etc   home  lib64  mnt  proc  run   selinux  tmp  var
bin  build  dev    exec  lib   media  opt  root  sbin  srv      sys    usr
root@3a6b0a823acb:/# cd build
root@3a6b0a823acb:/build# ls
builder  buildpacks  buildpacks.txt  packages.txt  prepare
root@3a6b0a823acb:/build# 
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;빌드스탭 이미지에 쉘을 띄웁니다. 안에는 일반적인 리눅스 시스템에서는 보기 힘든 build라는 디렉토리가 있습니다. 들어가 봅니다. 들어가 보니 build와 관련된 파일들이 나옵니다. buildpakcs 디렉토리에 들어가보면 다음과 같은 디렉토리들이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
root@3a6b0a823acb:/build/buildpacks# ls -al
total 64
drwxr-xr-x 16 root root 4096 Jan 29 07:16 .
drwxr-xr-x  3 root root 4096 Jan 29 06:18 ..
drwxr-xr-x  5 root root 4096 Dec  3 18:35 buildpack-nginx
drwxr-xr-x  5 root root 4096 Dec  3 18:35 heroku-buildpack-clojure
drwxr-xr-x  5 root root 4096 Dec  3 18:35 heroku-buildpack-dart
drwxr-xr-x  8 root root 4096 Dec  3 18:35 heroku-buildpack-go
drwxr-xr-x  6 root root 4096 Dec  3 18:35 heroku-buildpack-java
drwxr-xr-x  7 root root 4096 Dec  3 18:35 heroku-buildpack-meteorite
drwxr-xr-x  7 root root 4096 Dec  3 18:35 heroku-buildpack-nodejs
drwxr-xr-x  4 root root 4096 Dec  3 18:35 heroku-buildpack-perl
drwxr-xr-x  7 root root 4096 Dec  3 18:35 heroku-buildpack-php
drwxr-xr-x  6 root root 4096 Dec  3 18:35 heroku-buildpack-play
drwxr-xr-x  6 root root 4096 Dec  3 18:35 heroku-buildpack-python
drwxr-xr-x  9 root root 4096 Jan 29 07:16 heroku-buildpack-ruby
drwxr-xr-x  6 root root 4096 Dec  3 18:35 heroku-buildpack-scala
drwxr-xr-x  5 root root 4096 Dec  3 18:35 heroku-buildpack-static-apache
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;오, 뭔가 노다지를 찾은 기분입니다. heroku-buildpack 들이 우글우글대고 있습니다. 실제 빌드스텝이 어떻게 구성되어 있는지는 &lt;a href="https://github.com/progrium/buildstep"&gt;빌드스텝 저장소&lt;/a&gt;를 참조해보시면 도움이 되실 거라고 생각합니다. 정말 단순합니다. 여기는 어플리케이션 빌드가 가능하도록 각 언어별 heroku-buildpack들을 clone해두었다고 보시면 됩니다.&lt;/p&gt;

&lt;p&gt;눈치채셨을 지도 모르겠지만, 빌드스탭 이미지 역시 커스터마이징이 가능합니다. 도쿠에서 빌드스탭이미지를 기반으로 빌드를 할 때는 단순히 &lt;code&gt;progrium/buildstep:latest&lt;/code&gt;라는 이름을 가진 이미지를 기반으로 빌드를 합니다. 물론 기본적으로 내부에 위에서 간략히 보여드린 빌드팩들이 포함되어있어야하겠습니다만, 어쨌거나 원한다면 이미지를 수정하거나 필요한 패키지들을 더 집어넣을 수도 있습니다. 이미지 이름만 같으면 됩니다. 별도의 글에서 다룰 예정입니다만, 저 같은 경우는 [heroku-buildpack-ruby][buildpack-ruby]를 간단히 커스터마이징해서 쓰고 있고 그래서 이미지 안의 heroku-buildpack-ruby만 제 저장소에 있는 걸 클론해서 쓰고 있습니다. 위의 &lt;code&gt;ls&lt;/code&gt; 출력 결과를 보시면 ruby만 수정 날짜가 다른 걸 알 수 있습니다.&lt;/p&gt;

&lt;h2&gt;도커 컨테이너와 도메인 연결&lt;/h2&gt;

&lt;p&gt;즉 도쿠 서버에 푸시를 해서 실제로 일어나는 일이란, 이 빌드스텝이라는 이미지를 기반으로, &lt;code&gt;/build&lt;/code&gt; 폴더에 있는 히로쿠 빌드팩을 통해 어플리케이션을 빌드하고, 어라.&lt;/p&gt;

&lt;p&gt;한 가지가 빠졌네요. 도메인을 연결시켜줍니다. 이 일은 어떻게 일어나는 걸까요? 이제 &lt;code&gt;buildstep&lt;/code&gt; 이미지를 빠져나와 &lt;code&gt;dokku&lt;/code&gt; 홈으로 이동해보겠습니다.&lt;/p&gt;

&lt;p&gt;```
$ cd /home/dokku
$ ls -l
total 24
-rw-r--r-- 1 dokku root    13 Jan 29 11:31 dokkurc.log
-rw-r--r-- 1 dokku root    58 Jan 28 17:38 HOSTNAME
drwxr-xr-x 8 dokku dokku 4096 Jan 29 22:20 node-sample
-rw-r--r-- 1 root  root    19 Jan 29 17:08 VHOST&lt;/p&gt;

&lt;p&gt;$ cd node-sample
$ ls -l
total 52
drwxr-xr-x 2 dokku dokku 4096 Jan 29 22:19 branches
drwxr-xr-x 2 dokku dokku 4096 Jan 29 22:19 cache
-rw-r--r-- 1 dokku dokku   66 Jan 29 22:19 config
-rw-r--r-- 1 dokku dokku   65 Jan 29 22:20 CONTAINER
-rw-r--r-- 1 dokku dokku   73 Jan 29 22:19 description
-rw-r--r-- 1 dokku dokku   23 Jan 29 22:19 HEAD
drwxr-xr-x 2 dokku dokku 4096 Jan 29 22:19 hooks
drwxr-xr-x 2 dokku dokku 4096 Jan 29 22:19 info
-rw-r--r-- 1 dokku dokku  530 Jan 29 22:20 nginx.conf
drwxr-xr-x 4 dokku dokku 4096 Jan 29 22:19 objects
-rw-r--r-- 1 dokku dokku    6 Jan 29 22:20 PORT
drwxr-xr-x 4 dokku dokku 4096 Jan 29 22:19 refs
-rw-r--r-- 1 dokku dokku   38 Jan 29 22:20 URL
```&lt;/p&gt;

&lt;p&gt;앞어서도 어렴풋이 이야기 했습니다만, dokku 계정은 사실 git 원격 저장소를 관리하기 위한 계정입니다. 그리고 그 아래에 있는 디렉토리들은 실제로 하나하나 git 저장소가 됩니다. &lt;code&gt;node-sample&lt;/code&gt; 역시 git 저장소이자 도커 이미지를 생성하기 위한 설정들이 저장 되어있는 디렉토리입니다. 마술은 &lt;code&gt;git&lt;/code&gt;의 &lt;code&gt;hook&lt;/code&gt;를 사용해서 일어납니다. &lt;code&gt;git&lt;/code&gt;은 특정한 이벤트가 발생할 때 특정한 명령어를 실행시킬 수 있는 &lt;code&gt;hook&lt;/code&gt;라는 특수한 기능을 지원합니다. &lt;code&gt;hooks&lt;/code&gt; 디렉토리에 들어가보면 &lt;code&gt;pre-receive&lt;/code&gt; 후크가 활성화되어있는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;```
$ cd hooks
$ cat pre-receive&lt;/p&gt;

&lt;h1&gt;!/usr/bin/env bash&lt;/h1&gt;

&lt;p&gt;set -e; set -o pipefail;
cat | DOKKU_ROOT=&amp;quot;/home/dokku&amp;quot; dokku git-hook node-sample
```&lt;/p&gt;

&lt;p&gt;내용은 매우 간단합니다. &lt;code&gt;node-sample&lt;/code&gt; 어플리케이션에 대해 &lt;code&gt;dokku&lt;/code&gt; 명령어에 &lt;code&gt;git-hook&lt;/code&gt;라는 플러그인 명령을 실행시키고 있습니다. 이렇게 보면 이 명령어의 정체가 잘 안 보이니 &lt;code&gt;git-hook&lt;/code&gt;도 실제로 살펴 보겠습니다. &lt;code&gt;git-hook&lt;/code&gt; 플러그인의 내용은 아래 &lt;code&gt;/var/lib/dokku/plugins/git/commands&lt;/code&gt;에서 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;```sh&lt;/p&gt;

&lt;h1&gt;!/usr/bin/env bash&lt;/h1&gt;

&lt;p&gt;set -eo pipefail; [[ $DOKKU_TRACE ]] &amp;amp;&amp;amp; set -x&lt;/p&gt;

&lt;p&gt;case &amp;quot;$1&amp;quot; in
  git-hook)
    APP=$2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while read oldrev newrev refname
do
  # Only run this script for the master branch. You can remove this
  # if block if you wish to run it for others as well.
  if [[ $refname = &amp;quot;refs/heads/master&amp;quot; ]] ; then
    git archive $newrev | dokku receive $APP | sed -u &amp;quot;s/^/&amp;quot;$&amp;#39;\e&amp;#39;&amp;quot;/&amp;quot;
  fi

done
;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;...
```&lt;/p&gt;

&lt;p&gt;여기서는 &lt;code&gt;git-hook&lt;/code&gt; 명령어만 살펴보겠습니다. 여기서 git 브랜치가 master일 때 다시 &lt;code&gt;dokku&lt;/code&gt; 명령어를 통해서 &lt;code&gt;receive&lt;/code&gt; 명령을 실행시키는 걸 알 수 있습니다. &lt;code&gt;dokku receive&lt;/code&gt; 명령어는 &lt;a href="https://github.com/progrium/dokku/blob/master/dokku"&gt;dokku 메인 스크립트&lt;/a&gt;에 정의되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sh
case &amp;quot;$1&amp;quot; in
  receive)
    APP=&amp;quot;$2&amp;quot;; IMAGE=&amp;quot;app/$APP&amp;quot;
    echo &amp;quot;-----&amp;gt; Cleaning up ...&amp;quot;
    dokku cleanup
    echo &amp;quot;-----&amp;gt; Building $APP ...&amp;quot;
    cat | dokku build $APP
    echo &amp;quot;-----&amp;gt; Releasing $APP ...&amp;quot;
    dokku release $APP
    echo &amp;quot;-----&amp;gt; Deploying $APP ...&amp;quot;
    dokku deploy $APP
    echo &amp;quot;=====&amp;gt; Application deployed:&amp;quot;
    echo &amp;quot; $(dokku url $APP)&amp;quot;
    echo
    ;;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;여기서 다시 &lt;code&gt;build&lt;/code&gt;, &lt;code&gt;release&lt;/code&gt;, &lt;code&gt;deploy&lt;/code&gt; 명령을 실행합니다. 자세한 사항은 전체 스크립트에서 확인할 수 있으며, 여기서는 &lt;code&gt;deploy&lt;/code&gt; 부분만 간략히 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;```
  deploy)
    APP=&amp;quot;$2&amp;quot;; IMAGE=&amp;quot;app/$APP&amp;quot;
    pluginhook pre-deploy $APP&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# kill the app when running
if [[ -f &amp;quot;$DOKKU_ROOT/$APP/CONTAINER&amp;quot; ]]; then
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;oldid=$(&amp;lt; &amp;quot;$DOKKU_ROOT/$APP/CONTAINER&amp;quot;)
      docker kill $oldid &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 || true
fi&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# start the app
DOCKER_ARGS=$(: | pluginhook docker-args $APP)
id=$(docker run -d -p 5000 -e PORT=5000 $DOCKER_ARGS $IMAGE /bin/bash -c &amp;quot;/start web&amp;quot;)
echo $id &amp;gt; &amp;quot;$DOKKU_ROOT/$APP/CONTAINER&amp;quot;
port=$(docker port $id 5000 | sed &amp;#39;s/0.0.0.0://&amp;#39;)
echo $port &amp;gt; &amp;quot;$DOKKU_ROOT/$APP/PORT&amp;quot;
echo &amp;quot;http://$(&amp;lt; &amp;quot;$DOKKU_ROOT/HOSTNAME&amp;quot;):$port&amp;quot; &amp;gt; &amp;quot;$DOKKU_ROOT/$APP/URL&amp;quot;

pluginhook post-deploy $APP $port
;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;&lt;code&gt;deploy&lt;/code&gt; 부분에서는 빌드된 이미지로부터 docker container를 실행시킵니다. 특히 마지막 부분에서는 &lt;code&gt;post-deploy pluginhook&lt;/code&gt;를 실행시킵니다. 이는 &lt;code&gt;/var/lib/dokku/plugins/nginx-vhosts/post-deploy&lt;/code&gt;에 정의되어 있는 부분으로 저장소 폴더에 앱 설정에 맞춰 &lt;code&gt;nginx.conf&lt;/code&gt;를 생성하고 이 설정이 적용되도록 nginx 서비스를 재실행합니다. 앞서 배포한 어플리케이션의 &lt;code&gt;/home/dokku/node-sample/nginx.conf&lt;/code&gt;는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
upstream node-sample { server 127.0.0.1:49175; }
server {
  listen      80;
  server_name node-sample.nacyot.com;
  location    / {
    proxy_pass  http://node-sample;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection &amp;quot;upgrade&amp;quot;;
    proxy_set_header Host $http_host;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-For $remote_addr;
    proxy_set_header X-Forwarded-Port $server_port;
    proxy_set_header X-Request-Start $msec;
  }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;자세히 보면 이는 &lt;code&gt;node-sample.nacyot.com&lt;/code&gt;으로 들어온 요청을 받았을 때 &lt;code&gt;127.0.0.1:49175&lt;/code&gt;로 프록시를 보내주는 설정입니다. 배포된 어플리케이션이 어느 포트로 실행되고 있는지는 실행중인 컨테이너 목록에서 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker ps
CONTAINER ID        IMAGE                       COMMAND                CREATED             STATUS              PORTS                     NAMES
bc259b925113        app/node-sample:latest      /bin/bash -c /start    2 hours ago         Up 2 hours          0.0.0.0:49175-&amp;gt;5000/tcp   ecstatic_fermi
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;포트 부분을 보게 되면 &lt;code&gt;localhost:49175&lt;/code&gt; 요청에 대해서 &lt;code&gt;node-sample&lt;/code&gt; 컨테이너의 5000번 포트로 포트포워딩이 이뤄지는 것을 알 수 있습니다. 즉 위에서 살펴본 &lt;code&gt;nginx.conf&lt;/code&gt; 파일을 통해서 &lt;code&gt;node-sample.nacyot.com&lt;/code&gt;으로 요청을 받으면 &lt;code&gt;node-sample&lt;/code&gt; 컨테이너의 5000번 포트에서 돌아가고 있는 어플리케이션으로 요청이 전달되는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그런데 &lt;code&gt;/home/dokku&lt;/code&gt; 아래의 &lt;code&gt;nginx.conf&lt;/code&gt; 설정이 어떤 원리로 적용이 되는 걸까요? 이 수수께끼는 도쿠 설치시에 추가되는 &lt;code&gt;/etc/nginx/conf.d/dokku.conf&lt;/code&gt; 파일을 보면 풀립니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
include /home/dokku/*/nginx.conf;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;정말 단순하네요.&lt;/p&gt;

&lt;p&gt;이로써 &lt;code&gt;git push&lt;/code&gt;를 하면 일어나는 마술을 정말 간략히만 파헤쳐봤습니다.&lt;/p&gt;

&lt;p&gt;다시 한 번 정리하자면 도쿠 서버에 푸시를 해서 실제로 일어나는 일이란, 이 빌드스텝(buildstep이라는 이미지를 기반으로, &lt;code&gt;/build&lt;/code&gt; 폴더에 있는 히로쿠 빌드팩을 통해 어플리케이션을 빌드하고, nginx 설정 파일을 동적으로 만들고 재실행해서 원하는 도메인으로 서비스를 연결시켜주는 일입니다. &lt;/p&gt;

&lt;h2&gt;정리&lt;/h2&gt;

&lt;p&gt;지금까지 도쿠를 통해 샘플 어플리케이션을 배포해보고, 배포가 어떻게 이루어지는 지 간략하게 살펴보았습니다. 이제 도쿠가 어떻게 돌아가는지 감이 좀 잡히시나요? 실제 서비스 운용을 위한 용도는 아닙니다만, 도커와 도쿠를 개인 서버는 물론 KT cloud와 SKT T developes VM, Amazon EC2 마이크로 인스턴스에도 올려봤습니다만 신기할 정도로 잘 돌아갑니다. 이렇게 쉽게(?) 내 손 안에 히로쿠가 올라오다니 신기할 따름입니다.&lt;/p&gt;

&lt;p&gt;이번에는 도쿠의 원리를 가볍게 보여드리고자 샘플 어플리케이션을 배포해보았습니다만, (언제가 될 지 기약은 없습니다만) 다음 글에서는 레일즈4 어플리케이션을 도쿠를 통해 배포하면서 데이터베이스를 연동하고 빌드 과정에서 생길 수 있는 문제와 이를 해결하기 위해 buildstep과 buildpack을 간단히 커스터마이징 해보겠습니다.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>도커(Docker) 튜토리얼 : 깐 김에 배포까지</title>
    <link rel="alternate" href="http://blog.nacyot.com/articles/2014-01-27-easy-deploy-with-docker/"/>
    <id>http://blog.nacyot.com/articles/2014-01-27-easy-deploy-with-docker/</id>
    <published>2014-01-27T03:00:00Z</published>
    <updated>2014-02-16T15:50:24+00:00</updated>
    <author>
      <name>nacyot(Daekwon Kim)</name>
    </author>
    <content type="html">&lt;p&gt;클라우드와 같이 잘 짜여지고, 잘 나뉘어진 거대한 시스템에서야 그렇다 치더라도 가상 머신은 여러모로 손실이 많은 수단 중 하나입니다. 가상 머신은 격리된 환경을 구축해준다는 데서 매력적이긴 하지만, 실제 배포용으로 쓰기에는 성능 면에서 매우 불리한 도구라고 할 수 있습니다. 당연한 이야기입니다만 일단 운영체제 위에서 또 다른 운영체제를 통째로 돌린다는 것 자체가 리소스를 비효율적으로 활용할 수밖에 없습니다.&lt;/p&gt;

&lt;p&gt;이런 가운데 가상 머신의 단점은 극복하면서 장점만을 극대화하기 위한 최적화가 계속해서 이루어지고 있습니다. 도커 역시 이런 단점을 극복하기 위해서 나온 가상화 어플리케이션입니다. 도커는 단순한 가상 머신을 넘어서 어느 플랫폼에서나 재현가능한 어플리케이션 컨테이너를 만들어주는 걸 목표로 합니다. LXC(리눅스 컨테이너)라는 독특한 개념에서 출발하는 Docker의 가상화는 기존에 운영체제를 통째로 가상화하는 것과는 접근 자체를 달리합니다. 가상 머신이라고 하기에는 격리된 환경을 만들어주는 도구라고 하는 게 맞을 지도 모릅니다.&lt;/p&gt;

&lt;p&gt;예를 들어 보죠. 우분투에서 CentOS라는 Docker를 통해 가상 환경을 구축하는데 얼마만큼의 시간이 걸릴까요? 먼저 여기서는 Ubuntu 상에서 작업을 한다고 가정하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ cat /etc/issue
Ubuntu 13.10 \n \l
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;실제로 도커는 LXC를 사용하기 때문에 특정 리눅스 배포판에서 사용할 수 있고, 윈도우나 맥에서는 사용이 불가능합니다. Docker가 설치되어 있다는 가정 하에 Ubuntu에서 CentOS 가상 머신을 띄우는 데는 아래 두 명령어만 실행시키면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker pull centos
$ docker run -rm -i -t centos:6.4 /bin/bash
bash-4.1#
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;먼저 위의 pull 명령어를 통해서 centos 이미지를 다운로드 받습니다. 그리고 이 이미지에 쉘 명령어를 실행시킵니다. 이걸로 끝입니다. 먼저 첫번째 명령어를 실행시키는데 제 컴퓨터에서 12초 정도가
걸렸습니다. 아래 명령어를 실행시키는데 0.3초가 걸리지 않았습니다. 쉘이 실행되면 bash 쉘로 바뀐 것을 알 수 있습니다. 실제로 CentOS인지 확인해보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
bash-4.1# cat /etc/issue
CentOS release 6.4 (Final)
Kernel \r on an \m
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;어떻게 이런 일이 가능할까요? 원리적인 부분은 이미 좋은 문서들이 있습니다. 한국어로 된 좋은 자료로는 Deview 2013에서 김영찬 님이 발표하신 &lt;a href="http://deview.kr/2013/detail.nhn?topicSeq=45"&gt;이렇게 배포해야 할까? - Lightweight Linux Container Docker 를 활용하여 어플리케이션 배포하기&lt;/a&gt; 세션과 xym 님이 쓴 &lt;a href="http://spoqa.github.io/2013/11/22/docker-the-cloud.html"&gt;docker the cloud&lt;/a&gt;를 추천합니다. 하지만 분명한 건 VMWare를 사용한다고 해서 가상화 기술에 빠삭해야하는 것이 아니듯이, Docker 역시 기본적으로는 툴이라는 사실을 이해해야합니다. 제 생각에 도커의 원리를 이해하는 것도 중요하지만, 막상 이 도구를 사용하는 동안엔 컨테이너와 이미지의 차이를 이해하는 게 더 중요하고, Dockerfile을 만들어 자신만의 배포 프로세스를 저장하는 법을 익히는 게 더 중요합니다.&lt;/p&gt;

&lt;p&gt;이 글에서는 바로 이러한 시점에서 개발 환경이자 배포 툴로써의 도커를 이해하기 위한 개념들을 소개하고 모니위키 어플리케이션을 도커로 설치하는 부분까지 다뤄보도록 하겠습니다. 각 부분에 대한 좀 더 자세한 이야기는 기회가 된다면 따로 다뤄보도록 하죠.&lt;/p&gt;

&lt;h2&gt;설치&lt;/h2&gt;

&lt;p&gt;각 운영체제 별 Docker의 설치 방법은 공식 홈페이지에 잘 정리되어 있습니다. 제가 사용하는 Ubuntu의 경우에는 Docker에서 제공하는 스크립트 파일 하나를 통해서 원큐에 정말 쉽게 Docker를 설치할 수 있습니다. 가상 머신에서도 설치가 가능하니, 가능하다면 Ubuntu 환경을 사용하길 권장합니다. 네, 글을 쓰는 편의상.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
curl -s https://get.docker.io/ubuntu/ | sudo sh
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;단, 당연히 curl이 설치 되어있어야합니다.[^1] 1월 현재 12.04 / 13.10에서도 같은 방법으로 설치가 가능했습니다만, 설치 과정에 문제가 있거나 다른 운영체제를 사용하시는 경우엔 설치 문서를 꼼꼼히 읽어보시고 진행해나가시기 바랍니다. 설치가 끝나면 설치가 잘 됐나 확인해봅니다.&lt;/p&gt;

&lt;p&gt;[^1]: &lt;code&gt;curl&lt;/code&gt;이 없다면 &lt;code&gt;sudo apt-get curl&lt;/code&gt;로 설치하시면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker -v
Docker version 0.7.6, build bc3b2ec
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Wow! 훌륭합니다. 필요하다면 ufw(방화벽) 설정을 통해서 도커가 사용하는 4243/tcp 포트도 열어줍니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
sudo ufw allow 4243/tcp
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;기본적으로 docker의 대부분의 명령어를 실행 시 root 권한이 필요합니다. 따라서 sudo를 사용해야하는 번거로움이 따라오는데, 이를 위해 현재 유저를 docker 그룹에 포함시켜 줍니다. &lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ sudo groupadd docker
$ sudo gpasswd -a ${USER} docker
$ sudo service docker restart
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;명령어들을 실행하고 재로그인을 하게 되면 더 이상 sudo 명령어를 앞에 붙이지 않아도 docker 명령을 사용할 수 있습니다. 단, 이 방법을 사용할 경우엔, 공식 문서에서도 경고하고 있듯이 docker group은 root와 같은 권한 가지고 있다는 사실을 인지하고 있어야합니다.&lt;/p&gt;

&lt;h2&gt;이미지(Image)&lt;/h2&gt;

&lt;p&gt;설치만 끝났다면, 이제 끝이 보입니다. 대단해보이지만 정말 별 게 없습니다. 먼저 도커를 시작하면 이미지 개념을 이해할 필요가 있습니다. 처음에 보여드린 예제를 보면 centos 이미지를 다운로드 받고, 이 이미지에 shell을 실행시킵니다. 그런데 여기에 약간의 함정이 있습니다. Docker에서 실제로 실행되는 건 이미지가 아닙니다! 이미지는 추상적인 개념입니다. 실행되는 건 이미지를 기반으로 생성된 컨테이너입니다. 먼저 어떤 일이 일어나는지 확인해보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;code&gt;docker images&lt;/code&gt; 명령어로 시스템에 어떤 이미지가 있는지 확인해보죠. &lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;docker images 명령어는 현재 시스템에서 사용가능한 이미지 일람을 보여줍니다. 이미지가 어디서 오는지 궁금하게 느껴지실지도 모릅니다. 이미지는 크게 세 가지 방법을 통해서 추가할 수 있습니다.&lt;/p&gt;

&lt;p&gt;하나는 처음 예제에서와 마찬가지로 &lt;code&gt;docker pull &amp;lt;이미지 이름&amp;gt;&lt;/code&gt;을 통해서 가져오는 방법입니다. 바로 이 명령어를 사용하면 docker.io의 공식 저장소에서 이미지를 다운로드 받아옵니다. 쉘을 활용하는 개발자라면 이런 개념이 낯설지는 않을 것입니다. 리눅스에서 &lt;code&gt;apt-get&lt;/code&gt;이나 &lt;code&gt;yum&lt;/code&gt; 혹은 &lt;code&gt;gem&lt;/code&gt;이나 &lt;code&gt;pip&lt;/code&gt;, &lt;code&gt;cpan&lt;/code&gt;, &lt;code&gt;npm&lt;/code&gt; 같은 명령어를 사용해보셨다면 바로 이해하실 수 있을 겁니다. 이런 유틸리티를 사용해본 적이 없다고 하더라도 마찬가지 개념으로 docker 이미지 파일들을 관리하는 중앙 저장소가 있다고 이해하셔도 무방합니다. 독특한 점은 &lt;code&gt;intsall&lt;/code&gt;이 아닌 &lt;code&gt;pull&lt;/code&gt; 명령어를 사용한다는 점입니다. 이에 대해서는 개념적으로 VCS(버전 관리 시스템)을 알고 계신다면 추가적인 설명이 필요없겠습니다만, 어쨌거나 단순히 다운로드라고 이해하셔도 현재 단계에서는 무방합니다.&lt;/p&gt;

&lt;p&gt;(두 번째 방법 커밋을 하는 방법입니다. 아래에서 설명합니다. 또 다른 방법은 Dockerfile을 통해서 기술된 과정을 거쳐 도커 이미지를 생성하는 방법입니다. 이에 대해서는 맨 마지막에 자세히 다룹니다.)&lt;/p&gt;

&lt;p&gt;여기서는 편의상 ubuntu 이미지를 다운로드 받아오겠습니다. 이 이미지에 대한 정보는 웹을 통해서 확인하실 수 있습니다. 공식 저장소에 있는 이미지 정보들은 https://index.docker.io에서 확인할 수 있으며 우분투 이미지에 관해서는 &lt;a href="https://index.docker.io/_/ubuntu/"&gt;이 페이지&lt;/a&gt;에서 찾을 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker pull ubuntu
Pulling repository ubuntu
04180f9bd8a6: Download complete
1e548c932d40: Download complete
5e94ff221e91: Download complete
b750fe79269d: Download complete
3e47bae8d07a: Download complete
43461fe97ba1: Download complete
8dbd9e392a96: Download complete
511136ea3c5a: Download complete
27cf78414709: Download complete
46e4dee27895: Download complete
86f6383454b4: Download complete
7a4f87241845: Download complete
1957a8106a4c: Download complete
b74728ce6435: Download complete
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;도커가 무언가를 열심히 다운로드 받습니다. 사실 이것들 하나하나가 이미지라는 것을 이해할 필요가 있습니다. 우분투 하나를 설치했을 뿐인데, 무려 14개의 이미지를 다운로드 받았습니다. 다운로드가 전부 끝났으면 이제 다시 이미지들을 확인해봅니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu              saucy               43461fe97ba1        3 days ago          144.6 MB
ubuntu              raring              5e94ff221e91        3 days ago          133.6 MB
ubuntu              quantal             3e47bae8d07a        3 days ago          127.6 MB
ubuntu              lucid               04180f9bd8a6        3 days ago          139.6 MB
ubuntu              precise             1e548c932d40        3 days ago          125.9 MB
ubuntu              12.04               8dbd9e392a96        9 months ago        128 MB
ubuntu              latest              8dbd9e392a96        9 months ago        128 MB
ubuntu              12.10               b750fe79269d        10 months ago       175.3 MB
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;그런데 저는 위에서 다운로드 받은 것들 하나하나가 이미지라고 얘기했는데 이상하게도 다운받은 이미지수와 실제로 출력되는 이미지 수가 맞지 않습니다. 이를 확인하기 위해서는 이번엔 &lt;code&gt;-a&lt;/code&gt; 플래그를 통해서 모든 이미지를 출력해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu              saucy               43461fe97ba1        3 days ago          144.6 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              86f6383454b4        3 days ago          0 B
ubuntu              raring              5e94ff221e91        3 days ago          133.6 MB
ubuntu              quantal             3e47bae8d07a        3 days ago          127.6 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              1957a8106a4c        3 days ago          0 B
ubuntu              lucid               04180f9bd8a6        3 days ago          139.6 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              7a4f87241845        3 days ago          0 B
ubuntu              precise             1e548c932d40        3 days ago          125.9 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              46e4dee27895        5 weeks ago         0 B
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              b74728ce6435        5 weeks ago         0 B
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              511136ea3c5a        7 months ago        0 B
ubuntu              12.04               8dbd9e392a96        9 months ago        128 MB
ubuntu              latest              8dbd9e392a96        9 months ago        128 MB
ubuntu              12.10               b750fe79269d        10 months ago       175.3 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              27cf78414709        10 months ago       175.3 MB
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-a&lt;/code&gt;(&lt;code&gt;-a=false: show all images&lt;/code&gt;) 플래그는 이미지를 빌드하는 과정에서 생성되는 모든 이미지를 보여줍니다. 자세히 보시면 저장소(Repository)가 &lt;code&gt;&amp;lt;none&amp;gt;&lt;/code&gt;인 이미지들이 존재하는 것을 알 수 있습니다. &lt;code&gt;-a&lt;/code&gt; 플러그의 설명에서 알 수 있듯이 이 이미지들은 최종적인 이미지를 생성하는 과정에서 생성되는 중간 이미지들입니다. 나머지 다수의 우분투 이미지들은 TAG에서 보시듯이 다양한 버전의 이미지가 등록된 것을 알 수 있습니다.&lt;/p&gt;

&lt;h2&gt;컨테이너(Container)&lt;/h2&gt;

&lt;p&gt;다시 한 번 특정 이미지의 쉘에 접근해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker run -i -t ubuntu:12.04 /bin/bash
root@8bfd70fe7392:/#
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;우분투 안에 우분투에 접속하는데 성공했습니다! 짝짝짝. 그런데 앞서 말씀드렸다싶이 &lt;strong&gt;이미지에 접속했다&lt;/strong&gt;는 말에는 함정이 있습니다. 이 말은 마치 가상머신 ssh 프로토콜을 사용해 접근한 것과 같은 착각을 일으킵니다. 이제 새로운 명령어를 하나 배워보도록 하겠습니다. 앞서서 우리가 사용한 사용가능한 이미지들을 확인하는 명령어는 &lt;code&gt;docker images&lt;/code&gt;입니다. 이번에 사용할 명령어는 현재 실행중인 컨테이너들을 출력하는 명령어 &lt;code&gt;docker ps&lt;/code&gt;입니다. 별도의 쉘이나 터미널을 열고 &lt;code&gt;docker ps&lt;/code&gt; 실행시켜보시기 바랍니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
0fae5858c9c0        ubuntu:12.04        /bin/bash           8 seconds ago       Up 7 seconds                            sleepy_nobel
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;8초전에 만들어진 컨테이너가 실행되고 있는 것을 알 수 있습니다. 여기서 우리가 실행한 컨테이너 정보를 알 수 있습니다. 우리는 &lt;code&gt;ubuntu:12.04&lt;/code&gt; 이미지로부터 컨테이너를 생성했고, 이 컨테이너에 &lt;code&gt;/bin/bash&lt;/code&gt;라는 쉘을 실행시켰습니다. 그 외에도 맨 앞의 컨테이너 아이디는 앞으로 Docker에서 컨테이너를 조작할 때 사용하는 컬럼이기 때문에 필수적으로 알아둘 필요가 있습니다.&lt;/p&gt;

&lt;p&gt;유난처럼 느껴질지도 모릅니다만, 이미지와 컨테이너를 정확하게 짚고 넘어갈 필요가 있습니다. 하지만 그렇다고 이미지와 컨테이너 개념은 아주 헷갈리는 개념인 것은 아닙니다. 단지 이미지는 추상적인 존재라는 것을 이해하실 필요가 있습니다.&lt;/p&gt;

&lt;p&gt;또한 위의 예제에서는 직접 명령어를 넘겨서 이미지를 컨테이너로 실행시켰습니다만, 보통 이미지들은 자신이 실행할 명령어들을 가지고 있습니다. 예를 들어 레디스, 마리아DB, 루비 온 레일즈 어플리케이션을 담고 있는 이미지라면, 각각의 어플리케이션을 실행하는 스크립트를 실행하게되겠죠. 컨테이너는 독립된 환경에서 실행됩니다만, 컨테이너의 기본적인 역할은 이 미리 규정된 명령어를 실행하는 일입니다. 이 명령어가 종료되면 컨테이너도 종료 상태(Exit)에 들어갑니다. 이러한 죽은 컨테이너의 목록까지 확인하려면 &lt;code&gt;docker ps -a&lt;/code&gt; 명령어를 사용하면 됩니다. 실제로 쉘을 종료하고 컨테이너 목록을 확인해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
root@d02cd092f62d:/# exit
exit
$ docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
e2af61348652        ubuntu:12.04        /bin/bash           2 minutes ago       Exit 0                                  nostalgic_fermi  
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;상태(Status) 컬럼에서 확인할 수 있듯이 컨테이너가 임종하셨습니다. 이번엔 &lt;code&gt;restart&lt;/code&gt; 명령어를 통해 이미지를 되살려보겠습니다. &lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker restart e2af613
e2af613
$ sudo docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
e2af61348652        ubuntu:12.04        /bin/bash           4 minutes ago       Up 6 seconds                            nostalgic_fermi  
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;컨테이너가 되살아났습니다! 하지만 쉘이 실행되지는 않습니다. 컨테이너 속으로 들어가기 위해서는 &lt;code&gt;attach&lt;/code&gt; 명령어를 사용할 필요가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker attach e2af613
root@e2af61348652:/#
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;다시 docker 컨테이너 안으로 들어왔습니다! WoW! 부활의 기적을 여기서 만나는군요. 여기까지 도커 컨테이너의 생명 주기를 보았습니다. 도커 컨테이너를 실행시키는 &lt;code&gt;run&lt;/code&gt;부터 실행이 종료되었을 때 다시 실행하는 &lt;code&gt;restart&lt;/code&gt;를 배웠습니다. 이 외에도 실행을 강제로 종료시키는 &lt;code&gt;stop&lt;/code&gt; 명령어도 있으며, 종료된 컨테이너를 영면으로 이끌어주는 &lt;code&gt;rm&lt;/code&gt; 명령어도 있습니다. 잠시 기억을 더듬어 올라가 이 글의 아주 처음에 &lt;code&gt;run&lt;/code&gt; 명령어와 함께 사용한 &lt;code&gt;-rm&lt;/code&gt; 플래그는 컨테이너가 종료 상태로 들어가면 자동으로 삭제를 해주는 옵션입니다.&lt;/p&gt;

&lt;p&gt;네, 다시 한 번 이야기합니다. 이미지에는 접속한다는 개념이 없습니다. 실제로 실행되는 &lt;strong&gt;가상 머신&lt;/strong&gt;은 항상 컨테이너입니다. 분명 저는 &amp;#39;명령어&amp;#39;를 실행시킨다고 했습니다만, 컨테이너란 격리된 환경에서 특정한 명령을 실행시켜주는 가상 머신과 같은 무언가입니다. 그렇다면 쉘을 실행시키지 않았을 때 이 가상 머신을 조작할 수 있는 방법이 있을까요? 원론적으로 불가능한 것은 아닙니다. 이 부분에 대해서 여기선 다루지 않습니다만, 직접 파일 시스템을 조작할 수도 있고, 리눅스 컨테이너를 조작해 특정 컨테이너에 대해 쉘을 실행시킬 수도 있습니다. 하지만 좀 더 정상적인 방법은 조작이 필요한 컨테이너에 ssh 서비스를 올려서 ssh 프로토콜로 접근하는 방법입니다. 실제 도커로 서비스를 운영하면 이런 부분이 절실할 날이 오겠지만, 일단은 그렇구나 하고 넘어가셔도 무방합니다.&lt;/p&gt;

&lt;h2&gt;버전 관리 시스템과 도커&lt;/h2&gt;

&lt;p&gt;다시 이미지로 돌아가겠습니다. 누누이 강조하지만 이미지와 컨테이너는 다릅니다. 좋습니다. 그렇다면 한가지 질문을 던져보죠. 그렇다면 이 컨테이너를 지지고 볶고 삶고 데치고 하면 이미지는 어떻게 될까요?&lt;/p&gt;

&lt;p&gt;당연히 이미지에는 아무런 변화도 생기지 않습니다. 아주 세속적인 예를 들어보면 윈도우 CD로 윈도우를 설치해서 사용한다고 해서 설치한 윈도우 CD에 어떤 변화가 생기지는 않는 것과 같은 이치입니다. 이미지는 어디까지나 고정된 이미지입니다. 도커에서 이미지는 불변(Immutable)하는 저장 매체입니다. 그런데 도커에서 이미지는 불변이지만 이 이미지 위에 무언가를 더해서 새로운 이미지를 만들어내는 일이 가능합니다. 좀 더 정확히 말하면 컨테이너는 변경가능(Mutabe)합니다. 특정한 이미지로부터 생성된 컨테이너에 어떤 변경사항을 더하고, 이 변경된 상태를 이미지로 만들어내는 것이 가능합니다.&lt;/p&gt;

&lt;p&gt;앞서 실행한 컨테이너에 Git을 설치해보겠습니다. 위에서 실행한 쉘에 다음과 같은 명령어를 입력합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
root@e2af61348652:/# apt-get install -y git
...
root@e2af61348652:/# git --version
git version 1.7.9.5
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;우분투의 패키지 관리자인 apt-get을 통해서 버전 관리 시스템인 &lt;code&gt;Git&lt;/code&gt;을 설치했습니다. 여기서 도커는 마치 자신이 VCS인양, 어떤 컨테이너와 이 컨테이너의 부모 이미지 간의 파일의 변경사항을 확인할 수 있는 명령어를 제공합니다. 마치 &lt;code&gt;git diff&lt;/code&gt; 명령어로 프로젝트의 변경사항을 확인하듯이, &lt;code&gt;docker diff&lt;/code&gt; 명령어로 부모 이미지와 여기서 파생된 컨테이너의 파일 시스템 간의 변경사항을 확인할 수 있습니다. &lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker diff e2af61
A /.bash_history
A /.wh..wh.plnk/310.4862541
A /.wh..wh.plnk/93.4862548
C /bin
A /bin/less
...
C /var/log/alternatives.log
C /var/log/apt
A /var/log/apt/history.log
A /var/log/apt/term.log
C /var/log/dpkg.log
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이제 기본 우분투 12.04 이미지에 Git가 설치된 새로운 이미지를 생성해보도록 하겠습니다. 이 작업도 VCS와 매우 비슷합니다. 도커에서는 이 작업을 &lt;code&gt;commit&lt;/code&gt;이라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker commit e2af61 ubuntu:git
5ff1d6b1c5db272c3f1a88c96f78146ed48d18848f0a10e6aefa066b462ff5ee
$ docker images | grep git
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu              git                 5ff1d6b1c5db        About a minute ago   222.3 MB
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이미지 만들기 정말 쉽죠? 단지 커밋을 하고 뒤에 이름을 붙여주면 바로 새로운 도커 이미지가 생성됩니다. 이미지로부터 컨테이너를 실행시키고 이 컨테이너의 수정사항을 통해서 새로운 이미지를 만들었습니다. 그렇다면 정말로 이 이미지를 통해서 컨테이너를 실행시키면(&lt;code&gt;run&lt;/code&gt;) git가 실해될까요? 직접 확인해보죠.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker run -i -t ubuntu:git /bin/bash
root@27d4e3090750:/# git --version
git version 1.7.9.5
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;감동에 눙물이 나올 것 같습니다 TT.&lt;/p&gt;

&lt;p&gt;하지만 이 이미지는 별로 필요가 없군요. 냉정하게 필요없는 이미지는 삭제해버리겠습니다. 하나 알아두셔야 하는 중요한 사항은, 이미지에서 (종료상태를 포함한) 파생된 컨테이너가 하나라도 있다면 이미지는 삭제할 수 없습니다. (처음에 이 부분을 정확히 이해하지 못 해 한참을 해맸던 기억이 납니다) 따라서 먼저 컨테이너를 종료하고, 삭제까지 해주어야합니다. &lt;code&gt;docker rm&lt;/code&gt;은 컨테이너를 삭제하는 명령어입니다. &lt;code&gt;docker rmi&lt;/code&gt;는 이미지를 삭제하는 명령어입니다. 이 두 명령어를 혼동하지 않아야합니다.&lt;/p&gt;

&lt;p&gt;먼저 컨테이너를 지우고, 이미지를 삭제해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
27d4e3090750        ubuntu:git          /bin/bash           4 minutes ago       Exit 0                                  silly_heisenberg
$ docker rm 27d4e
27d4e
$ docker rmi ubuntu:git
Untagged: 5ff1d6b1c5db272c3f1a88c96f78146ed48d18848f0a10e6aefa066b462ff5ee
Deleted: 5ff1d6b1c5db272c3f1a88c96f78146ed48d18848f0a10e6aefa066b462ff5ee
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;브라보! 이번에는 도커 이미지의 생명주기를 배웠습니다. 도커 이미지를 &lt;code&gt;pull&lt;/code&gt;로 받아오고 &lt;code&gt;commit&lt;/code&gt;
으로 파생된 이미지를 만들고 &lt;code&gt;rmi&lt;/code&gt; 명령어로 삭제까지 해보았습니다. 컨테이너와 이미지의 생명주기만 이해하고 나면 도커의 80%는 이해한 거나 다름 없습니다. 도커를 통해서 하는 일은 거의 다 이 이미지와 컨테이너 개념으로 커버가 가능합니다. 이제 남은 일은 자신에게 필요한 &lt;strong&gt;이미지&lt;/strong&gt;를 만들고 이 이미지를 통해서 컨테이너(가상 머신)를 실행하는 일입니다. 물론 이제 기본적인 개념들을 배웠으니 오픈된 중앙 저장소격에 해당하는 &lt;a href="https://index.docker.io/"&gt;Docker Index&lt;/a&gt;에서 이미 만들어져있는 다양한 이미지들을 활용할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;무엇을 하건 도커의 모토를 잊지 마시기 바랍니다. 거짓말 조금 보태서(?!) 완성된 이미지는 언제 어디에 서라 도  가동 가능합니다.&lt;/p&gt;

&lt;h2&gt;Dockerfile로 이미지 생성하고 어플리케이션 실행시키기&lt;/h2&gt;

&lt;p&gt;멀리 돌아왔습니다. 앞서서 도커 이미지를 추가하는 방법은 크게 세 가지가 있다고 이야기했습니다. 먼저 &lt;code&gt;pull&lt;/code&gt;을 사용하는 방법은 이미 앞에서 다룬 바 있습니다. 그리고 컨테이너의 변경사항으로부터 이미지를 만드는 법에 대해서도 소개했습니다. 이러한 방법들은 매우 좋기는 하지만, 어딘가 2% 부족합니다. 이를 보완해주는 Dockerfile이라고 불리는 도커 이미지 생성용 배치 파일이 있습니다.&lt;/p&gt;

&lt;p&gt;Dockerfile은 특정한 이미지를 출발점으로 새로운 이미지 구성에 필요한 일련의 명령어들을 저장해놓는 파일입니다. 미리 만들어둔 docker-moniwiki라는 프로젝트를 통해서 간단히 Dockerfile을 설명하고, 실제로 모니위키 어플리케이션을 가진 이미지를 생성하고 컨테이너를 통해서 실행시켜보도록하겠습니다. 먼저 프로젝트를 clone 받습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
git clone https://github.com/nacyot/docker-moniwiki.git
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이 프로젝트에는 3개의 파일이 있습니다만, 실질적으로 Dockerfile 하나밖에 없다고 보셔도 무방합니다. 전체 파일 내용은 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;```
FROM ubuntu:12.04
MAINTAINER Daekwon Kim &lt;a href="mailto:propellerheaven@gmail.com"&gt;propellerheaven@gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Run upgrades&lt;/h1&gt;

&lt;p&gt;RUN echo &amp;quot;deb http://archive.ubuntu.com/ubuntu precise main universe&amp;quot; &amp;gt; /etc/apt/sources.list
RUN apt-get update&lt;/p&gt;

&lt;h1&gt;Install basic packages&lt;/h1&gt;

&lt;p&gt;RUN apt-get -qq -y install git curl build-essential&lt;/p&gt;

&lt;h1&gt;Install apache2&lt;/h1&gt;

&lt;p&gt;RUN apt-get -qq -y install apache2
ENV APACHE&lt;em&gt;RUN&lt;/em&gt;USER www-data
ENV APACHE&lt;em&gt;RUN&lt;/em&gt;GROUP www-data
ENV APACHE&lt;em&gt;LOG&lt;/em&gt;DIR /var/log/apache2
RUN a2enmod rewrite&lt;/p&gt;

&lt;h1&gt;Install php&lt;/h1&gt;

&lt;p&gt;RUN apt-get -qq -y install php5
RUN apt-get -qq -y install libapache2-mod-php5&lt;/p&gt;

&lt;h1&gt;Install Moniwiki&lt;/h1&gt;

&lt;p&gt;RUN apt-get install rcs
RUN cd /tmp; curl -L -O http://dev.naver.com/frs/download.php/8193/moniwiki-1.2.1.tgz
RUN tar xf /tmp/moniwiki-1.2.1.tgz
RUN mv moniwiki /var/www/
RUN chown -R www-data:www-data /var/www/moniwiki
RUN chmod 777 /var/www/moniwiki/data/ /var/www/moniwiki/
RUN chmod +x /var/www/moniwiki/secure.sh
RUN ./var/www/moniwiki/secure.sh&lt;/p&gt;

&lt;p&gt;EXPOSE 80
CMD [&amp;quot;/usr/sbin/apache2&amp;quot;, &amp;quot;-D&amp;quot;, &amp;quot;FOREGROUND&amp;quot;]
```&lt;/p&gt;

&lt;p&gt;보시는 바와 같이 Dockerfile은 모니위키를 설치하는 일련의 과정과 서버를 실행하는 명령어로 구성되어 있습니다. 각각의 부분을 간략히 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
FROM ubuntu:12.04
MAINTAINER Daekwon Kim &amp;lt;propellerheaven@gmail.com&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;먼저 맨 위에 정의된 &lt;code&gt;FROM&lt;/code&gt;은 어떤 이미지로부터 새로운 이미지를 생성할 지를 지정합니다. 다음으로 MAINTAINER는 이 Dockerfile을 생성-관리하는 사람을 입력해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
RUN echo &amp;quot;deb http://archive.ubuntu.com/ubuntu precise main universe&amp;quot; &amp;gt; /etc/apt/sources.list
RUN apt-get update
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RUN&lt;/code&gt;은 직접 쉘 명령어를 실행하는 명령어입니다. 이 때 바로 뒤에 명령어를 입력하게 되면 쉘을 통해서 명령어가 실행됩니다. 위의 두 줄은 패키지 관리자 &lt;code&gt;apt-get&lt;/code&gt;에 저장소를 추가하고 저장소 정보를 갱신하는 명령어입니다.&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h1&gt;Install basic packages&lt;/h1&gt;

&lt;p&gt;RUN apt-get -qq -y install git curl build-essential&lt;/p&gt;

&lt;h1&gt;Install apache2&lt;/h1&gt;

&lt;p&gt;RUN apt-get -qq -y install apache2
ENV APACHE&lt;em&gt;RUN&lt;/em&gt;USER www-data
ENV APACHE&lt;em&gt;RUN&lt;/em&gt;GROUP www-data
ENV APACHE&lt;em&gt;LOG&lt;/em&gt;DIR /var/log/apache2
RUN a2enmod rewrite&lt;/p&gt;

&lt;h1&gt;Install php&lt;/h1&gt;

&lt;p&gt;RUN apt-get -qq -y install php5
RUN apt-get -qq -y install libapache2-mod-php5
```&lt;/p&gt;

&lt;p&gt;다음 부분에서는 모니위키 설치에 필요한 패키지들과 apache2 서버, php 프로그램을 설치 및 설정해줍니다. 아파치 설치 과정에서 나오는 &lt;code&gt;ENV&lt;/code&gt;를 통해 환경 변수를 지정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h1&gt;Install Moniwiki&lt;/h1&gt;

&lt;p&gt;RUN apt-get install rcs
RUN cd /tmp; curl -L -O http://dev.naver.com/frs/download.php/8193/moniwiki-1.2.1.tgz
RUN tar xf /tmp/moniwiki-1.2.1.tgz
RUN mv moniwiki /var/www/
RUN chown -R www-data:www-data /var/www/moniwiki
RUN chmod 777 /var/www/moniwiki/data/ /var/www/moniwiki/
RUN chmod +x /var/www/moniwiki/secure.sh
RUN ./var/www/moniwiki/secure.sh
```&lt;/p&gt;

&lt;p&gt;이제 실제로 모니위키를 설치합니다. 여기서는 모니위키를 curl을 통해서 다운로드 받고, 압축을 풀고 모니위키 실행에 필요한 권한 관련 설정을 해주고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
EXPOSE 80
CMD [&amp;quot;/usr/sbin/apache2&amp;quot;, &amp;quot;-D&amp;quot;, &amp;quot;FOREGROUND&amp;quot;]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이제 마지막입니다. &lt;code&gt;EXPOSE&lt;/code&gt;는 가상 머신에 오픈할 포트를 지정해줍니다. 마지막줄의 &lt;code&gt;CMD&lt;/code&gt;는 컨테이너에서 실행될 명령어를 지정해줍니다. 이 글의 앞선 예에서는 &lt;code&gt;docker run&lt;/code&gt;을 통해서 &lt;code&gt;/bin/bash&lt;/code&gt;를 실행했습니다만, 여기서는 아파치 서버를 &lt;code&gt;FOREGROUND&lt;/code&gt;에 실행시킵니다.&lt;/p&gt;

&lt;p&gt;자 기다리고 기다리던 대망의 순간이 왔습니다. 직접 이 Dockerfile을 빌드할 차례입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker build -t nacyot/moniwiki .
Uploading context 71.68 kB
Uploading context
Step 1 : FROM ubuntu:12.04
---&amp;gt; 8dbd9e392a96
Step 2 : MAINTAINER Daekwon Kim &amp;lt;propellerheaven@gmail.com&amp;gt;
---&amp;gt; Running in a2af31ca9d62
---&amp;gt; c42835b9308b
Step 3 : RUN echo &amp;quot;deb http://archive.ubuntu.com/ubuntu precise main universe&amp;quot; &amp;gt; /etc/apt/sources.list
---&amp;gt; Running in d305ce1fea04
---&amp;gt; f4cb16c39b0e
Step 4 : RUN apt-get update
...
---&amp;gt; c63d093aacfb
Step 21 : EXPOSE 80
---&amp;gt; Running in cee6a6048c83
---&amp;gt; 7436a638e52c
Step 22 : CMD [&amp;quot;/usr/sbin/apache2&amp;quot;, &amp;quot;-D&amp;quot;, &amp;quot;FOREGROUND&amp;quot;]
---&amp;gt; Running in 2f251c355290
---&amp;gt; 0a148bb4de2f
Successfully built 0a148bb4de2f
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker build&lt;/code&gt; 명령어는 &lt;code&gt;-t&lt;/code&gt; 플래그를 사용해 이름과 태그를 지정할 수 있습니다. 그리고 마지막에 &lt;code&gt;.&lt;/code&gt;은 빌드 대상 디렉토리를 가리킵니다. 이 때 알아두면 좋은 게 하나 있습니다. 위에서 정의한 &lt;code&gt;RUN&lt;/code&gt; 명령 하나 하나는 명령 하나마다 이미지가 됩니다. 기본적으로 이 빌드를 통해서 생성되는 최종 이미지는 &lt;code&gt;nacyot/moniwi&lt;/code&gt;가 됩니다만, &lt;code&gt;docker images -a&lt;/code&gt;를 통해서 살펴보면 이름없는 도커 이미지들이 다수 생성되는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker images -a
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              c63d093aacfb        4 minutes ago       670.4 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              7436a638e52c        4 minutes ago       670.4 MB
nacyot/moniwiki     latest              0a148bb4de2f        4 minutes ago       670.4 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              49825025193f        4 minutes ago       670.4 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              5b374f859553        4 minutes ago       670.4 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              c8afe13ab509        4 minutes ago       670.4 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              bb65aa482123        4 minutes ago       663.1 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              fa7f2059c9ba        4 minutes ago       655.8 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              1a18589e4d9a        4 minutes ago       648.5 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              fdd759b53314        4 minutes ago       646.1 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              786c8ad1df43        4 minutes ago       610.5 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              14e8b032683a        4 minutes ago       610.5 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              6be08754c2ae        4 minutes ago       547.9 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              67e17f5a39f1        4 minutes ago       547.9 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              55ec9487188b        4 minutes ago       547.9 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              88a61604a1d0        4 minutes ago       547.9 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              7edabbb84352        4 minutes ago       547.9 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              78e9afc826cd        4 minutes ago       503 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              8066398c160f        5 minutes ago       272.5 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              f4cb16c39b0e        6 minutes ago       128 MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              c42835b9308b        6 minutes ago       128 MB
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이미지 아이디가 빌드 과정에서 출력되는 아이디와 같은 것을 알 수있습니다. 필요한 경우 중간 이미지에 접근하거나 직접 중간 이미지로부터 다른 이미지를 생성하는 것도 가능합니다. 정말 좋은 소식은 도커는 이러한 빌드 순서를 기억하고 각 이미지를 보존하기 때문에 같은 빌드 과정에 대해서는 캐시를 사용해 매우 빠르게 빌드가 가능하다는 점입니다. 실제로 Docker 파일을 만드는 과정에서는 많은 시행 착오를 겪게되는데, 중간에 빌드가 실패하더라도 성공했던 명령어까지는 거의 시간 소모 없이 빠르게 진행되도록 설계되어있습니다.&lt;/p&gt;

&lt;p&gt;빌드 자체는 꽤나 번거로운 일입니다. 도커의 가상화가 굉장히 빠르다고 해도 어플리케이션 실행환경을 구축하는 일은 상당히 시간도 많이 걸립니다. 더욱이 빌드 자체는 완벽히 &amp;#39;재현 가능&amp;#39;하지 않습니다. 하지만 이렇게 Dockerfile을 통해서 배치화를 시켜두면 Dockerfile이라는 정말 작은 파일 하나로 어플리케이션 배포 환경을 구축할 수 있다는 장점이 있으며, 또한 쉽게 유연하게 사용할 수 있습니다. 아주 흥미로운 이야기를 하나 해드리자면 Docker 생태계에 있는 오픈소스 어플리케이션들은 아예 Dockerfile을 프로젝트에 포함하고 있습니다. 대표적으로 도커 모니터링 툴인 &lt;a href="https://github.com/shipyard/shipyard"&gt;Shipyard&lt;/a&gt;가 있습니다. 여기서 제공하는 Dockerfile을 빌드해서 이미지를 만들고, 이 이미지로 컨테이너를 가동하면 바로 shipyard 어플리케이션을 사용할 수 있습니다. 전율이 느껴지시나요?&lt;/p&gt;

&lt;p&gt;Dockerfile은 단순히 어플리케이션 설치를 스크립트로 만들어주는 게 아니라, 배포환경 구축까지 한꺼번에 해주는 역할을 합니다. 오래전 제로보드나 테터툴즈 한 번 설치해보겠다고 &lt;code&gt;&amp;lt;? phpinfo() ?&amp;gt;&lt;/code&gt; 찍어가며 php랑 aphche랑 잘 붙었나 안 붙었나 확인해보고 안 되면 이유도 못 찾아 혼자 서러워했던 적이 있는 분이라면(어라?) 이해하리라 믿습니다. 다른 예를 들어볼까요? 설치가 까다로운 걸로 악명높은 오픈소스 웹 어플리케이션 중에 &lt;a href="http://gitlab.org/"&gt;Gitlab&lt;/a&gt;이라는 어플리케이션이 있습니다. &lt;a href="https://github.com/crashsystems/gitlab-docker"&gt;gitlab-docker&lt;/a&gt;에서 제공하는 &lt;code&gt;Dockerfile&lt;/code&gt; 하나면 이제 Gitlab도 두렵지 않습니다. 그저 &lt;code&gt;Build&lt;/code&gt;하고 &lt;code&gt;Run&lt;/code&gt;하면 Gitlab이 뜹니다.&lt;/p&gt;

&lt;p&gt;네, 얘기가 길어졌네요. 다시 모니위키로 돌아갑니다. 빌드가 끝났으니 실행을 해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ docker run -d -p 9999:80 nacyot/moniwiki
746443ad118afdb3f254eedaeeada5abc2b125c7263bc5e67c2964b570166187
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;다시 &lt;code&gt;docker run&lt;/code&gt; 입니다. 이번에는 &lt;code&gt;-d&lt;/code&gt;와 &lt;code&gt;-p&lt;/code&gt; 플래그를 사용합니다. 앞서서 자세히 설명하진 않았습니다만, &lt;code&gt;-d&lt;/code&gt; 플래그는 &lt;code&gt;-i&lt;/code&gt; 플래그의 반대 역할을 하는 플래그로, 컨테이너늘 백그라운드에서 실행시켜줍니다. &lt;code&gt;-p&lt;/code&gt;는 포트포워딩을 지정하는 플래그입니다. &lt;code&gt;:&lt;/code&gt;을 경계로 앞에는 외부 포트, 뒤로는 내부 포트입니다. 참고로 컨테이너 안에서 아파치가 80포트로 실행됩니다. 따라서 여기서는 localhost에 9999로 들어오는 연결을 여기서 실행한 컨테이너의 80포트로 보내도록합니다.&lt;/p&gt;

&lt;p&gt;이제 정말 마지막입니다. 로컬의 9999 포트에 접근해 정말로 모니위키가 실행되는지 보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
http://127.0.0.1:9999/moniwiki/
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt="모니위키 설치 페이지" src="../../images/2014-01-27-easy-deploy-with-docker/moniwiki.png" /&gt;&lt;/p&gt;

&lt;p&gt;올레! 잘 돌아가네요. &lt;/p&gt;

&lt;h2&gt;정리&lt;/h2&gt;

&lt;p&gt;도커의 활용가능성은 무궁무진합니다. 당연히 실제 배포에도 사용할 수 있고, 유연하고 날렵한 격리된 환경을 활용해 실험적인 개발을 진행할 수도 있습니다. Vagrant보다도 훨씬 빠른 가상 환경을 활용할 수 있으며 접근 방법은 다르지만 서버환경을 자동적으로 구성할 수도 있습니다. 미리 만든 이미지를 자신의 저장소(registry)에 등록해 여러대의 머신에 컨테이너들을 자동적으로 배포할 수도 있고, 오픈소스 프로젝트에서 Dockerfile을 제공해 설치를 색다른 방법으로(?) 지원할 수도 있습니다. &lt;a href="https://github.com/progrium/dokku"&gt;Dokku&lt;/a&gt;를 사용하면 정말 쉽게 mini-heroku와 같은 PaaS 플랫폼을 구축해 볼 수도 있습니다.&lt;/p&gt;

&lt;p&gt;단순히 생산성을 넘어, 도커의 매력은 상상력을 자극한다는 점입니다. 특히나 서버 자동화가 화두인 요즘에 인프라스트럭쳐가 &lt;strong&gt;코드&lt;/strong&gt;로 변해버리는 묘한 체험을 하게 해줍니다. 인프라스트럭쳐가 코드가 되면 뭔가 신기한 일들이 벌어집니다. 이런 상황에서 아직까지 낯설게 느껴질지도 모르는 개념이고 툴입니다만 직접 설치하고  이것저것 해보다보면 저처럼 분명 반하실 거라 생각합니다 :)&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>우분투 13.10 개발환경 세팅</title>
    <link rel="alternate" href="http://blog.nacyot.com/articles/2014-01-18-ubuntu-setting/"/>
    <id>http://blog.nacyot.com/articles/2014-01-18-ubuntu-setting/</id>
    <published>2014-01-17T15:00:00Z</published>
    <updated>2014-02-16T15:50:24+00:00</updated>
    <author>
      <name>nacyot(Daekwon Kim)</name>
    </author>
    <content type="html">&lt;p&gt;Ubuntu 13.10 개발 환경 세팅 정리. 서버면 자동화시키는 것도 좋은 방법일 듯 한데, 데스크탑은 그래픽 드라이버 같은 부분이 컴퓨터마다 다르다 보니 완전히 자동화하는 건 쉽지 않은 것 같다. 지난 번까지 우분투 13.04 써왔는데(지금 노트북도 13.04), 이번에 새로 13.10에 도전해봤다. 사실 그래픽 드라이버 문제로 13.04로 낮추고 싶었으나, 조만간 지원이 끝난다고 하길래 맘 잡고 13.10으로 개발환경 정리를 했다. 금요일 오전 내내 걸렸으니까 전체 세팅하는데 4~5시간 정도 걸린 것 같다. 이걸로 기본적인 부분은 정리가 된 듯 싶고, 어디까지나 앞으로 삽질 방지용 포스트.&lt;/p&gt;

&lt;p&gt;참고로 본인은 Ubuntu / Terminator(터미널 프로그램) / Emacs(에디터) / Dvorak(키보드 레이아웃) 사용자.&lt;/p&gt;



&lt;h2&gt;Ubuntu 13.10 설치&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.ubuntu.com/download/desktop"&gt;우분투 공식 홈페이지&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우분투 13.10 설치. 우분투에는 기본적으로 setup disk creator이라는 어플이 들어가서 있어서 이걸로 usb에 옮겨담을 수 있는데 조금 문제가 있어서 윈도우에서 &lt;a href="http://www.linuxliveusb.com/"&gt;Linux Live USB Driver&lt;/a&gt;로 USB에 설치.&lt;/p&gt;

&lt;h2&gt;APT 다운로드 서버 설정&lt;/h2&gt;

&lt;p&gt;처음에 자동으로 업데이트를 실시하지만 패키지도 많고 상당히 시간이 오래걸린다. 이 때 미러 서버를 바꿔주면 속도가 많이 개선된다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;자동으로 뜨는 업데이트는 진행하지 말 것.&lt;/li&gt;
&lt;li&gt;System Settings&lt;/li&gt;
&lt;li&gt;Software &amp;amp; Updates&lt;/li&gt;
&lt;li&gt;Ubuntu Software 탭에서 Download from : http://ftp.daum.net/ubuntu&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;APT 다운로드 서버 설정. 자세히 알고 있다면 &lt;code&gt;/etc/apt&lt;/code&gt;에 설정 파일들을 직접 편집해도 되지만 보통 시스템 설정을 사용하는 게 편리하다. 디폴트로 잡혀있는 kr.archive.ubuntu.com은 많이 느린 편이고, 한국에서는 Daum이나 Neowiz 서버가 빠르긴한데 업데이트가 느리거나 불안정하다는 얘기가 있다. 한국 미러에 문제가 있는 경우, 일본에서 빠른 서버 찾아서 사용하면 된다. jaist를 많이 사용하는 것 같다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;터미널에서 업데이트 진행(Software &amp;amp; Updates 윈도우에서 진행해도 무관하다).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;
sudo apt-get update
sudo apt-get upgrade
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;그래픽 카드 설치&lt;/h2&gt;

&lt;h3&gt;AMD A10 5800K(APU)&lt;/h3&gt;

&lt;p&gt;일단 Ubuntu에서 기본적으로 지원하는 드라이버 Xorg로는 화면이 깨지는 현상이 있어서 AMD 쪽에서 나오는 서드파티 드라이버를 설치해야한다. &lt;code&gt;fglrx&lt;/code&gt;를 설치하면 화면이 깨지는 현상은 사라지는데 마우스 커서가 없어지는 문제가 있어서 &lt;code&gt;fglrx-update&lt;/code&gt;를 설치.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo apt-get install fglrx-update fglrx-update-dev&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이걸로 안 되면 삭제하고 &lt;code&gt;fglrx&lt;/code&gt; 설치.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo apt-get install fglrx fglrx-dev&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;듀얼 모니터 설정&lt;/h4&gt;

&lt;p&gt;단 &lt;code&gt;fglrx-update&lt;/code&gt;를 설치하니 듀얼모니터가 해상도 제한이 걸린다며 지정이 안 되는 문제가 발생했다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
sudo aticonfig --initial # /etc/X11/xorg.conf 생성.
sudo amdcccle
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;설정을 알고 있다면 직접 xorg.conf 생성 후 직접 편집해도 되지만, 잘 모른다면 AMD 드라이버 설정 관리자(amdcccle)를 열어서 듀얼 모니터를 잡아주면 된다. 여기서 화면 회전이나 추가적인 설정 가능.&lt;/p&gt;

&lt;h3&gt;NVidia GTX 560Ti&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
sudo apt-add-repository ppa:xorg-edgers/ppa
sudo apt-add-repository ppa:ubuntu-x-swat/x-updates
sudo apt-get update
sudo apt-get install nvidia-current
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;NVidia 카드의 경우 우분투 디폴트 그래픽 드라이버로도 사용은 가능하지만 부드럽지 못 하거나 느려서, Nvidia 전용 드라이버를 설치해주는 게 좋다. 위의 명령어들이 기본적인 설치 방법인데 설치할 수 있는 여러 버전들이 있으니 nvidia-current로 설치가 제대로 되지 않으면 버전명을 바꿔가며 설치해보는 게 좋다. 보통은 설치 후 재부팅이 필요하다.&lt;/p&gt;

&lt;p&gt;이 과정에서 드라이버가 제대로 작동하지 않아 화면이 먹통이 될 수 있는데, 이런 경우네 Alt + Ctrl + F1 을 눌러 가상 콘솔로 넘어가 터미널 환경에서 드라이버를 삭제하거나 다른 드라이버를 설치 후 재부팅하는 게 좋다. 이 외에도 공식 홈페이지에서 &lt;code&gt;.run&lt;/code&gt; 확장자를 가진 드라이버를 제공하기도 하는데 이 드라이버를 설치하고자 할 때는 해당파일에 실행 권한을 주고 관리자 권한으로 실행하면 된다.&lt;/p&gt;

&lt;h4&gt;QHD270&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;http://learnitwithme.com/wordpress/?p=342&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;개인적으로 이 과정에서 공식 드라이버 설치시 화면이 먹통이 되는 문제로 한참을 방황했는데 이는 그래픽 드라이버가 아니라 모니터 문제였다. 한국에서 생산된 27인치 모니터 중 2560 * 1440에 최적화된 모니터의 경우 제대로 출력이 되지 않는 경우가 있다. 이런 경우엔 위 링크를 참조해 문제를 해결하면 된다.&lt;/p&gt;

&lt;h3&gt;참고&lt;/h3&gt;

&lt;p&gt;일반적으로 어떤 그래픽 카드건 Software &amp;amp; Updates의 Additianal Drivers에서 사용가능한 드라이버를 확인할 수 있다. 일반적으로 하드웨어 벤더에서 제공하는 독점 드라이버를 선택하는 게 안정성이나 성능 면에서 월등하다. 문제가 있으면 여기에 뜨는 것들을 바꿔가며 테스트 해보고 구글링으로 해당하는 문제를 찾아보는 게 좋다. &lt;/p&gt;

&lt;h2&gt;Nabi 설정&lt;/h2&gt;

&lt;h3&gt;한글 입력기 Nabi 설치[^1]&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
sudo add-apt-repository ppa:createsc/copy4
sudo apt-get update
sudo apt-get install nabi
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;[^1]: 참고 http://www.ubuntu.or.kr/viewtopic.php?p=62810&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;System Settings&lt;/li&gt;
&lt;li&gt;Language Support&lt;/li&gt;
&lt;li&gt;키보드 입력기 : Hangul&lt;/li&gt;
&lt;li&gt;재부팅 or 로그아웃&lt;/li&gt;
&lt;li&gt;드보락 설정(필요시, 링크 참조)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;System Tray Whitelist 등록[^2]&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
sudo add-apt-repository ppa:mc3man/systray-white
sudo apt-get update
sudo apt-get upgrade
gsettings set com.canonical.Unity.Panel systray-whitelist &amp;quot;[&amp;#39;all&amp;#39;]&amp;quot;
sudo reboot
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;[^2]: 참조 http://www.ubuntu.or.kr/viewtopic.php?p=112275&lt;/p&gt;

&lt;h2&gt;방화병 설정 및 ssh 서버 설치&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
sudo ufw enable
sudo ufw allow 22/tcp
sudo apt-get install ssh
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;외부 접속 위해서 ssh-server 설치해줘야 되는 건지 원래 되는 건지(설치 되어있는지) 정확히 기억이 안난다. &lt;code&gt;uft&lt;/code&gt;은 방화벽 설정인데 기본적으로 포트가 다 열려있으므로, 사용하지 않는다면 생략해도 무방.&lt;/p&gt;

&lt;h2&gt;ssh key 생성&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
ssh-keygen -t rsa -C &amp;quot;&amp;lt;EmailAddress&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ssh key 생성 후, &lt;code&gt;~/.ssh/id_rsa.pub&lt;/code&gt; 파일 출력해서 github, bitbucket, gitlab에 등록 해 줌.&lt;/p&gt;

&lt;h2&gt;OpenVPN 세팅&lt;/h2&gt;

&lt;p&gt;```
sudo apt-get install openvpn&lt;/p&gt;

&lt;h1&gt;/etc/openvpn vpn 환경 설정 파일 설정&lt;/h1&gt;

&lt;p&gt;sudo service openvpn restart
```&lt;/p&gt;

&lt;p&gt;개인적으로는 로컬 서버에서 돌리는 것들이 있어서 openvpn 열어서 사용중. 필요하면 /etc/openvpn디렉토리에서 설정.&lt;/p&gt;

&lt;h2&gt;Unix 설정 파일 Clone&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
sudo apt-get install zsh tmux git
chsh # /bin/zsh
git clone git@&amp;lt;GIT_SERVER&amp;gt;:configuration/unix-config.git conf
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;환경설정 파일들은 마찬가지로 기존에 사용하는 것들 그대로 가져와서 사용. 개인적으로 private repository에서 관리중이고 클론해서 &lt;code&gt;~&lt;/code&gt;에서 &lt;code&gt;conf&lt;/code&gt; 디렉토리의 폴더로 심볼릭 링크 걸어서 사용. 필요한 게 추가로 있으면 scp로 기존 작업 환경에서 복사해서 사용. &lt;/p&gt;

&lt;h2&gt;Terminator 설치&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
sudo apt-get install terminator
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;터미네이터 설정 파일은 &lt;code&gt;.config/terminator/config&lt;/code&gt;. 보통은 scp로 원래 쓰던 거 가져다가 세팅했는데,이번엔 &lt;a href="https://github.com/ghuntley/terminator-solarized"&gt;terminator-solarized&lt;/a&gt; 테마도 같이사용해봤다.사용해보진 않았는데 Mac 쓰던 경우엔 &lt;a href="https://gist.github.com/olistik/3894072"&gt;이 gist&lt;/a&gt;도좋을 듯.&lt;/p&gt;

&lt;h2&gt;Eamcs 설치&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
sudo apt-get install emacs24 emacs24-common
git clone git@&amp;lt;GIT_SERVER&amp;gt;:configuration/emacs-config.git .emacs.d
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ubuntu 13.10에서는 emacs24를 바로 설치해서 사용 가능. 환경 설정에 기존에 사용하던 거 그대로 가져와서 사용.&lt;/p&gt;

&lt;h3&gt;the silver seacher 설치&lt;/h3&gt;

&lt;p&gt;ubuntu 13.10에서는 apt-get으로 바로 silver seacher 설치할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
sudo apt-get install silversearcher-ag
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;워크스페이스 활성화&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
sudo apt-get install compizconfig-settings-manager
&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Windows(Super) 키 누르고 &lt;code&gt;컴피즈 설정 관리자&lt;/code&gt; 실행.&lt;/li&gt;
&lt;li&gt;General =&amp;gt; 일반 설정&lt;/li&gt;
&lt;li&gt;데스크탑 크기 탭에서 &lt;code&gt;가로 가상 크기&lt;/code&gt;와 &lt;code&gt;세로 가상 크기&lt;/code&gt; 지정.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;워크스페이스 간 창 이동 단축키 변경&lt;/h3&gt;

&lt;p&gt;Ubuntu Unity에서는 워크스페이스간에 창 이동을 시킬때 컨트롤 + 쉬프트 + 알트 화살표를 사용하는데 Ubuntu 13.10에서는 기본적으로 양 옆 이동은 가능하나 위 아래 이동은 안 먹히는 문제가 있다. 이를 해결하기 위해서는,&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Windows(Super) 키 누르고 &lt;code&gt;컴피즈 설정 관리자&lt;/code&gt; 실행.&lt;/li&gt;
&lt;li&gt;Desktop =&amp;gt; Desktop Wall&lt;/li&gt;
&lt;li&gt;바로가기 탭의 Move with window within wall을 열고,&lt;/li&gt;
&lt;li&gt;단축키 다시 설정 해줌(연필 아이콘)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Ruby 설치&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
git clone https://github.com/sstephenson/rbenv.git ~/.rbenv
echo &amp;#39;export PATH=&amp;quot;$HOME/.rbenv/bin:$PATH&amp;quot;&amp;#39; &amp;gt;&amp;gt; ~/.zshrc
echo &amp;#39;eval &amp;quot;$(rbenv init -)&amp;quot;&amp;#39; &amp;gt;&amp;gt; ~/.zshrc
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;rbenv 설치. 기본적으로 README에는 bash 기준으로 설정이 되어있는데, 자신이 사용하는 쉘 설정 파일에 집어넣어준다(여기선 zsh). 필요하면 설정하고 쉘을 다시 실행시켜준다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
git clone https://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build
sudo apt-get install -qy build-essential zlib1g-dev libyaml-dev libssl-devlibgdbm-devlibreadline-dev libncurses5-dev libffi-dev curl libxml2-dev libxslt-devlibcurl4-openssl-dev libicu-dev
rbenv install 2.1.0
rbenv install 2.0.0-p353
rbenv install 1.9.3-p484
rbenv global 2.1.0
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ruby-build는 rbenv에서 루비 빌드를 하기 위한 플러그인. 위에서 설치하는 패키지들은 루비 빌드에 사용되는 패키지들.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
gem install travis middleman middleman-blog rails heroku --verbose
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;중요한 gem들 설치... 별로 중요해보이지 않지만 패스.&lt;/p&gt;

&lt;h2&gt;Hub 설치&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
git clone git://github.com/github/hub.git
cd hub/
sudo .rbenv/shims/rake install
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;적당한 디렉토리에 클론하고 &lt;code&gt;rake install&lt;/code&gt;로 설치.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
wget https://raw.github.com/github/hub/master/etc/hub.zsh_completion
sudo mv hub.zsh_completion /usr/local/share/zsh/site-functions/_hub
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;zsh용 자동완성 파일을 받아서 위의 디렉토리로 복사해준다. 아래 설정을 &lt;code&gt;.zshrc&lt;/code&gt; 파일에 추가해준다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
eval &amp;quot;$(hub alias -s)&amp;quot;
compdef git=hub
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;Wine 카카오톡 설치&lt;/h2&gt;

&lt;p&gt;현재 팀에서 사용하고 있는 메신저가 카카오톡이라 Wine로 카카오톡 설치 시도. &lt;/p&gt;

&lt;p&gt;&lt;code&gt;
sudo add-apt-repository ppa:ubuntu-wine/ppa
sudo apt-get upgrade
sudo apt-cache search &amp;quot;wine&amp;quot;
sudo apt-get install wine1.7
winetricks gdiplus
winetricks wmp9 
winetricks riched20
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wmp9&lt;/code&gt;은 메시지 알림음, &lt;code&gt;riched20&lt;/code&gt;은 한글 입력에 필요한 듯.&lt;/p&gt;

&lt;p&gt;한글 설정을 위해 굴림 폰트 구해서 wine 폴더 쪽으로 복사해주고 기본 폰트 쪽에 링크를 걸어준다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
mv gulim.ttc ../.wine/drive_c/windows/Fonts/
ln -s gulim.ttc batang.ttc
ln -s gulim.ttc dotum.ttc
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;~/.wine/system.reg&lt;/code&gt; 파일을 열어서 아래 부분을 찾아서,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
&amp;quot;MS Shell Dlg&amp;quot;=&amp;quot;Tahoma&amp;quot;
&amp;quot;MS Shell Dlg 2&amp;quot;=&amp;quot;Tahoma&amp;quot;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;아래 내용으로 바꿔준다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
&amp;quot;MS Shell Dlg&amp;quot;=&amp;quot;Gulim&amp;quot;
&amp;quot;MS Shell Dlg 2&amp;quot;=&amp;quot;Gulim&amp;quot;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://app.pc.kakao.com/talk/win32/KakaoTalk_Setup.exe"&gt;카카오톡 설치 파일&lt;/a&gt; 다운 받아서 실행. 한글이 깨지는 경우 적당이 추측해서 설치해준다.&lt;/p&gt;

&lt;p&gt;터미널에서 아래 명령어를 실행해본다. 이 때 카카오톡 아이콘 위치가 정확하지 않으면 직접 확인해준다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
wine C:\\windows\\command\\start.exe/Unix/home/daekwon/.wine/dosdevices/c:/users/Public/Desktop/카카오톡.lnk
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이렇게 실행했는데, 한글이 깨지면 카카오톡을 전부 종료하고 강제로 &lt;code&gt;LC_ALL&lt;/code&gt; 환경변수를 지정해 실행해본다. 이게 나 같은 경우에는 이번에 Ubuntu를 영어로 설치해서 그러니 Wine도 기본으로 Language가 영어로 잡혀서 폰트 설정만으로는 제대로 적용이 안 됐다. 이 환경변수를 사용해 한글이 잘 되면 카카오톡 설치시 바탕화면에 생기는 아이콘의 실행 경로에 &lt;code&gt;LC_ALL&lt;/code&gt; 환경변수를 지정해 놓는다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
LC_ALL=ko_KR.utf8 wine C:\\windows\\command\\start.exe/Unix/home/daekwon/.wine/dosdevices/c:/users/Public/Desktop/카카오톡.lnk
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;한글이 조금 구려보이긴 하지만 잘 되는 것은 확인.&lt;/p&gt;

&lt;h2&gt;개발용 &lt;a href="http://docker.io/"&gt;Docker&lt;/a&gt; 설치&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
curl -s https://get.docker.io/ubuntu/ | sudo sh
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;요새 서버에 도입하려고 궁리중인 Docker. 공식 사이트에서 제공해주는 스크립트 하나면 정말 간단히 설치할 수 있다. 자세항 내용은 &lt;a href="http://docs.docker.io/en/latest/installation/ubuntulinux/"&gt;공식 문서&lt;/a&gt; 확인.&lt;/p&gt;

&lt;h2&gt;정리&lt;/h2&gt;

&lt;p&gt;일단 중요한 부분은 다 정리한 듯. 이외에도 VirtualBox, Vagrant, Pandoc, Tex, python, 등등 설치해야되지만, 필요해지면 설치할 예정.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>정적 웹사이트 생성기의 유혹</title>
    <link rel="alternate" href="http://blog.nacyot.com/articles/2014-01-15-static-site-generator/"/>
    <id>http://blog.nacyot.com/articles/2014-01-15-static-site-generator/</id>
    <published>2014-01-05T03:00:00Z</published>
    <updated>2014-02-16T15:50:24+00:00</updated>
    <author>
      <name>nacyot(Daekwon Kim)</name>
    </author>
    <content type="html">&lt;p&gt;개인적으로 요새 화두인 주제가 바로 정적 웹사이트 생성기입니다. 21세기에 정적 웹사이트라니 꽤나 뜬금없는 이야기로 들리실지 모르겠지만 여기에 대해서는 약간 배경에 대해서 이해할 필요가 있습니다.&lt;/p&gt;

&lt;p&gt;분명히 &lt;strong&gt;정적&lt;/strong&gt;이라는 단어는 그 동안에 웹 어플리케이션이 발전해 온 데 있어서 정반대의 위치에 있는 단어입니다. &lt;strong&gt;정적&lt;/strong&gt;인 페이지란 말그대로 이미 완성된 HTML이고, 클라이언트의 요청을 받는 서버의 역할은 단순히 이렇게 완성되어 있는 HTML을 보내주는 역할을 할 뿐입니다. 이러한 모델은 우편부를 통해서 비유하기에 아주 적절합니다. 그렇다면 웹이 &lt;strong&gt;동적&lt;/strong&gt;으로 발전해왔다는 건 어떤 걸 의미할까요? 여기서 &lt;strong&gt;동적&lt;/strong&gt;이란 화려한 시각적 효과나 움직임을 지칭하는 단어가 아닙니다. 좀 더 정확히 말하자면 HTML 페이지를 클라이언트의 요청에 따라서 실시간으로 생성해서 보내준다는 의미를 가지고 있습니다. 그래서 이러한 웹 어플리케이션을 배울 때 가장 먼저 나오는 가장 간단한 예는 항상 이름을 받고서 이름을 출력해주는 예제입니다. 즉 서버는 완성된 HTML을 가지고 있지 않습니다. 거의 완성되어있거나, 심지어는 아무것도 없이도 요청에 따라 실시간으로 완성된 문서를 다시 보내줍니다. 즉, 여기서 서버란 웹서버 어플리케이션과 웹 어플리케이션을 함께 이야기합니다.&lt;/p&gt;

&lt;p&gt;하지만 본질적인 부분을 다시 생각해볼 필요가 있습니다. 정말로 &lt;strong&gt;동적&lt;/strong&gt;인 웹페이지란 필요한 걸까요? 단언컨데, 네 필요합니다. 질문을 바꿀 필요가 있습니다. 모든 경우에 정말로 &lt;strong&gt;동적&lt;/strong&gt;인 웹페이지가 필요한 걸까요? 여기에 &lt;strong&gt;모든 경우에&lt;/strong&gt;라는 수사를 통해서 저는 이도 저도 아닌 회색 영역을 만들었습니다. 네, 물론 아닙니다. 웹페이지 상에 동적으로 변해야하는 부분이 단 하나도 없다면, 완성된 HTML 형식으로 사이트를 공개해도 아무런 문제가 없습니다. 단지 우리는 21.1세기에 더 이상 그런 원시적인 웹 사이트는 거의 없다고 믿고 있을 뿐이죠.&lt;/p&gt;

&lt;p&gt;사실 &lt;strong&gt;정적&lt;/strong&gt;이라는 건 &lt;strong&gt;나쁜 것&lt;/strong&gt;이 아닙니다. 오히려 &lt;strong&gt;동적&lt;/strong&gt; 방식이야 말로 실시간으로 &lt;strong&gt;사이트를 생성&lt;/strong&gt;하는 데서 오는 굉장히 큰 비용을 감당해야합니다. 바로 이런 이유 때문에 &lt;strong&gt;어떤 프레임워크&lt;/strong&gt;를 사용할 것인가, &lt;strong&gt;어떤 언어&lt;/strong&gt;를 사용할 것인가 하는 게 굉장히 중요한 문제입니다. 제가 사랑해마지 않는 루비조차도 바로 이런 이유(즉 상대적으로 느리기 때문에!)로 언젠가 서비스가 커지면 갈아치워야할 프로토타입용이라고 생각되는 경우가 굉장히 많습니다. 물론 대부분의 서비스는 그 단계까지도 가지도 못 하고 프로토타입만 서비스하다  망합니다만....&lt;/p&gt;

&lt;p&gt;뭐, 그렇습니다.&lt;/p&gt;

&lt;p&gt;단순히 서버 수준의 스케일링까지 고려를 하지 않더라도 동적으로 웹페이지를 생성하는 일은 굉장히 느립니다. 이는 만들어져있는 즉석식품과와 주문 받으면 음식을 조리하는 방식의 차이입니다. 정적이 전자라면, 동적은 후자입니다. 당연히 느립니다. 그 차이가 비록 와닿지 않을 정도라고 하더라도 분명히 느리며, 또한 이러한 차이를 극복하기 위해 실제 웹서비스들에서는 캐시를 사용해 마치 자신이 정적 웹 페이지인 것 마냥 작동합니다. 캐시가 가능한 이유는 웹 어플리케이션의 많은 부분이 &lt;strong&gt;사실은&lt;/strong&gt; 정적이기 때문입니다. 즉, 요청마다 다르게 보여주는 부분은 실제로는 그렇게 많지 않다는 이야기입니다.&lt;/p&gt;

&lt;p&gt;정적인 자원은 다른 처리 비용을 발생시키지 않기 때문에 동적인 자원에 비해서 훨씬 더 빠릅니다. 그저 이미 만들어져있는 것을 보내주면 그만입니다. 앞에서 이야기했듯이 서버는 그저 우편부 역할을 할 뿐입니다. 여기서 오는 또 하나의 장점은 이렇게 미리 HTML 문서를 만들 경우 배포가 매우 쉽다는 점입니다. 어느 웹서버든 HTML은 serve할 수 있습니다. 복잡하게 어떤 언어를 쓰면 이렇게 하고 어떤 프레임워크를 써면 저렇게 하고 프록시 서버 써서 도메인 돌리고 그런 걸 고민할 필요가 없습니다. 싸구려 호스팅에 올려도 되고, 남는 서버에 올려도 되고, 아마존 S3에 올려도 되고, Github Pages로 배포할 수도 있습니다. 어플리케이션이 아니니 SQL injection 같은 보안 이슈도 없고요. 오오... 은근히 좋아보이네요. &lt;/p&gt;

&lt;p&gt;하지만!&lt;/p&gt;

&lt;p&gt;네, 이제, 웹 프레임워크는 다 버리고 HTML 하드 코딩하시면 되겠습니다.&lt;/p&gt;

&lt;p&gt;바로 여기입니다. 당연히 HTML을 직접 작성해야하는 &lt;strong&gt;정적&lt;/strong&gt; 방식이 좋다고는 결코 말할 수 없습니다. 즉 &lt;code&gt;2 * 10 + 1 * 1 + 1 * 0.1&lt;/code&gt; 세기에 다시 주목받는 정적 웹사이트란, 단순히 HTML을 Serve 해준다는 의미에서의 웹사이트를 말하는 것이 아니라 거기서 한 층 더 나아가 웹사이트를 동적으로 생성하되, 정적으로 Serve 한다는 의미에서 정적 웹사이트 생성기가 되는 것입니다. 이는 프로그래밍에 있어서 &lt;strong&gt;컴파일&lt;/strong&gt;의 사전적인 의미에 좀 더 가까운 작업입니다. 실제로 미리 모든 것을 만들어둔다는 점에서는 프로그래밍의 컴파일 개념과도 비슷합니다.&lt;/p&gt;

&lt;p&gt;예를 들어보죠. 이러한 방식을 적용할 수 있는 정말 좋은 플랫폼이 &lt;strong&gt;블로그&lt;/strong&gt;입니다. 블로그는 시작부터 HTML 문서들을 좀 더 쉽게 배포하기 위한 &lt;strong&gt;동적&lt;/strong&gt;인 플랫폼으로 출발했거나, 그런 목적으로 개발되었습니다. 하지만 문서 기반의 모든 플랫폼은 본질적으로 &lt;strong&gt;내가 가진 문서를 얼마나 잘 보여줄 것인가&lt;/strong&gt; 하는 문제가 가장 중요한 문제입니다. 그런데 여기서 &lt;strong&gt;문서&lt;/strong&gt;란 &lt;strong&gt;정적&lt;/strong&gt;입니다. 그러나 문서를 지원하는 다양한 페이지들은 동적입니다. 이런 페이지에는 페이징, 카테고리, 태그, 날짜 기반 페이지, Feed가 있습니다. 그런데 여기서 동적이라는 b말의 시점을 잘 따져볼 필요가 있습니다. 웹페이지가 동적으로 생성된다는 의미는 웹페이지가 &lt;code&gt;request&lt;/code&gt;되는 시점에서 동적으로 &lt;code&gt;response&lt;/code&gt;를 생성한다는 의미입니다. 그런데 페이징, 카테고리, 태그, 날짜 기반 페이지, Feed와 같은 블로그의 핵심 기능들은 request를 요청하는 시점이 아니라, 블로그 운영자가 포스트를 올리는 시점에 &lt;strong&gt;동적&lt;/strong&gt;입니다. 즉, 이 시점을 제외하고는 항상 아무것도 변하지 않습니다. 같은 &lt;strong&gt;동적&lt;/strong&gt;이라고 말해도 실제로는 시점이 페이지가 완결되는 시점이 다르다는 점입니다. 물론 글을 쓴 시점에 &lt;code&gt;response&lt;/code&gt;가 완성된다는 의미는 아닙니다. 대부분의 웹 어플리케이션은 lazy하기 때문에 처음 &lt;code&gt;request&lt;/code&gt;가 들어오는 시점에 해당 페이지를 적절히 생성하고 캐시합니다. 중요한 건 실제로는 포스트를 올린 시점에 블로그의 모든 페이지가 정적으로 완결될 수 있다는 점입니다. 즉 블로그의 모든 페이지를 미리 생성할 수 있습니다. 이미 이러한 방식을 지원하는 툴들이 이미 존재합니다. Jekyll을 기반으로하는 Octopress를 사용한다면 바로 글을 쓰는 시점에 블로그에 포함되는 모든 페이지를 &lt;strong&gt;정적 페이지&lt;/strong&gt;, 바꿔말해 HTML 파일로 만들어 줍니다.&lt;/p&gt;

&lt;p&gt;단, 여기에는 약간의 함정이 있습니다. 블로그에도 정말 적은 부분이지만 사용자의 요청이 발생하는 시점에서 실시간으로 동적으로 생성하고 반응해야하는 부분이 있습니다. 바로 댓글입니다. 이 부분은 따로 고민하지 않습니다. 그냥 댓글이 들어갈 부분에 &lt;a href="http://disqus.com/"&gt;Disqus&lt;/a&gt;를 삽입합니다.&lt;/p&gt;

&lt;p&gt;이렇듯 의외로 블로그는 정적인 웹 플랫폼입니다. 근데 더 큰 함정이 있군요. 이렇게 만들면 블로그에 글은 어떻게 쓸까요? 다르게 말하면 블로그에서 가장 동적인 부분은 글을 작성하는 부분입니다. 이런 부분은 정적 블로그 생성기에서는 존재하지 않습니다. 여기서 모든 포스트는 그저 마크다운 파일일 뿐입니다. 또한 글이 작성된 시점이나 사이트에 기능이나 페이지가 더해진 시점을 일반적으로 Git 저장소에 push가 일어난 시점으로 판단합니다. 이런 부분은 일반인들이 이런 툴을 사용하기에 매우 프로그래머스럽습니다. 하지만 프로그래머들에게 이런 점은 다른 방향에서 자유를 선사합니다. 바로 블로그 글을 자신이 원하는 에디터로 작성 할 수 있다는 점입니다. 저는 지금 이 글을 제가 애용하는 에디터인 Emacs 위에서 작성하고 있습니다. 예전부터 블로그나 위키를 운영하면서 에디터 통합을 꿈꾸던 입장에서는 지금은 너무 쉽게 이런 접근이 가능합니다. 물론 또다른 방향에서 웹 편집기들은 발전하고 있습니다. &lt;a href="https://github.com/HackerWins/summernote"&gt;Summernote&lt;/a&gt;와 같은 부트스트랩 기반의 에디터도 있고 &lt;a href="http://ghost.org"&gt;Ghost&lt;/a&gt;와 같은 마크다운 프리뷰를 바로 보여주는 훌륭한 플랫폼도 있습니다. Mediawiki에는 웹문서에서 바로 편집을 하는 것 같은 경험을 제공하는 &lt;a href="http://www.mediawiki.org/wiki/VisualEditor"&gt;Visual Editor&lt;/a&gt; 같은 확장도 있습니다.[^1] 많은 훌륭한 시도들이 있습니다만 여전히 웹에서 글을 작성한다는 것은 전용 에디터에 비해서 매우 불만족스러운 일입니다. 반면에 마크다운 파일을 기반으로 하고 있다면 그저 텍스트 문서를 원하는 에디터에서 작성하면 그만입니다.&lt;/p&gt;

&lt;p&gt;[^1]: http://www.mediawiki.org/wiki/VisualEditor 에서 직접 edit를 해보시기 바랍니다.&lt;/p&gt;

&lt;p&gt;아시는 분은 아시겠지만! 이미 &lt;a href="http://github.com"&gt;Github&lt;/a&gt;을 적극 활용하는 많은 분들은 Github Pages와 Github에서 지원하는 루비 기반의 정적 웹페이지 생성기(이자 Github CEO가 만든)인 &lt;a href="http://jekyllrb.com/"&gt;Jekyll&lt;/a&gt;을 적극 활용해서 블로그나 사이트를 운영하고 있습니다. 단순히 블로그에서만 사용할 수 있는 건 아닙니다. 이미 괜찮은 블로그 솔루션들이 마련되어 있기에 편하게 사용할 수 있는 것 뿐이지, 결과적으로 정적인 사이트라면 얼마든지 생성할 수 있습니다. 루비 커뮤니티에서 두 번째로 유명한 &lt;a href="http://middlemanapp.com/community/built-using-middleman/"&gt;Middleman으로 생성한 사례들&lt;/a&gt;도 매우 많습니다. 이 사이트도 Middleman으로 만들어졌고, 글을 작성하면 &lt;a href="https://travis-ci.org/"&gt;Travis&lt;/a&gt;를 통해 빌드하고, 다시 변경된 내용을 Github Repository에 반영해 Github Pages로 배포되고 있습니다. 이러한 활용 방법에 대해서는 다른 포스트에서 좀 더 자세히 다루겠습니다. 이 외에도 &lt;a href="http://staticsitegenerators.net/"&gt;Static Site Generator&lt;/a&gt;와 &lt;a href="http://modernstatic.com/"&gt;Modern Static&lt;/a&gt;에서는 다양한 정적 웹페이지 생성기들을 소개하고 있습니다.&lt;/p&gt;

&lt;p&gt;당연하게도 이런 정적 페이지 생성기들은 정적 페이지를 통한 배포의 이점을 전부 그대로 누립니다. 그냥 HTML 문서니까요. 동시에 빌드 시점에서는 프로그래밍 언어의 강력함도 누릴 수 있습니다. &lt;/p&gt;

&lt;p&gt;결국에 중요한 문제는 어느 시점에서 &lt;strong&gt;동적&lt;/strong&gt;이면 되는가의 문제로 귀결됩니다. 블로그가 정적 웹페이지로도 만들어질 수도 있는 건 모든 시점에 동적일 필요가 없었기 때문입니다. 반면에 소셜 사이트를 정적 웹페이지로 만드는 건 거의 불가능하다고 봐도 되겠죠. 네, 케바케입니다. 하지만 분명한 건 정적 웹페이지로 만들 수 있는 페이지를 동적 어플리케이션으로 서버에 물려놓는 건 사이트 구축은 그렇다고 쳐도, 운영 면에서 불리합니다. 정적 웹페이지 생성기는 중간쯤 어딘가에서 어떤 공백을 메워줍니다.&lt;/p&gt;

&lt;p&gt;네, 모든 종류의 웹사이트가 정적일 수는 없습니다. 거꾸로 모든 종류의 웹사이트가 동적일 필요도 없는 거고, 적절한 타협점이 필요한 거죠.&lt;/p&gt;
</content>
  </entry>
</feed>
